[17:07:10] Checking Database
[17:07:10] LP Module Load
[17:07:10] Selecting scheduler: OldDefaultScheduler
[17:07:10] Server change to arsbitcoin
[17:07:10] Updating Difficulty
[17:07:10] writing to database
[17:07:12] Updating NameCoin Difficulty
[17:07:12] LP Call http://btcworld.de:8332/LP
[17:07:12] LP Call http://pool.bloodys.com:8332/LP
[17:07:12] LP Call http://swepool.net:8337/LP
[17:07:12] LP Call http://arsbitcoin.com:8344/LP
[17:07:12] LP Call http://pit.deepbit.net:8332/listenChannel
[17:07:13] digbtc:	1800592	  
[17:07:13] RPC request [] submitted to arsbitcoin
[17:07:13] LP Call http://digbtc.net:8332/LP
[17:07:13] LP Call http://ozco.in:8332/LP
[17:07:13] LP Call http://pool.bitclockers.com:8332/LP
[17:07:13] LP Call http://mtred.com:8837/LP
[17:07:13] RPC request [] submitted to arsbitcoin
[17:07:13] LP Call http://btcserv.net:8335/LP
[17:07:13] triple:	7560852	  
[17:07:14] RPC request [] submitted to arsbitcoin
[17:07:14] arsbitcoin:	1311311	  
[17:07:14] bloodys:	2150890	  
[17:07:15] swepool:	4654952	  3.6gh/s 	34055min.
[17:07:16] ozco:	1856974	  65.5gh/s 	1212min.
[17:07:17] RPC request [] submitted to arsbitcoin
[17:07:17] bitclockers:	1065182	  224.2gh/s 
[17:07:17] RPC request [] submitted to arsbitcoin
[17:07:18] bithasher:	2381008	  
[17:07:18] RPC request [] submitted to arsbitcoin
[17:07:18] slush:	576449	  1868.4gh/s 	22min.
[17:07:18] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000001ea59d6d44a13eb2457b0527a4e5306ad43a4cc1de23aa251f1789f96a4f99424e53b44c1a094a86dba1d000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to arsbitcoin
[17:07:19] RPC request [] submitted to arsbitcoin
[17:07:20] btcmonkey:	4309671	  2.1gh/s 
[17:07:21] mtred:	1148981	  200.8gh/s 
[17:07:21] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000ca68664f50ef3244cc8198baa4eda0eb10495985d19d683644815fabf3f7a5994e53b44d1a094a86dbd96409000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to arsbitcoin
[17:07:21] btcworld:	482801	  
[17:07:21] Server change to btcworld
[17:07:21] RPC request [] submitted to arsbitcoin
[17:07:21] btcserv:	1473033	  
[17:07:21] RPC request [] submitted to btcworld
[17:07:21] deepbit:	1821026	  5750.0gh/s 
[17:07:21] RPC request [] submitted to btcworld
[17:07:22] RPC request [] submitted to btcworld
[17:07:25] RPC request [] submitted to btcworld
[17:07:26] RPC request [] submitted to btcworld
[17:07:26] RPC request [] submitted to btcworld
[17:07:29] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000ce562a3da83f9bafa9749c2989e436e4c26a4f59d88a4009df4ea1b7cde731454e53b4001a094a86b6c74011000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:07:29] RPC request [] submitted to btcworld
[17:07:29] RPC request [] submitted to btcworld
[17:07:30] RPC request [] submitted to btcworld
[17:07:30] RPC request [] submitted to btcworld
[17:07:34] RPC request [] submitted to btcworld
[17:07:34] RPC request [] submitted to btcworld
[17:07:35] RPC request [] submitted to btcworld
[17:07:38] RPC request [] submitted to btcworld
[17:07:38] RPC request [] submitted to btcworld
[17:07:39] RPC request [] submitted to btcworld
[17:07:40] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000036c0bda55b9eb8d5cb115af7b107f45731bf81c1007008e4cb3795c97afa8c0b4e53b40e1a094a8634bf8208000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:07:40] RPC request [] submitted to btcworld
[17:07:42] RPC request [] submitted to btcworld
[17:07:42] RPC request [] submitted to btcworld
[17:07:43] RPC request [] submitted to btcworld
[17:07:46] RPC request [] submitted to btcworld
[17:07:46] RPC request [] submitted to btcworld
[17:07:47] RPC request [] submitted to btcworld
[17:07:50] RPC request [] submitted to btcworld
[17:07:50] RPC request [] submitted to btcworld
[17:07:51] RPC request [] submitted to btcworld
[17:07:54] RPC request [] submitted to btcworld
[17:07:55] RPC request [] submitted to btcworld
[17:07:55] RPC request [] submitted to btcworld
[17:07:58] RPC request [] submitted to btcworld
[17:07:59] RPC request [] submitted to btcworld
[17:07:59] RPC request [] submitted to btcworld
[17:08:03] RPC request [] submitted to btcworld
[17:08:03] RPC request [] submitted to btcworld
[17:08:03] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000def6ee0ed600d0188b22a4a8ac652ae6fb0841bacec8682972a9f6c42cde9df94e53b4261a094a8628a8eb02000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:08:03] RPC request [] submitted to btcworld
[17:08:04] RPC request [] submitted to btcworld
[17:08:07] RPC request [] submitted to btcworld
[17:08:07] RPC request [] submitted to btcworld
[17:08:08] RPC request [] submitted to btcworld
[17:08:08] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c880a2f33623737706b35cc99a5a39793097ddf21b6bc8a14271021a317ae91f4e53b42a1a094a862cc13104000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:08:08] RPC request [] submitted to btcworld
[17:08:11] RPC request [] submitted to btcworld
[17:08:11] RPC request [] submitted to btcworld
[17:08:12] RPC request [] submitted to btcworld
[17:08:13] writing to database
[17:08:13] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000000ca9530fa516cddadedf817ee809b8502744d3822c92fa9149d8225d9ab677384e53b42e1a094a86eae26c08000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:08:13] RPC request [] submitted to btcworld
[17:08:15] RPC request [] submitted to btcworld
[17:08:15] RPC request [] submitted to btcworld
[17:08:16] RPC request [] submitted to btcworld
[17:08:19] RPC request [] submitted to btcworld
[17:08:19] RPC request [] submitted to btcworld
[17:08:20] RPC request [] submitted to btcworld
[17:08:23] RPC request [] submitted to btcworld
[17:08:23] RPC request [] submitted to btcworld
[17:08:24] RPC request [] submitted to btcworld
[17:08:27] RPC request [] submitted to btcworld
[17:08:28] RPC request [] submitted to btcworld
[17:08:28] RPC request [] submitted to btcworld
[17:08:32] RPC request [] submitted to btcworld
[17:08:32] RPC request [] submitted to btcworld
[17:08:33] RPC request [] submitted to btcworld
[17:08:36] RPC request [] submitted to btcworld
[17:08:36] RPC request [] submitted to btcworld
[17:08:37] RPC request [] submitted to btcworld
[17:08:39] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000b9f511ebe4ffa170cd0ea2884f4d77650ac3ebbce2e21120bee8337b470a64d54e53b4471a094a86dc7ef413000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:08:40] RPC request [] submitted to btcworld
[17:08:40] RPC request [] submitted to btcworld
[17:08:40] RPC request [] submitted to btcworld
[17:08:41] RPC request [] submitted to btcworld
[17:08:44] RPC request [] submitted to btcworld
[17:08:44] RPC request [] submitted to btcworld
[17:08:45] RPC request [] submitted to btcworld
[17:08:48] RPC request [] submitted to btcworld
[17:08:48] RPC request [] submitted to btcworld
[17:08:49] RPC request [] submitted to btcworld
[17:08:52] RPC request [] submitted to btcworld
[17:08:52] RPC request [] submitted to btcworld
[17:08:53] RPC request [] submitted to btcworld
[17:08:56] RPC request [] submitted to btcworld
[17:08:57] RPC request [] submitted to btcworld
[17:08:57] RPC request [] submitted to btcworld
[17:09:01] RPC request [] submitted to btcworld
[17:09:01] RPC request [] submitted to btcworld
[17:09:02] RPC request [] submitted to btcworld
[17:09:05] RPC request [] submitted to btcworld
[17:09:05] RPC request [] submitted to btcworld
[17:09:05] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000007f993d3dbb9bc19c9654b7fef784163ec250aacd38f1296e16ca2e06bd66edbd4e53b4641a094a8658453901000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:09:05] RPC request [] submitted to btcworld
[17:09:06] RPC request [] submitted to btcworld
[17:09:09] RPC request [] submitted to btcworld
[17:09:09] RPC request [] submitted to btcworld
[17:09:09] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000000f96255cae2a3efbf439c2b0a11c48add99d61da40d6c49a8e439f77bde6e0fb4e53b4641a094a86d9a9ae16000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:09:09] RPC request [] submitted to btcworld
[17:09:10] RPC request [] submitted to btcworld
[17:09:13] writing to database
[17:09:13] RPC request [] submitted to btcworld
[17:09:13] digbtc:	1800711	  
[17:09:13] RPC request [] submitted to btcworld
[17:09:13] triple:	7561551	  
[17:09:14] RPC request [] submitted to btcworld
[17:09:15] swepool:	4655043	  3.6gh/s 	34057min.
[17:09:15] arsbitcoin:	1347879	  
[17:09:17] RPC request [] submitted to btcworld
[17:09:17] RPC request [] submitted to btcworld
[17:09:18] RPC request [] submitted to btcworld
[17:09:18] slush:	630849	  1868.5gh/s 	24min.
[17:09:18] bithasher:	2381214	  
[17:09:21] btcmonkey:	4309731	  2.1gh/s 
[17:09:21] btcserv:	1473104	  
[17:09:21] RPC request [] submitted to btcworld
[17:09:21] RPC request [] submitted to btcworld
[17:09:22] deepbit:	1982412	  5764.0gh/s 
[17:09:22] RPC request [] submitted to btcworld
[17:09:25] RPC request [] submitted to btcworld
[17:09:26] RPC request [] submitted to btcworld
[17:09:26] RPC request [] submitted to btcworld
[17:09:30] RPC request [] submitted to btcworld
[17:09:30] RPC request [] submitted to btcworld
[17:09:31] RPC request [] submitted to btcworld
[17:09:34] RPC request [] submitted to btcworld
[17:09:34] RPC request [] submitted to btcworld
[17:09:35] RPC request [] submitted to btcworld
[17:09:37] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000059a82a74fae51f024031864603a2ccfa9be008b0c2d534b7d1acf29b4d51c0bb4e53b4811a094a86fc8dd411000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:09:37] RPC request [] submitted to btcworld
[17:09:38] RPC request [] submitted to btcworld
[17:09:38] RPC request [] submitted to btcworld
[17:09:39] RPC request [] submitted to btcworld
[17:09:42] RPC request [] submitted to btcworld
[17:09:42] RPC request [] submitted to btcworld
[17:09:43] RPC request [] submitted to btcworld
[17:09:46] RPC request [] submitted to btcworld
[17:09:46] RPC request [] submitted to btcworld
[17:09:47] RPC request [] submitted to btcworld
[17:09:50] RPC request [] submitted to btcworld
[17:09:50] RPC request [] submitted to btcworld
[17:09:51] RPC request [] submitted to btcworld
[17:09:54] RPC request [] submitted to btcworld
[17:09:55] RPC request [] submitted to btcworld
[17:09:55] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000005bc5fd7f2c788778eb10323b4f7b9300a7c62dc0626a0c670ae2b1f867d66c9d4e53b4921a094a8696a83716000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:09:55] RPC request [] submitted to btcworld
[17:09:55] RPC request [] submitted to btcworld
[17:09:59] RPC request [] submitted to btcworld
[17:09:59] RPC request [] submitted to btcworld
[17:10:00] RPC request [] submitted to btcworld
[17:10:03] RPC request [] submitted to btcworld
[17:10:03] RPC request [] submitted to btcworld
[17:10:04] RPC request [] submitted to btcworld
[17:10:04] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000005874fd1068271e598a864620b1f7d8e5dcf6e4c1f853344094511cc35168660a4e53b49e1a094a86a21b0706000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:10:04] RPC request [] submitted to btcworld
[17:10:06] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000039016692e8239adac2d4da008a09702dac5d7b301f4533dd218202a71fe3f75d4e53b49e1a094a86b634b213000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:10:07] RPC request [] submitted to btcworld
[17:10:07] RPC request [] submitted to btcworld
[17:10:07] RPC request [] submitted to btcworld
[17:10:08] RPC request [] submitted to btcworld
[17:10:11] RPC request [] submitted to btcworld
[17:10:11] RPC request [] submitted to btcworld
[17:10:12] RPC request [] submitted to btcworld
[17:10:13] writing to database
[17:10:15] RPC request [] submitted to btcworld
[17:10:15] RPC request [] submitted to btcworld
[17:10:16] RPC request [] submitted to btcworld
[17:10:18] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000518393de261387a3bbe89f86411f5c78e4c3e67120af24b06413b58e136b07d74e53b4ab1a094a86262b1708000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:10:18] RPC request [] submitted to btcworld
[17:10:19] RPC request [] submitted to btcworld
[17:10:19] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000054ad13cd0734db2fbb7fb55149275304a1f7763813f1478fd7e81304074a123d4e53b4ad1a094a86f2c1ff06000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:10:19] RPC request [] submitted to btcworld
[17:10:19] RPC request [] submitted to btcworld
[17:10:20] RPC request [] submitted to btcworld
[17:10:23] RPC request [] submitted to btcworld
[17:10:24] RPC request [] submitted to btcworld
[17:10:24] RPC request [] submitted to btcworld
[17:10:28] RPC request [] submitted to btcworld
[17:10:28] RPC request [] submitted to btcworld
[17:10:29] RPC request [] submitted to btcworld
[17:10:32] RPC request [] submitted to btcworld
[17:10:32] RPC request [] submitted to btcworld
[17:10:33] RPC request [] submitted to btcworld
[17:10:36] RPC request [] submitted to btcworld
[17:10:36] RPC request [] submitted to btcworld
[17:10:37] RPC request [] submitted to btcworld
[17:10:40] RPC request [] submitted to btcworld
[17:10:40] RPC request [] submitted to btcworld
[17:10:41] RPC request [] submitted to btcworld
[17:10:42] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000df51a6fa9e3d0e1fbd39f989a0bdd6784bfbf2c04b30cfc7e3f7116dbf4d25064e53b4c31a094a861e773a08000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:10:42] RPC request [] submitted to btcworld
[17:10:43] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000081328423be1ac794e90aee51b17d7847f11116c5f7e1bc5aa8309752db452184e53b4c31a094a864f0adc0e000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:10:43] RPC request [] submitted to btcworld
[17:10:44] RPC request [] submitted to btcworld
[17:10:44] RPC request [] submitted to btcworld
[17:10:45] RPC request [] submitted to btcworld
[17:10:48] RPC request [] submitted to btcworld
[17:10:48] RPC request [] submitted to btcworld
[17:10:49] RPC request [] submitted to btcworld
[17:10:52] RPC request [] submitted to btcworld
[17:10:53] RPC request [] submitted to btcworld
[17:10:53] RPC request [] submitted to btcworld
[17:10:57] RPC request [] submitted to btcworld
[17:10:57] RPC request [] submitted to btcworld
[17:10:58] RPC request [] submitted to btcworld
[17:11:01] RPC request [] submitted to btcworld
[17:11:01] RPC request [] submitted to btcworld
[17:11:02] RPC request [] submitted to btcworld
[17:11:05] RPC request [] submitted to btcworld
[17:11:05] RPC request [] submitted to btcworld
[17:11:06] RPC request [] submitted to btcworld
[17:11:09] RPC request [] submitted to btcworld
[17:11:09] RPC request [] submitted to btcworld
[17:11:10] RPC request [] submitted to btcworld
[17:11:13] writing to database
[17:11:13] RPC request [] submitted to btcworld
[17:11:13] RPC request [] submitted to btcworld
[17:11:14] digbtc:	1800829	  
[17:11:14] triple:	7562234	  
[17:11:14] RPC request [] submitted to btcworld
[17:11:15] swepool:	4655141	  3.6gh/s 	34059min.
[17:11:17] RPC request [] submitted to btcworld
[17:11:17] RPC request [] submitted to btcworld
[17:11:18] RPC request [] submitted to btcworld
[17:11:18] slush:	686050	  1868.0gh/s 	26min.
[17:11:19] bithasher:	2381404	  
[17:11:21] ozco:	1864917	  63.5gh/s 	1216min.
[17:11:21] btcserv:	1473180	  
[17:11:22] RPC request [] submitted to btcworld
[17:11:22] RPC request [] submitted to btcworld
[17:11:22] deepbit:	2143727	  5761.0gh/s 
[17:11:22] btcmonkey:	4309783	  2.0gh/s 
[17:11:22] mtred:	1163783	  211.9gh/s 
[17:11:22] RPC request [] submitted to btcworld
[17:11:26] RPC request [] submitted to btcworld
[17:11:26] RPC request [] submitted to btcworld
[17:11:27] RPC request [] submitted to btcworld
[17:11:30] RPC request [] submitted to btcworld
[17:11:30] RPC request [] submitted to btcworld
[17:11:31] RPC request [] submitted to btcworld
[17:11:33] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000005053a7da7512e24e3e917ea4612de74e57ddf704fb93e26aaba86dc14ce4de5d4e53b4f51a094a86ac7b300f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:11:33] RPC request [] submitted to btcworld
[17:11:34] RPC request [] submitted to btcworld
[17:11:34] RPC request [] submitted to btcworld
[17:11:35] RPC request [] submitted to btcworld
[17:11:38] RPC request [] submitted to btcworld
[17:11:38] RPC request [] submitted to btcworld
[17:11:39] RPC request [] submitted to btcworld
[17:11:42] RPC request [] submitted to btcworld
[17:11:42] RPC request [] submitted to btcworld
[17:11:43] RPC request [] submitted to btcworld
[17:11:46] RPC request [] submitted to btcworld
[17:11:46] RPC request [] submitted to btcworld
[17:11:47] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000a6d53882af73c823d8bc4c30245c9bbcda3d5963d820b67e3fda781f9b4860164e53b5061a094a86a0a96001000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:11:47] RPC request [] submitted to btcworld
[17:11:47] RPC request [] submitted to btcworld
[17:11:51] RPC request [] submitted to btcworld
[17:11:51] RPC request [] submitted to btcworld
[17:11:51] RPC request [] submitted to btcworld
[17:11:55] RPC request [] submitted to btcworld
[17:11:55] RPC request [] submitted to btcworld
[17:11:56] RPC request [] submitted to btcworld
[17:11:57] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000071b07942fe2edb5bef3ebb53bae6e10090767ac139c77919244aa21fd599d31d4e53b50f1a094a8685724903000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:11:57] RPC request [] submitted to btcworld
[17:12:00] RPC request [] submitted to btcworld
[17:12:00] RPC request [] submitted to btcworld
[17:12:00] RPC request [] submitted to btcworld
[17:12:04] RPC request [] submitted to btcworld
[17:12:04] RPC request [] submitted to btcworld
[17:12:04] RPC request [] submitted to btcworld
[17:12:08] RPC request [] submitted to btcworld
[17:12:08] RPC request [] submitted to btcworld
[17:12:08] RPC request [] submitted to btcworld
[17:12:12] RPC request [] submitted to btcworld
[17:12:12] RPC request [] submitted to btcworld
[17:12:12] RPC request [] submitted to btcworld
[17:12:13] writing to database
[17:12:16] RPC request [] submitted to btcworld
[17:12:16] RPC request [] submitted to btcworld
[17:12:16] RPC request [] submitted to btcworld
[17:12:20] RPC request [] submitted to btcworld
[17:12:20] RPC request [] submitted to btcworld
[17:12:20] RPC request [] submitted to btcworld
[17:12:24] RPC request [] submitted to btcworld
[17:12:24] RPC request [] submitted to btcworld
[17:12:25] RPC request [] submitted to btcworld
[17:12:29] RPC request [] submitted to btcworld
[17:12:29] RPC request [] submitted to btcworld
[17:12:29] RPC request [] submitted to btcworld
[17:12:33] RPC request [] submitted to btcworld
[17:12:33] RPC request [] submitted to btcworld
[17:12:33] RPC request [] submitted to btcworld
[17:12:37] RPC request [] submitted to btcworld
[17:12:37] RPC request [] submitted to btcworld
[17:12:37] RPC request [] submitted to btcworld
[17:12:41] RPC request [] submitted to btcworld
[17:12:41] RPC request [] submitted to btcworld
[17:12:41] RPC request [] submitted to btcworld
[17:12:45] RPC request [] submitted to btcworld
[17:12:45] RPC request [] submitted to btcworld
[17:12:45] RPC request [] submitted to btcworld
[17:12:49] RPC request [] submitted to btcworld
[17:12:49] RPC request [] submitted to btcworld
[17:12:49] RPC request [] submitted to btcworld
[17:12:53] RPC request [] submitted to btcworld
[17:12:53] RPC request [] submitted to btcworld
[17:12:54] RPC request [] submitted to btcworld
[17:12:55] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000007e33bc6acb752109126f204e9d9d572cbf039e38bce10e0a91fb62dd0e49cbb4e53b5491a094a867c1faa04000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:12:55] RPC request [] submitted to btcworld
[17:12:58] RPC request [] submitted to btcworld
[17:12:58] RPC request [] submitted to btcworld
[17:12:58] RPC request [] submitted to btcworld
[17:13:02] RPC request [] submitted to btcworld
[17:13:02] RPC request [] submitted to btcworld
[17:13:02] RPC request [] submitted to btcworld
[17:13:06] RPC request [] submitted to btcworld
[17:13:06] RPC request [] submitted to btcworld
[17:13:06] RPC request [] submitted to btcworld
[17:13:09] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000001d88daa3faae8e23362e461bdc87995136fc2b6f0b24291148e8de82e2960e994e53b5551a094a8639aad511000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:13:09] RPC request [] submitted to btcworld
[17:13:10] RPC request [] submitted to btcworld
[17:13:10] RPC request [] submitted to btcworld
[17:13:10] RPC request [] submitted to btcworld
[17:13:13] writing to database
[17:13:14] triple:	7562756	  
[17:13:14] digbtc:	1800905	  
[17:13:14] RPC request [] submitted to btcworld
[17:13:14] RPC request [] submitted to btcworld
[17:13:14] RPC request [] submitted to btcworld
[17:13:15] swepool:	4655245	  3.6gh/s 	34061min.
[17:13:15] bloodys:	2151052	  
[17:13:16] arsbitcoin:	1384672	  
[17:13:18] RPC request [] submitted to btcworld
[17:13:18] bitclockers:	1075403	  224.6gh/s 
[17:13:18] RPC request [] submitted to btcworld
[17:13:18] slush:	728451	  1869.9gh/s 	27min.
[17:13:18] RPC request [] submitted to btcworld
[17:13:19] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000003ee3f33cbd8aef3365e90d5bd3a432fcb8030c34c4068a6fabd0de8cb2b5fd074e53b5621a094a86a2ef3e04000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:13:20] RPC request [] submitted to btcworld
[17:13:20] bithasher:	2381624	  
[17:13:22] btcserv:	1473250	  
[17:13:22] deepbit:	2305051	  5759.0gh/s 
[17:13:22] RPC request [] submitted to btcworld
[17:13:23] RPC request [] submitted to btcworld
[17:13:23] RPC request [] submitted to btcworld
[17:13:24] btcmonkey:	4309838	  2.0gh/s 
[17:13:27] RPC request [] submitted to btcworld
[17:13:27] RPC request [] submitted to btcworld
[17:13:27] RPC request [] submitted to btcworld
[17:13:30] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000f31af72d07a4a6ca4c5dc8e3220032703bd8d68932460b512fb1fdc10ff4dba44e53b56a1a094a86189f7e14000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:13:31] RPC request [] submitted to btcworld
[17:13:31] RPC request [] submitted to btcworld
[17:13:31] RPC request [] submitted to btcworld
[17:13:31] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000922ab2c6ad6f43061a6e74c79023f5c8c7312630cc79d68317285f4a3fb298864e53b56a1a094a869a3e5b17000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:13:31] RPC request [] submitted to btcworld
[17:13:31] RPC request [] submitted to btcworld
[17:13:35] RPC request [] submitted to btcworld
[17:13:35] RPC request [] submitted to btcworld
[17:13:35] RPC request [] submitted to btcworld
[17:13:39] RPC request [] submitted to btcworld
[17:13:39] RPC request [] submitted to btcworld
[17:13:39] RPC request [] submitted to btcworld
[17:13:43] RPC request [] submitted to btcworld
[17:13:43] RPC request [] submitted to btcworld
[17:13:43] RPC request [] submitted to btcworld
[17:13:47] RPC request [] submitted to btcworld
[17:13:47] RPC request [] submitted to btcworld
[17:13:48] RPC request [] submitted to btcworld
[17:13:51] RPC request [] submitted to btcworld
[17:13:52] RPC request [] submitted to btcworld
[17:13:52] RPC request [] submitted to btcworld
[17:13:56] RPC request [] submitted to btcworld
[17:13:56] RPC request [] submitted to btcworld
[17:13:56] RPC request [] submitted to btcworld
[17:14:00] RPC request [] submitted to btcworld
[17:14:00] RPC request [] submitted to btcworld
[17:14:00] RPC request [] submitted to btcworld
[17:14:01] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000d4ecd04e189e76c3ad1eb3d9f207a8a1f98d3869cfac6213ed2cdf248949c6ee4e53b58b1a094a86abf15405000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:14:01] RPC request [] submitted to btcworld
[17:14:04] RPC request [] submitted to btcworld
[17:14:04] RPC request [] submitted to btcworld
[17:14:04] RPC request [] submitted to btcworld
[17:14:06] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000e5302721e7bd45618fc1c32bab13aaff89f488fff253b993676f2407996a3bbf4e53b58f1a094a86ddcf1407000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:14:06] RPC request [] submitted to btcworld
[17:14:08] RPC request [] submitted to btcworld
[17:14:08] RPC request [] submitted to btcworld
[17:14:08] RPC request [] submitted to btcworld
[17:14:12] RPC request [] submitted to btcworld
[17:14:12] RPC request [] submitted to btcworld
[17:14:12] RPC request [] submitted to btcworld
[17:14:13] writing to database
[17:14:16] RPC request [] submitted to btcworld
[17:14:16] RPC request [] submitted to btcworld
[17:14:16] RPC request [] submitted to btcworld
[17:14:20] RPC request [] submitted to btcworld
[17:14:21] RPC request [] submitted to btcworld
[17:14:21] RPC request [] submitted to btcworld
[17:14:25] RPC request [] submitted to btcworld
[17:14:25] RPC request [] submitted to btcworld
[17:14:25] RPC request [] submitted to btcworld
[17:14:29] RPC request [] submitted to btcworld
[17:14:29] RPC request [] submitted to btcworld
[17:14:29] RPC request [] submitted to btcworld
[17:14:31] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000cae1cf6b88002340d5994f59f1d060337c797c4a7fd6dbd7a504d73453515e094e53b5a81a094a86699c1f0d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:14:31] RPC request [] submitted to btcworld
[17:14:33] RPC request [] submitted to btcworld
[17:14:33] RPC request [] submitted to btcworld
[17:14:33] RPC request [] submitted to btcworld
[17:14:37] RPC request [] submitted to btcworld
[17:14:37] RPC request [] submitted to btcworld
[17:14:37] RPC request [] submitted to btcworld
[17:14:41] RPC request [] submitted to btcworld
[17:14:41] RPC request [] submitted to btcworld
[17:14:41] RPC request [] submitted to btcworld
[17:14:45] RPC request [] submitted to btcworld
[17:14:45] RPC request [] submitted to btcworld
[17:14:45] RPC request [] submitted to btcworld
[17:14:49] RPC request [] submitted to btcworld
[17:14:50] RPC request [] submitted to btcworld
[17:14:50] RPC request [] submitted to btcworld
[17:14:54] RPC request [] submitted to btcworld
[17:14:54] RPC request [] submitted to btcworld
[17:14:54] RPC request [] submitted to btcworld
[17:14:57] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000033c0434346b4ce70ad88df10d54b33aed3a07eec848dedcd72f8848aa87058f44e53b5c11a094a8698b42610000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:14:58] RPC request [] submitted to btcworld
[17:14:59] RPC request [] submitted to btcworld
[17:14:59] RPC request [] submitted to btcworld
[17:14:59] RPC request [] submitted to btcworld
[17:15:03] RPC request [] submitted to btcworld
[17:15:03] RPC request [] submitted to btcworld
[17:15:03] RPC request [] submitted to btcworld
[17:15:07] RPC request [] submitted to btcworld
[17:15:07] RPC request [] submitted to btcworld
[17:15:07] RPC request [] submitted to btcworld
[17:15:11] RPC request [] submitted to btcworld
[17:15:11] RPC request [] submitted to btcworld
[17:15:11] RPC request [] submitted to btcworld
[17:15:12] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000018f3852e13fd3797787b02f7a6bf9d1af47f956ac4d8f7b6335486e6bc06ada04e53b5d21a094a8671238904000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:15:12] RPC request [] submitted to btcworld
[17:15:13] writing to database
[17:15:14] triple:	7563427	  
[17:15:15] digbtc:	1801062	  
[17:15:15] RPC request [] submitted to btcworld
[17:15:15] RPC request [] submitted to btcworld
[17:15:15] RPC request [] submitted to btcworld
[17:15:15] swepool:	4655335	  3.6gh/s 	34063min.
[17:15:18] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c93fed7928dd56bf481988564bf79d292f1a3f67f621e4f1f0a2dfaf48c88c8e4e53b5d61a094a86164d3410000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:15:18] RPC request [] submitted to btcworld
[17:15:19] slush:	782954	  1870.1gh/s 	30min.
[17:15:19] RPC request [] submitted to btcworld
[17:15:19] RPC request [] submitted to btcworld
[17:15:19] RPC request [] submitted to btcworld
[17:15:20] bithasher:	2381828	  
[17:15:22] btcserv:	1473322	  
[17:15:22] deepbit:	2466606	  5769.0gh/s 
[17:15:23] RPC request [] submitted to btcworld
[17:15:23] RPC request [] submitted to btcworld
[17:15:23] RPC request [] submitted to btcworld
[17:15:24] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000066911c09c72f86acc0a45cd73a1ca2185b272b3f37685e98d8c99435222da2564e53b5da1a094a868bf28918000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:15:24] RPC request [] submitted to btcworld
[17:15:25] btcmonkey:	4309887	  2.0gh/s 
[17:15:28] RPC request [] submitted to btcworld
[17:15:28] RPC request [] submitted to btcworld
[17:15:28] RPC request [] submitted to btcworld
[17:15:32] RPC request [] submitted to btcworld
[17:15:32] RPC request [] submitted to btcworld
[17:15:32] RPC request [] submitted to btcworld
[17:15:34] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000e146a82c78409fb4b75d857c3594ae93d1639e155cf6d14271fa63c8e1fa6ed74e53b5e71a094a863ff97f0b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:15:34] RPC request [] submitted to btcworld
[17:15:36] RPC request [] submitted to btcworld
[17:15:36] RPC request [] submitted to btcworld
[17:15:36] RPC request [] submitted to btcworld
[17:15:40] RPC request [] submitted to btcworld
[17:15:40] RPC request [] submitted to btcworld
[17:15:40] RPC request [] submitted to btcworld
[17:15:44] RPC request [] submitted to btcworld
[17:15:44] RPC request [] submitted to btcworld
[17:15:44] RPC request [] submitted to btcworld
[17:15:48] RPC request [] submitted to btcworld
[17:15:48] RPC request [] submitted to btcworld
[17:15:48] RPC request [] submitted to btcworld
[17:15:52] RPC request [] submitted to btcworld
[17:15:52] RPC request [] submitted to btcworld
[17:15:52] RPC request [] submitted to btcworld
[17:15:56] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000fa77fda5817e1470c8ae22228764709c4f2fe18765f692e29cc444ec852ac6cc4e53b5fc1a094a86bae53514000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:15:56] RPC request [] submitted to btcworld
[17:15:56] RPC request [] submitted to btcworld
[17:15:57] RPC request [] submitted to btcworld
[17:15:57] RPC request [] submitted to btcworld
[17:16:01] RPC request [] submitted to btcworld
[17:16:01] RPC request [] submitted to btcworld
[17:16:01] RPC request [] submitted to btcworld
[17:16:05] RPC request [] submitted to btcworld
[17:16:05] RPC request [] submitted to btcworld
[17:16:05] RPC request [] submitted to btcworld
[17:16:09] RPC request [] submitted to btcworld
[17:16:09] RPC request [] submitted to btcworld
[17:16:09] RPC request [] submitted to btcworld
[17:16:13] RPC request [] submitted to btcworld
[17:16:13] RPC request [] submitted to btcworld
[17:16:13] RPC request [] submitted to btcworld
[17:16:13] writing to database
[17:16:17] RPC request [] submitted to btcworld
[17:16:17] RPC request [] submitted to btcworld
[17:16:17] RPC request [] submitted to btcworld
[17:16:21] RPC request [] submitted to btcworld
[17:16:21] RPC request [] submitted to btcworld
[17:16:21] RPC request [] submitted to btcworld
[17:16:25] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000052fad6fb18944c6d3127f30fadbe0a4437e81e164aa7c064082c183b845af1ba4e53b6181a094a86b811b312000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:16:25] RPC request [] submitted to btcworld
[17:16:25] RPC request [] submitted to btcworld
[17:16:26] RPC request [] submitted to btcworld
[17:16:26] RPC request [] submitted to btcworld
[17:16:30] RPC request [] submitted to btcworld
[17:16:30] RPC request [] submitted to btcworld
[17:16:30] RPC request [] submitted to btcworld
[17:16:30] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000003c6a96c4c897bdafdec5a8f002d8be41a94ab99ba79b89625b4aa05a0eb8763c4e53b61d1a094a8694a83517000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:16:30] RPC request [] submitted to btcworld
[17:16:34] RPC request [] submitted to btcworld
[17:16:34] RPC request [] submitted to btcworld
[17:16:34] RPC request [] submitted to btcworld
[17:16:38] RPC request [] submitted to btcworld
[17:16:38] RPC request [] submitted to btcworld
[17:16:38] RPC request [] submitted to btcworld
[17:16:42] RPC request [] submitted to btcworld
[17:16:42] RPC request [] submitted to btcworld
[17:16:42] RPC request [] submitted to btcworld
[17:16:46] RPC request [] submitted to btcworld
[17:16:46] RPC request [] submitted to btcworld
[17:16:46] RPC request [] submitted to btcworld
[17:16:48] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c1b9e7b919362f660f308f712ea0eb6c0fe90a7a90faeab0026344ac0f5581a04e53b6311a094a86fcac970a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:16:48] RPC request [] submitted to btcworld
[17:16:50] RPC request [] submitted to btcworld
[17:16:50] RPC request [] submitted to btcworld
[17:16:50] RPC request [] submitted to btcworld
[17:16:54] RPC request [] submitted to btcworld
[17:16:54] RPC request [] submitted to btcworld
[17:16:54] RPC request [] submitted to btcworld
[17:16:59] RPC request [] submitted to btcworld
[17:16:59] RPC request [] submitted to btcworld
[17:16:59] RPC request [] submitted to btcworld
[17:17:03] RPC request [] submitted to btcworld
[17:17:03] RPC request [] submitted to btcworld
[17:17:03] RPC request [] submitted to btcworld
[17:17:04] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000002ec7865a1e117979099057dbce76648dd8e06b17d6d5e0c8ddfd3bd81cee7fb24e53b6421a094a865a9e4a03000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:17:04] RPC request [] submitted to btcworld
[17:17:05] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000ba762c7a95752c3c43f01956dd87f73d6dbf270a0d9f5e115ccea2468a18e7ac4e53b6421a094a865e4b8f0a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:17:05] RPC request [] submitted to btcworld
[17:17:07] RPC request [] submitted to btcworld
[17:17:07] RPC request [] submitted to btcworld
[17:17:07] RPC request [] submitted to btcworld
[17:17:10] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000009bd976191ed772f694a08fb5f0ec889b437f04c188fcbd413d9770bd56a4cdda4e53b6461a094a86e0271d0f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:17:10] RPC request [] submitted to btcworld
[17:17:11] RPC request [] submitted to btcworld
[17:17:11] RPC request [] submitted to btcworld
[17:17:11] RPC request [] submitted to btcworld
[17:17:14] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000532ba108305f19b087d69ce9aaa36b9a8d0be69b0a463a5114147c5ed5b262b34e53b64a1a094a863d63c20c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:17:14] writing to database
[17:17:14] RPC request [] submitted to btcworld
[17:17:14] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c1dd5093013d710177608f75290ed4c669af00ae9ce41143764fdb529759322b4e53b64a1a094a861268840d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:17:14] RPC request [] submitted to btcworld
[17:17:14] triple:	7564116	  
[17:17:15] RPC request [] submitted to btcworld
[17:17:15] digbtc:	1801168	  
[17:17:15] RPC request [] submitted to btcworld
[17:17:15] RPC request [] submitted to btcworld
[17:17:15] swepool:	4655419	  3.5gh/s 	34065min.
[17:17:16] bloodys:	2151192	  
[17:17:19] slush:	838656	  1877.1gh/s 	32min.
[17:17:19] bitclockers:	1085972	  227.6gh/s 
[17:17:19] RPC request [] submitted to btcworld
[17:17:19] RPC request [] submitted to btcworld
[17:17:19] RPC request [] submitted to btcworld
[17:17:21] bithasher:	2382022	  
[17:17:22] btcserv:	1473407	  
[17:17:23] deepbit:	2627835	  5758.0gh/s 
[17:17:23] RPC request [] submitted to btcworld
[17:17:23] RPC request [] submitted to btcworld
[17:17:23] RPC request [] submitted to btcworld
[17:17:25] mtred:	1179039	  218.4gh/s 
[17:17:26] btcmonkey:	4309947	  1.7gh/s 
[17:17:28] RPC request [] submitted to btcworld
[17:17:28] RPC request [] submitted to btcworld
[17:17:28] RPC request [] submitted to btcworld
[17:17:32] RPC request [] submitted to btcworld
[17:17:32] RPC request [] submitted to btcworld
[17:17:32] RPC request [] submitted to btcworld
[17:17:36] RPC request [] submitted to btcworld
[17:17:36] RPC request [] submitted to btcworld
[17:17:36] RPC request [] submitted to btcworld
[17:17:36] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c611c7eae2cc4ff35957bcbdba07953f8f6ba2592b0878692e018f80abf36b204e53b6631a094a86e8f3a400000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:17:37] RPC request [] submitted to btcworld
[17:17:40] RPC request [] submitted to btcworld
[17:17:40] RPC request [] submitted to btcworld
[17:17:40] RPC request [] submitted to btcworld
[17:17:44] RPC request [] submitted to btcworld
[17:17:44] RPC request [] submitted to btcworld
[17:17:44] RPC request [] submitted to btcworld
[17:17:48] RPC request [] submitted to btcworld
[17:17:48] RPC request [] submitted to btcworld
[17:17:48] RPC request [] submitted to btcworld
[17:17:50] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000563ada8aaa4ce905ac729f33fbc120b39f37a09ec8a314c3160175a7571c3f4d4e53b66f1a094a86d4a0df04000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:17:50] RPC request [] submitted to btcworld
[17:17:52] RPC request [] submitted to btcworld
[17:17:52] RPC request [] submitted to btcworld
[17:17:53] RPC request [] submitted to btcworld
[17:17:57] RPC request [] submitted to btcworld
[17:17:57] RPC request [] submitted to btcworld
[17:17:57] RPC request [] submitted to btcworld
[17:18:02] RPC request [] submitted to btcworld
[17:18:02] RPC request [] submitted to btcworld
[17:18:02] RPC request [] submitted to btcworld
[17:18:06] RPC request [] submitted to btcworld
[17:18:06] RPC request [] submitted to btcworld
[17:18:06] RPC request [] submitted to btcworld
[17:18:10] RPC request [] submitted to btcworld
[17:18:10] RPC request [] submitted to btcworld
[17:18:10] RPC request [] submitted to btcworld
[17:18:14] writing to database
[17:18:14] RPC request [] submitted to btcworld
[17:18:14] RPC request [] submitted to btcworld
[17:18:14] RPC request [] submitted to btcworld
[17:18:18] RPC request [] submitted to btcworld
[17:18:18] RPC request [] submitted to btcworld
[17:18:18] RPC request [] submitted to btcworld
[17:18:22] RPC request [] submitted to btcworld
[17:18:22] RPC request [] submitted to btcworld
[17:18:22] RPC request [] submitted to btcworld
[17:18:23] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000051bc9be7014d97a50fbd09dc0e5699379ef9474ce43ffe27ccd473cc2a144bfb4e53b6911a094a86441d9f05000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:18:24] RPC request [] submitted to btcworld
[17:18:26] RPC request [] submitted to btcworld
[17:18:26] RPC request [] submitted to btcworld
[17:18:26] RPC request [] submitted to btcworld
[17:18:30] RPC request [] submitted to btcworld
[17:18:31] RPC request [] submitted to btcworld
[17:18:31] RPC request [] submitted to btcworld
[17:18:35] RPC request [] submitted to btcworld
[17:18:35] RPC request [] submitted to btcworld
[17:18:35] RPC request [] submitted to btcworld
[17:18:39] RPC request [] submitted to btcworld
[17:18:39] RPC request [] submitted to btcworld
[17:18:39] RPC request [] submitted to btcworld
[17:18:43] RPC request [] submitted to btcworld
[17:18:43] RPC request [] submitted to btcworld
[17:18:43] RPC request [] submitted to btcworld
[17:18:44] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000ca8ac3432cd845e327258a342fe8743b4f946da0265d2085161034796fbe8d424e53b6a61a094a8660989b04000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:18:44] RPC request [] submitted to btcworld
[17:18:47] RPC request [] submitted to btcworld
[17:18:47] RPC request [] submitted to btcworld
[17:18:47] RPC request [] submitted to btcworld
[17:18:51] RPC request [] submitted to btcworld
[17:18:51] RPC request [] submitted to btcworld
[17:18:51] RPC request [] submitted to btcworld
[17:18:55] RPC request [] submitted to btcworld
[17:18:55] RPC request [] submitted to btcworld
[17:18:55] RPC request [] submitted to btcworld
[17:18:59] RPC request [] submitted to btcworld
[17:19:00] RPC request [] submitted to btcworld
[17:19:00] RPC request [] submitted to btcworld
[17:19:04] RPC request [] submitted to btcworld
[17:19:04] RPC request [] submitted to btcworld
[17:19:04] RPC request [] submitted to btcworld
[17:19:08] RPC request [] submitted to btcworld
[17:19:08] RPC request [] submitted to btcworld
[17:19:08] RPC request [] submitted to btcworld
[17:19:12] RPC request [] submitted to btcworld
[17:19:12] RPC request [] submitted to btcworld
[17:19:12] RPC request [] submitted to btcworld
[17:19:14] writing to database
[17:19:15] triple:	7564792	  
[17:19:16] digbtc:	1801310	  
[17:19:16] swepool:	4655520	  3.5gh/s 	34067min.
[17:19:16] RPC request [] submitted to btcworld
[17:19:16] RPC request [] submitted to btcworld
[17:19:16] RPC request [] submitted to btcworld
[17:19:19] arsbitcoin:	1421802	  
[17:19:19] slush:	894460	  1875.0gh/s 	34min.
[17:19:20] RPC request [] submitted to btcworld
[17:19:20] RPC request [] submitted to btcworld
[17:19:20] RPC request [] submitted to btcworld
[17:19:22] bithasher:	2382203	  
[17:19:22] btcserv:	1473482	  
[17:19:23] deepbit:	2789245	  5751.0gh/s 
[17:19:24] RPC request [] submitted to btcworld
[17:19:24] RPC request [] submitted to btcworld
[17:19:24] RPC request [] submitted to btcworld
[17:19:27] btcmonkey:	4309991	  1.7gh/s 
[17:19:28] RPC request [] submitted to btcworld
[17:19:29] RPC request [] submitted to btcworld
[17:19:29] RPC request [] submitted to btcworld
[17:19:29] ozco:	1872899	  63.8gh/s 	1225min.
[17:19:33] RPC request [] submitted to btcworld
[17:19:33] RPC request [] submitted to btcworld
[17:19:33] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000008a6ac5fb5b4c31ec4bc4bc144b0547692ae544dca739e4b38962307a724fed8c4e53b6d41a094a866e835d16000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:19:33] RPC request [] submitted to btcworld
[17:19:33] RPC request [] submitted to btcworld
[17:19:37] RPC request [] submitted to btcworld
[17:19:37] RPC request [] submitted to btcworld
[17:19:37] RPC request [] submitted to btcworld
[17:19:41] RPC request [] submitted to btcworld
[17:19:41] RPC request [] submitted to btcworld
[17:19:41] RPC request [] submitted to btcworld
[17:19:45] RPC request [] submitted to btcworld
[17:19:45] RPC request [] submitted to btcworld
[17:19:45] RPC request [] submitted to btcworld
[17:19:47] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000e6b449c1b16ba60a1a0b6a0738c3fc666dfb6514f113804ed82d8c0a2e15e2a34e53b6e41a094a8696450306000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:19:47] RPC request [] submitted to btcworld
[17:19:49] RPC request [] submitted to btcworld
[17:19:49] RPC request [] submitted to btcworld
[17:19:49] RPC request [] submitted to btcworld
[17:19:53] RPC request [] submitted to btcworld
[17:19:53] RPC request [] submitted to btcworld
[17:19:53] RPC request [] submitted to btcworld
[17:19:56] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000d7078e7a33f06486340c9e2e496a3f1613d2877eb48a999b47f0fc0976f801f04e53b6ed1a094a86ce00480d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:19:56] RPC request [] submitted to btcworld
[17:19:57] RPC request [] submitted to btcworld
[17:19:57] RPC request [] submitted to btcworld
[17:19:58] RPC request [] submitted to btcworld
[17:19:59] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000b6c1b9236180c6246bdcd70a62815b89bd7c419008219ea26bbbb1547c98355b4e53b6f11a094a8691355b03000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:19:59] RPC request [] submitted to btcworld
[17:20:02] RPC request [] submitted to btcworld
[17:20:02] RPC request [] submitted to btcworld
[17:20:02] RPC request [] submitted to btcworld
[17:20:06] RPC request [] submitted to btcworld
[17:20:06] RPC request [] submitted to btcworld
[17:20:06] RPC request [] submitted to btcworld
[17:20:10] RPC request [] submitted to btcworld
[17:20:10] RPC request [] submitted to btcworld
[17:20:10] RPC request [] submitted to btcworld
[17:20:14] writing to database
[17:20:14] RPC request [] submitted to btcworld
[17:20:14] RPC request [] submitted to btcworld
[17:20:14] RPC request [] submitted to btcworld
[17:20:18] RPC request [] submitted to btcworld
[17:20:18] RPC request [] submitted to btcworld
[17:20:18] RPC request [] submitted to btcworld
[17:20:22] RPC request [] submitted to btcworld
[17:20:22] RPC request [] submitted to btcworld
[17:20:22] RPC request [] submitted to btcworld
[17:20:26] RPC request [] submitted to btcworld
[17:20:27] RPC request [] submitted to btcworld
[17:20:27] RPC request [] submitted to btcworld
[17:20:30] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000e9646d4f9da2fd9870a03b8a2afb3125673b4cb4054b0e4a60cc9f20906654374e53b70e1a094a861ec0b115000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:20:31] RPC request [] submitted to btcworld
[17:20:31] RPC request [] submitted to btcworld
[17:20:31] RPC request [] submitted to btcworld
[17:20:31] RPC request [] submitted to btcworld
[17:20:35] RPC request [] submitted to btcworld
[17:20:35] RPC request [] submitted to btcworld
[17:20:35] RPC request [] submitted to btcworld
[17:20:39] RPC request [] submitted to btcworld
[17:20:39] RPC request [] submitted to btcworld
[17:20:39] RPC request [] submitted to btcworld
[17:20:43] RPC request [] submitted to btcworld
[17:20:43] RPC request [] submitted to btcworld
[17:20:43] RPC request [] submitted to btcworld
[17:20:47] RPC request [] submitted to btcworld
[17:20:47] RPC request [] submitted to btcworld
[17:20:47] RPC request [] submitted to btcworld
[17:20:49] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000df4c762ffee16b8d3e4ba8fb61b4795512ee93bbced3ced21d4a2d387833ded94e53b7221a094a86e6eb1908000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:20:49] RPC request [] submitted to btcworld
[17:20:51] RPC request [] submitted to btcworld
[17:20:51] RPC request [] submitted to btcworld
[17:20:51] RPC request [] submitted to btcworld
[17:20:56] RPC request [] submitted to btcworld
[17:20:56] RPC request [] submitted to btcworld
[17:20:56] RPC request [] submitted to btcworld
[17:21:00] RPC request [] submitted to btcworld
[17:21:00] RPC request [] submitted to btcworld
[17:21:00] RPC request [] submitted to btcworld
[17:21:03] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000cab267af55f6b86ea6564800d6126831101d161a999d7b33c6117fa6159aa4b64e53b72f1a094a869a3ffd11000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:21:03] RPC request [] submitted to btcworld
[17:21:04] RPC request [] submitted to btcworld
[17:21:04] RPC request [] submitted to btcworld
[17:21:04] RPC request [] submitted to btcworld
[17:21:07] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000e233d3f0ad4972085654c79520a50c4804b3a3d925ecb2ee141d1cec133814fd4e53b7331a094a865d1c0310000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:21:07] RPC request [] submitted to btcworld
[17:21:08] RPC request [] submitted to btcworld
[17:21:08] RPC request [] submitted to btcworld
[17:21:08] RPC request [] submitted to btcworld
[17:21:12] RPC request [] submitted to btcworld
[17:21:12] RPC request [] submitted to btcworld
[17:21:12] RPC request [] submitted to btcworld
[17:21:14] writing to database
[17:21:15] triple:	7565318	  
[17:21:16] swepool:	4655611	  3.5gh/s 	34069min.
[17:21:16] digbtc:	1801467	  
[17:21:16] RPC request [] submitted to btcworld
[17:21:16] RPC request [] submitted to btcworld
[17:21:16] RPC request [] submitted to btcworld
[17:21:17] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000007eea43e5d071857c1f7a9e7ae95f82d9d35872073d8e17d1d9c84bf4af98bd6a4e53b73f1a094a865f3b9202000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:21:17] RPC request [] submitted to btcworld
[17:21:19] slush:	950067	  1876.1gh/s 	36min.
[17:21:20] RPC request [] submitted to btcworld
[17:21:20] RPC request [] submitted to btcworld
[17:21:20] RPC request [] submitted to btcworld
[17:21:22] bithasher:	2382404	  
[17:21:23] btcserv:	1473561	  
[17:21:24] deepbit:	2950614	  5751.0gh/s 
[17:21:24] RPC request [] submitted to btcworld
[17:21:25] RPC request [] submitted to btcworld
[17:21:25] RPC request [] submitted to btcworld
[17:21:27] mtred:	1194105	  215.7gh/s 
[17:21:28] btcmonkey:	4310040	  1.7gh/s 
[17:21:29] RPC request [] submitted to btcworld
[17:21:29] RPC request [] submitted to btcworld
[17:21:29] RPC request [] submitted to btcworld
[17:21:33] RPC request [] submitted to btcworld
[17:21:33] RPC request [] submitted to btcworld
[17:21:33] RPC request [] submitted to btcworld
[17:21:37] RPC request [] submitted to btcworld
[17:21:37] RPC request [] submitted to btcworld
[17:21:37] RPC request [] submitted to btcworld
[17:21:41] RPC request [] submitted to btcworld
[17:21:41] RPC request [] submitted to btcworld
[17:21:41] RPC request [] submitted to btcworld
[17:21:45] RPC request [] submitted to btcworld
[17:21:45] RPC request [] submitted to btcworld
[17:21:45] RPC request [] submitted to btcworld
[17:21:49] RPC request [] submitted to btcworld
[17:21:49] RPC request [] submitted to btcworld
[17:21:49] RPC request [] submitted to btcworld
[17:21:53] RPC request [] submitted to btcworld
[17:21:54] RPC request [] submitted to btcworld
[17:21:54] RPC request [] submitted to btcworld
[17:21:55] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000075be4dee5ed25b9fd43f44b8a3bf44a6a3b3a6fb4a5bff1c1e7f644ecde25af44e53b7651a094a86a532d604000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:21:55] RPC request [] submitted to btcworld
[17:21:58] RPC request [] submitted to btcworld
[17:21:58] RPC request [] submitted to btcworld
[17:21:58] RPC request [] submitted to btcworld
[17:22:02] RPC request [] submitted to btcworld
[17:22:02] RPC request [] submitted to btcworld
[17:22:02] RPC request [] submitted to btcworld
[17:22:07] RPC request [] submitted to btcworld
[17:22:07] RPC request [] submitted to btcworld
[17:22:07] RPC request [] submitted to btcworld
[17:22:11] RPC request [] submitted to btcworld
[17:22:11] RPC request [] submitted to btcworld
[17:22:11] RPC request [] submitted to btcworld
[17:22:14] writing to database
[17:22:15] RPC request [] submitted to btcworld
[17:22:15] RPC request [] submitted to btcworld
[17:22:15] RPC request [] submitted to btcworld
[17:22:19] RPC request [] submitted to btcworld
[17:22:19] RPC request [] submitted to btcworld
[17:22:20] RPC request [] submitted to btcworld
[17:22:20] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000602770e60c2602011340810e0a27367913e6b99b23551140d180ddad9155ad8a4e53b77f1a094a86b5a2cf00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:22:20] RPC request [] submitted to btcworld
[17:22:24] RPC request [] submitted to btcworld
[17:22:24] RPC request [] submitted to btcworld
[17:22:24] RPC request [] submitted to btcworld
[17:22:28] RPC request [] submitted to btcworld
[17:22:28] RPC request [] submitted to btcworld
[17:22:28] RPC request [] submitted to btcworld
[17:22:32] RPC request [] submitted to btcworld
[17:22:32] RPC request [] submitted to btcworld
[17:22:32] RPC request [] submitted to btcworld
[17:22:36] RPC request [] submitted to btcworld
[17:22:36] RPC request [] submitted to btcworld
[17:22:36] RPC request [] submitted to btcworld
[17:22:40] RPC request [] submitted to btcworld
[17:22:40] RPC request [] submitted to btcworld
[17:22:40] RPC request [] submitted to btcworld
[17:22:44] RPC request [] submitted to btcworld
[17:22:44] RPC request [] submitted to btcworld
[17:22:44] RPC request [] submitted to btcworld
[17:22:48] RPC request [] submitted to btcworld
[17:22:48] RPC request [] submitted to btcworld
[17:22:49] RPC request [] submitted to btcworld
[17:22:52] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000e8010c58ed2222db10a43f403f9ffe55d521d7c39925aead022f96394204e7744e53b79c1a094a8683167c13000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:22:52] RPC request [] submitted to btcworld
[17:22:53] RPC request [] submitted to btcworld
[17:22:53] RPC request [] submitted to btcworld
[17:22:53] RPC request [] submitted to btcworld
[17:22:57] RPC request [] submitted to btcworld
[17:22:57] RPC request [] submitted to btcworld
[17:22:57] RPC request [] submitted to btcworld
[17:23:01] RPC request [] submitted to btcworld
[17:23:01] RPC request [] submitted to btcworld
[17:23:01] RPC request [] submitted to btcworld
[17:23:05] RPC request [] submitted to btcworld
[17:23:05] RPC request [] submitted to btcworld
[17:23:05] RPC request [] submitted to btcworld
[17:23:09] RPC request [] submitted to btcworld
[17:23:09] RPC request [] submitted to btcworld
[17:23:09] RPC request [] submitted to btcworld
[17:23:13] RPC request [] submitted to btcworld
[17:23:13] RPC request [] submitted to btcworld
[17:23:13] RPC request [] submitted to btcworld
[17:23:14] writing to database
[17:23:15] triple:	7565963	  
[17:23:16] swepool:	4655702	  3.5gh/s 	34071min.
[17:23:17] digbtc:	1780314	  
[17:23:17] bloodys:	2151336	  
[17:23:17] RPC request [] submitted to btcworld
[17:23:17] RPC request [] submitted to btcworld
[17:23:18] RPC request [] submitted to btcworld
[17:23:19] slush:	991768	  1874.9gh/s 	38min.
[17:23:19] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000000be229eb3de0d2bc56faa13d57359c4753cb33cc5b851cf1df7a4f028d19dd1c4e53b7b91a094a86d6fb3807000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:23:19] RPC request [] submitted to btcworld
[17:23:20] arsbitcoin:	1458910	  
[17:23:21] bitclockers:	1096197	  227.3gh/s 
[17:23:22] RPC request [] submitted to btcworld
[17:23:22] RPC request [] submitted to btcworld
[17:23:22] RPC request [] submitted to btcworld
[17:23:23] btcserv:	1473651	  
[17:23:23] bithasher:	2382604	  
[17:23:24] deepbit:	3111804	  5746.0gh/s 
[17:23:26] RPC request [] submitted to btcworld
[17:23:26] RPC request [] submitted to btcworld
[17:23:26] RPC request [] submitted to btcworld
[17:23:28] btcmonkey:	4310099	  1.7gh/s 
[17:23:30] RPC request [] submitted to btcworld
[17:23:30] RPC request [] submitted to btcworld
[17:23:30] RPC request [] submitted to btcworld
[17:23:34] RPC request [] submitted to btcworld
[17:23:34] RPC request [] submitted to btcworld
[17:23:34] RPC request [] submitted to btcworld
[17:23:38] RPC request [] submitted to btcworld
[17:23:38] RPC request [] submitted to btcworld
[17:23:38] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000005d2997ebb35aecff4e48dcb2cdba9e18aa3b8735c5bc231d95071484bb6b3e224e53b7c91a094a866355e315000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:23:38] RPC request [] submitted to btcworld
[17:23:38] RPC request [] submitted to btcworld
[17:23:41] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000008ad7a6d922795b9171f181f9715073e2468ce9aa9db37fd7b92a311c0838356a4e53b7cd1a094a86c388960f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:23:41] RPC request [] submitted to btcworld
[17:23:42] RPC request [] submitted to btcworld
[17:23:42] RPC request [] submitted to btcworld
[17:23:42] RPC request [] submitted to btcworld
[17:23:44] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000004aad0aaf9da166b3f5fe6ac86f8a65f5d2ff26a5d34cdcb7ec987d1554220d274e53b7d11a094a866b498307000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:23:44] RPC request [] submitted to btcworld
[17:23:46] RPC request [] submitted to btcworld
[17:23:46] RPC request [] submitted to btcworld
[17:23:47] RPC request [] submitted to btcworld
[17:23:51] RPC request [] submitted to btcworld
[17:23:51] RPC request [] submitted to btcworld
[17:23:51] RPC request [] submitted to btcworld
[17:23:55] RPC request [] submitted to btcworld
[17:23:55] RPC request [] submitted to btcworld
[17:23:55] RPC request [] submitted to btcworld
[17:23:57] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000af92972b2bbb1172148ca45b9a0330aa53d2caf74b42a5d2c46230ccfb5580354e53b7de1a094a861468330f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:23:58] RPC request [] submitted to btcworld
[17:23:59] RPC request [] submitted to btcworld
[17:23:59] RPC request [] submitted to btcworld
[17:23:59] RPC request [] submitted to btcworld
[17:24:01] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000090bf3b10b81bfcf18458695cddc45695b3f52897be1657073c84343dd034e2a64e53b7e21a094a8620c88009000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:24:01] RPC request [] submitted to btcworld
[17:24:03] RPC request [] submitted to btcworld
[17:24:03] RPC request [] submitted to btcworld
[17:24:03] RPC request [] submitted to btcworld
[17:24:07] RPC request [] submitted to btcworld
[17:24:07] RPC request [] submitted to btcworld
[17:24:07] RPC request [] submitted to btcworld
[17:24:11] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000002adb5f7971a340fcb289793591c9353a8b1cffda659e62a852894c2f329e68794e53b7ea1a094a8656b0e514000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:24:11] RPC request [] submitted to btcworld
[17:24:11] RPC request [] submitted to btcworld
[17:24:11] RPC request [] submitted to btcworld
[17:24:11] RPC request [] submitted to btcworld
[17:24:14] writing to database
[17:24:15] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000002670f6dacac6198b68a5306df53444a607c9d2d3103e2774cb54bc0d1471d1d84e53b7ef1a094a860ecc4e10000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:24:15] RPC request [] submitted to btcworld
[17:24:15] RPC request [] submitted to btcworld
[17:24:15] RPC request [] submitted to btcworld
[17:24:16] RPC request [] submitted to btcworld
[17:24:16] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000003f2d589d145517b7a2d4c6f2660433098233d4847fce30ee69f4f55b22f0a8854e53b7f21a094a862eeb7602000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:24:16] RPC request [] submitted to btcworld
[17:24:19] RPC request [] submitted to btcworld
[17:24:19] RPC request [] submitted to btcworld
[17:24:20] RPC request [] submitted to btcworld
[17:24:24] RPC request [] submitted to btcworld
[17:24:24] RPC request [] submitted to btcworld
[17:24:24] RPC request [] submitted to btcworld
[17:24:27] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000df5d6da93f8a4173ff6647d04ed7b02611a192d63c905a2911a4cc555b3fdcf24e53b7fb1a094a8627413f12000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:24:28] RPC request [] submitted to btcworld
[17:24:28] RPC request [] submitted to btcworld
[17:24:28] RPC request [] submitted to btcworld
[17:24:28] RPC request [] submitted to btcworld
[17:24:31] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000002f9afcd9161cc78bbe0fccb6934a9c3f327dec42a803cd39ecbfbe51a78471014e53b7ff1a094a86f6339b12000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:24:31] RPC request [] submitted to btcworld
[17:24:32] RPC request [] submitted to btcworld
[17:24:32] RPC request [] submitted to btcworld
[17:24:32] RPC request [] submitted to btcworld
[17:24:36] RPC request [] submitted to btcworld
[17:24:36] RPC request [] submitted to btcworld
[17:24:36] RPC request [] submitted to btcworld
[17:24:40] RPC request [] submitted to btcworld
[17:24:40] RPC request [] submitted to btcworld
[17:24:40] RPC request [] submitted to btcworld
[17:24:41] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000008a863cc63f93424482106f50b4f12127f30ca0c348f88158acd00bf57e2564024e53b80c1a094a869831a000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:24:41] RPC request [] submitted to btcworld
[17:24:44] RPC request [] submitted to btcworld
[17:24:44] RPC request [] submitted to btcworld
[17:24:44] RPC request [] submitted to btcworld
[17:24:48] RPC request [] submitted to btcworld
[17:24:48] RPC request [] submitted to btcworld
[17:24:49] RPC request [] submitted to btcworld
[17:24:53] RPC request [] submitted to btcworld
[17:24:53] RPC request [] submitted to btcworld
[17:24:53] RPC request [] submitted to btcworld
[17:24:57] RPC request [] submitted to btcworld
[17:24:57] RPC request [] submitted to btcworld
[17:24:57] RPC request [] submitted to btcworld
[17:25:01] RPC request [] submitted to btcworld
[17:25:01] RPC request [] submitted to btcworld
[17:25:01] RPC request [] submitted to btcworld
[17:25:05] RPC request [] submitted to btcworld
[17:25:05] RPC request [] submitted to btcworld
[17:25:05] RPC request [] submitted to btcworld
[17:25:09] RPC request [] submitted to btcworld
[17:25:09] RPC request [] submitted to btcworld
[17:25:09] RPC request [] submitted to btcworld
[17:25:11] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c7e0436a7bafd6d2a8cb6292557b66e5d7902ad1d45c317f3033bbc37a4dc6844e53b8281a094a8632106d07000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:25:11] RPC request [] submitted to btcworld
[17:25:13] RPC request [] submitted to btcworld
[17:25:13] RPC request [] submitted to btcworld
[17:25:14] RPC request [] submitted to btcworld
[17:25:14] writing to database
[17:25:15] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000004eccfdbedce240fcc75ff3fc92be3aad44182f75e14ba317a40862035a6ff86e4e53b82d1a094a8620d73d06000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:25:15] RPC request [] submitted to btcworld
[17:25:16] triple:	7566636	  
[17:25:16] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000007a4095ef1ff4fe9325b9b92354b5a13605a6dbb47727622ffbb8abd1b727b7554e53b82f1a094a86af0b0102000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:25:16] swepool:	4655802	  3.5gh/s 	34073min.
[17:25:16] RPC request [] submitted to btcworld
[17:25:17] digbtc:	1801719	  
[17:25:18] RPC request [] submitted to btcworld
[17:25:18] RPC request [] submitted to btcworld
[17:25:18] RPC request [] submitted to btcworld
[17:25:19] slush:	1046770	  1875.8gh/s 	40min.
[17:25:22] RPC request [] submitted to btcworld
[17:25:22] RPC request [] submitted to btcworld
[17:25:22] RPC request [] submitted to btcworld
[17:25:23] btcserv:	1473735	  
[17:25:24] bithasher:	2382803	  
[17:25:25] deepbit:	3272767	  5746.0gh/s 
[17:25:26] RPC request [] submitted to btcworld
[17:25:26] RPC request [] submitted to btcworld
[17:25:26] RPC request [] submitted to btcworld
[17:25:29] btcmonkey:	4310156	  1.9gh/s 
[17:25:30] RPC request [] submitted to btcworld
[17:25:30] RPC request [] submitted to btcworld
[17:25:30] RPC request [] submitted to btcworld
[17:25:34] RPC request [] submitted to btcworld
[17:25:34] RPC request [] submitted to btcworld
[17:25:34] RPC request [] submitted to btcworld
[17:25:38] RPC request [] submitted to btcworld
[17:25:38] RPC request [] submitted to btcworld
[17:25:38] RPC request [] submitted to btcworld
[17:25:42] RPC request [] submitted to btcworld
[17:25:42] RPC request [] submitted to btcworld
[17:25:43] RPC request [] submitted to btcworld
[17:25:46] RPC request [] submitted to btcworld
[17:25:47] RPC request [] submitted to btcworld
[17:25:47] RPC request [] submitted to btcworld
[17:25:51] RPC request [] submitted to btcworld
[17:25:51] RPC request [] submitted to btcworld
[17:25:51] RPC request [] submitted to btcworld
[17:25:55] RPC request [] submitted to btcworld
[17:25:55] RPC request [] submitted to btcworld
[17:25:55] RPC request [] submitted to btcworld
[17:25:59] RPC request [] submitted to btcworld
[17:25:59] RPC request [] submitted to btcworld
[17:25:59] RPC request [] submitted to btcworld
[17:26:03] RPC request [] submitted to btcworld
[17:26:03] RPC request [] submitted to btcworld
[17:26:03] RPC request [] submitted to btcworld
[17:26:07] RPC request [] submitted to btcworld
[17:26:07] RPC request [] submitted to btcworld
[17:26:07] RPC request [] submitted to btcworld
[17:26:11] RPC request [] submitted to btcworld
[17:26:11] RPC request [] submitted to btcworld
[17:26:12] RPC request [] submitted to btcworld
[17:26:14] writing to database
[17:26:15] RPC request [] submitted to btcworld
[17:26:16] RPC request [] submitted to btcworld
[17:26:16] RPC request [] submitted to btcworld
[17:26:20] RPC request [] submitted to btcworld
[17:26:20] RPC request [] submitted to btcworld
[17:26:20] RPC request [] submitted to btcworld
[17:26:24] RPC request [] submitted to btcworld
[17:26:24] RPC request [] submitted to btcworld
[17:26:24] RPC request [] submitted to btcworld
[17:26:28] RPC request [] submitted to btcworld
[17:26:28] RPC request [] submitted to btcworld
[17:26:28] RPC request [] submitted to btcworld
[17:26:30] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000009770619ad4fb342f29cac17d73708763c693a4e54725441a1475a08f73bda5ce4e53b8771a094a86a408c706000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:26:30] RPC request [] submitted to btcworld
[17:26:32] RPC request [] submitted to btcworld
[17:26:32] RPC request [] submitted to btcworld
[17:26:32] RPC request [] submitted to btcworld
[17:26:35] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000002f820270daf5d20c17eabdb3f7962c0ff4cf161c4b7c81589171ca3c6e3955b34e53b87b1a094a866722ac10000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:26:35] RPC request [] submitted to btcworld
[17:26:36] RPC request [] submitted to btcworld
[17:26:36] RPC request [] submitted to btcworld
[17:26:36] RPC request [] submitted to btcworld
[17:26:39] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000518b1b272558dd7ed6d0f1c4c2dee858432fbb43183cff4d68c526ff5a06d6844e53b87f1a094a861c75880e000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:26:39] RPC request [] submitted to btcworld
[17:26:40] RPC request [] submitted to btcworld
[17:26:40] RPC request [] submitted to btcworld
[17:26:41] RPC request [] submitted to btcworld
[17:26:44] RPC request [] submitted to btcworld
[17:26:44] RPC request [] submitted to btcworld
[17:26:45] RPC request [] submitted to btcworld
[17:26:48] RPC request [] submitted to btcworld
[17:26:49] RPC request [] submitted to btcworld
[17:26:49] RPC request [] submitted to btcworld
[17:26:51] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000064729385566fa9ef72e11fda67230dbe458fdc8b30333447151b98380ed1c8d24e53b88c1a094a861aeac809000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:26:51] RPC request [] submitted to btcworld
[17:26:53] RPC request [] submitted to btcworld
[17:26:53] RPC request [] submitted to btcworld
[17:26:53] RPC request [] submitted to btcworld
[17:26:57] RPC request [] submitted to btcworld
[17:26:57] RPC request [] submitted to btcworld
[17:26:57] RPC request [] submitted to btcworld
[17:26:59] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000014a986bbc7eea777d3271aefe521709168da816ebdc4c7817cecb23e6bbdff24e53b8941a094a86c7917b0b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:26:59] RPC request [] submitted to btcworld
[17:27:01] RPC request [] submitted to btcworld
[17:27:01] RPC request [] submitted to btcworld
[17:27:01] RPC request [] submitted to btcworld
[17:27:05] RPC request [] submitted to btcworld
[17:27:05] RPC request [] submitted to btcworld
[17:27:05] RPC request [] submitted to btcworld
[17:27:09] RPC request [] submitted to btcworld
[17:27:09] RPC request [] submitted to btcworld
[17:27:10] RPC request [] submitted to btcworld
[17:27:13] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000008350f26e0d60f4e8afa9be8c2653ec01d2c429dc139b05c264698e4989468be54e53b8a11a094a86612ead13000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:27:13] RPC request [] submitted to btcworld
[17:27:13] RPC request [] submitted to btcworld
[17:27:13] RPC request [] submitted to btcworld
[17:27:14] RPC request [] submitted to btcworld
[17:27:15] writing to database
[17:27:16] triple:	7567328	  
[17:27:16] swepool:	4655917	  3.5gh/s 	34075min.
[17:27:17] RPC request [] submitted to btcworld
[17:27:18] RPC request [] submitted to btcworld
[17:27:18] digbtc:	1801844	  
[17:27:18] RPC request [] submitted to btcworld
[17:27:19] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000009cb412f81cc532c873070f1d47c28a42bffc4234ac486b50c3a2052cf5e3ffeb4e53b8a91a094a86b079d404000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:27:19] slush:	1102372	  1874.1gh/s 	42min.
[17:27:19] RPC request [] submitted to btcworld
[17:27:22] RPC request [] submitted to btcworld
[17:27:22] RPC request [] submitted to btcworld
[17:27:22] RPC request [] submitted to btcworld
[17:27:22] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000004d919c585dbce148feaf6639c033d8530e333194418bccf2cb0c6e30a5c5adc94e53b8ad1a094a86327a4a03000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:27:22] RPC request [] submitted to btcworld
[17:27:23] btcserv:	1473810	  
[17:27:24] bloodys:	2151478	  
[17:27:25] bithasher:	2382992	  
[17:27:25] deepbit:	3433663	  5746.0gh/s 
[17:27:25] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000f9ec1aa49f28424b120e8c86527a88be192d63ea707168a66023fe83832ca1144e53b8ae1a094a86db1eea0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:27:25] RPC request [] submitted to btcworld
[17:27:26] RPC request [] submitted to btcworld
[17:27:26] RPC request [] submitted to btcworld
[17:27:26] RPC request [] submitted to btcworld
[17:27:27] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000d53111b1e9bc866aaa2f16a65ff6d0dfaacc8922ef2da354872813c3e7eb426d4e53b8b11a094a863a7a0d01000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:27:27] RPC request [] submitted to btcworld
[17:27:29] bitclockers:	1106860	  233.9gh/s 
[17:27:30] mtred:	1209333	  218.0gh/s 
[17:27:30] RPC request [] submitted to btcworld
[17:27:30] RPC request [] submitted to btcworld
[17:27:30] RPC request [] submitted to btcworld
[17:27:30] btcmonkey:	4310204	  1.9gh/s 
[17:27:31] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000001ad75f24cda4c49f093fdeb268348b0a0154fa8dbef0c8400580ef004c6f06594e53b8b51a094a86883fc702000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:27:31] RPC request [] submitted to btcworld
[17:27:34] RPC request [] submitted to btcworld
[17:27:34] RPC request [] submitted to btcworld
[17:27:34] RPC request [] submitted to btcworld
[17:27:38] RPC request [] submitted to btcworld
[17:27:38] RPC request [] submitted to btcworld
[17:27:39] RPC request [] submitted to btcworld
[17:27:42] RPC request [] submitted to btcworld
[17:27:42] RPC request [] submitted to btcworld
[17:27:43] RPC request [] submitted to btcworld
[17:27:45] ozco:	1880818	  64.0gh/s 	1233min.
[17:27:46] RPC request [] submitted to btcworld
[17:27:47] RPC request [] submitted to btcworld
[17:27:47] RPC request [] submitted to btcworld
[17:27:51] RPC request [] submitted to btcworld
[17:27:51] RPC request [] submitted to btcworld
[17:27:51] RPC request [] submitted to btcworld
[17:27:55] RPC request [] submitted to btcworld
[17:27:55] RPC request [] submitted to btcworld
[17:27:55] RPC request [] submitted to btcworld
[17:27:59] RPC request [] submitted to btcworld
[17:27:59] RPC request [] submitted to btcworld
[17:27:59] RPC request [] submitted to btcworld
[17:28:03] RPC request [] submitted to btcworld
[17:28:03] RPC request [] submitted to btcworld
[17:28:04] RPC request [] submitted to btcworld
[17:28:07] RPC request [] submitted to btcworld
[17:28:07] RPC request [] submitted to btcworld
[17:28:08] RPC request [] submitted to btcworld
[17:28:11] RPC request [] submitted to btcworld
[17:28:12] RPC request [] submitted to btcworld
[17:28:12] RPC request [] submitted to btcworld
[17:28:15] writing to database
[17:28:15] RPC request [] submitted to btcworld
[17:28:17] RPC request [] submitted to btcworld
[17:28:17] RPC request [] submitted to btcworld
[17:28:20] RPC request [] submitted to btcworld
[17:28:21] RPC request [] submitted to btcworld
[17:28:21] RPC request [] submitted to btcworld
[17:28:21] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000002f355b96f6ce6986e8cb9f14915a134fa572eb53f047d07ebde868b527ab6d204e53b8e41a094a86fde38815000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:28:21] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000cca9ca788055885e693839c11958b655313da83213b4c5ed9af90507233825534e53b8e71a094a867dacf506000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:28:21] RPC request [] submitted to btcworld
[17:28:21] RPC request [] submitted to btcworld
[17:28:24] RPC request [] submitted to btcworld
[17:28:25] RPC request [] submitted to btcworld
[17:28:25] RPC request [] submitted to btcworld
[17:28:28] RPC request [] submitted to btcworld
[17:28:28] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000cdc98814da100a43cf3da8f68dd2e5368aa576c02bf06ff6d1f310b69d1f94c94e53b8ec1a094a866d06b111000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:28:28] RPC request [] submitted to btcworld
[17:28:29] RPC request [] submitted to btcworld
[17:28:29] RPC request [] submitted to btcworld
[17:28:32] RPC request [] submitted to btcworld
[17:28:33] RPC request [] submitted to btcworld
[17:28:33] RPC request [] submitted to btcworld
[17:28:36] RPC request [] submitted to btcworld
[17:28:37] RPC request [] submitted to btcworld
[17:28:37] RPC request [] submitted to btcworld
[17:28:40] RPC request [] submitted to btcworld
[17:28:41] RPC request [] submitted to btcworld
[17:28:41] RPC request [] submitted to btcworld
[17:28:44] RPC request [] submitted to btcworld
[17:28:45] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000fe0f9f8b9ec2f3169ae296fb1545ea705976f6ebe7490cf6ec904586a5555beb4e53b8ff1a094a86c8ac4a03000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:28:45] RPC request [] submitted to btcworld
[17:28:46] RPC request [] submitted to btcworld
[17:28:46] RPC request [] submitted to btcworld
[17:28:48] RPC request [] submitted to btcworld
[17:28:49] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000a30b03b95dee41450f0b40c45a53b2d6b4bc23af4c881098bdecb9861b7ede834e53b9011a094a86e3f20d10000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:28:49] RPC request [] submitted to btcworld
[17:28:50] RPC request [] submitted to btcworld
[17:28:50] RPC request [] submitted to btcworld
[17:28:50] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000045646ac160f205b9d95a19d913faefa86a81169c29d86998de1ec7a32215014b4e53b9051a094a86aa503602000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:28:51] RPC request [] submitted to btcworld
[17:28:53] RPC request [] submitted to btcworld
[17:28:54] RPC request [] submitted to btcworld
[17:28:54] RPC request [] submitted to btcworld
[17:28:57] RPC request [] submitted to btcworld
[17:28:58] RPC request [] submitted to btcworld
[17:28:58] RPC request [] submitted to btcworld
[17:29:01] RPC request [] submitted to btcworld
[17:29:02] RPC request [] submitted to btcworld
[17:29:02] RPC request [] submitted to btcworld
[17:29:05] RPC request [] submitted to btcworld
[17:29:06] RPC request [] submitted to btcworld
[17:29:06] RPC request [] submitted to btcworld
[17:29:09] RPC request [] submitted to btcworld
[17:29:10] RPC request [] submitted to btcworld
[17:29:10] RPC request [] submitted to btcworld
[17:29:12] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000040258ca94e303f5c693f48afaf2726c2ce6bad07c4d557889e00dd5fa17e47bf4e53b91a1a094a86d63c7f06000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:29:12] RPC request [] submitted to btcworld
[17:29:14] RPC request [] submitted to btcworld
[17:29:14] RPC request [] submitted to btcworld
[17:29:15] RPC request [] submitted to btcworld
[17:29:15] writing to database
[17:29:16] triple:	7567988	  
[17:29:17] swepool:	4655991	  3.5gh/s 	34077min.
[17:29:18] RPC request [] submitted to btcworld
[17:29:18] digbtc:	1801957	  
[17:29:19] RPC request [] submitted to btcworld
[17:29:19] RPC request [] submitted to btcworld
[17:29:19] slush:	1160075	  1875.3gh/s 	44min.
[17:29:21] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c39a922b6e320faa07a2d30c4575eeb83cd852c70fd6de2626e9c7d878b32d4d4e53b9211a094a861ae1390d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:29:21] RPC request [] submitted to btcworld
[17:29:22] RPC request [] submitted to btcworld
[17:29:22] arsbitcoin:	1495636	  
[17:29:23] RPC request [] submitted to btcworld
[17:29:23] RPC request [] submitted to btcworld
[17:29:24] btcserv:	1473893	  
[17:29:25] deepbit:	3594627	  5746.0gh/s 
[17:29:26] bithasher:	2383166	  
[17:29:26] RPC request [] submitted to btcworld
[17:29:27] RPC request [] submitted to btcworld
[17:29:27] RPC request [] submitted to btcworld
[17:29:30] RPC request [] submitted to btcworld
[17:29:31] RPC request [] submitted to btcworld
[17:29:31] RPC request [] submitted to btcworld
[17:29:31] btcmonkey:	4310254	  1.9gh/s 
[17:29:32] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000065fae58e8ec1a2d7a7569ec10262541767a7e1849cde08eb9fbd949376762dc04e53b92a1a094a86c665ef18000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:29:32] RPC request [] submitted to btcworld
[17:29:35] RPC request [] submitted to btcworld
[17:29:35] RPC request [] submitted to btcworld
[17:29:35] RPC request [] submitted to btcworld
[17:29:37] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000030b2bfd7b4cf91896bcbc8fc8c83b69f2af167a6080ed0c037ce4f805a8b3b124e53b9321a094a861dab5808000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:29:37] RPC request [] submitted to btcworld
[17:29:39] RPC request [] submitted to btcworld
[17:29:39] RPC request [] submitted to btcworld
[17:29:39] RPC request [] submitted to btcworld
[17:29:43] RPC request [] submitted to btcworld
[17:29:43] RPC request [] submitted to btcworld
[17:29:44] RPC request [] submitted to btcworld
[17:29:47] RPC request [] submitted to btcworld
[17:29:48] RPC request [] submitted to btcworld
[17:29:48] RPC request [] submitted to btcworld
[17:29:51] RPC request [] submitted to btcworld
[17:29:52] RPC request [] submitted to btcworld
[17:29:52] RPC request [] submitted to btcworld
[17:29:55] RPC request [] submitted to btcworld
[17:29:56] RPC request [] submitted to btcworld
[17:29:56] RPC request [] submitted to btcworld
[17:29:59] RPC request [] submitted to btcworld
[17:30:00] RPC request [] submitted to btcworld
[17:30:00] RPC request [] submitted to btcworld
[17:30:04] RPC request [] submitted to btcworld
[17:30:04] RPC request [] submitted to btcworld
[17:30:04] RPC request [] submitted to btcworld
[17:30:06] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000ecfc60ccda8229465a09d65703ac9de6c4cc231847c9805ece5a06b44ed055dc4e53b94f1a094a86ddd5d605000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:30:06] RPC request [] submitted to btcworld
[17:30:08] RPC request [] submitted to btcworld
[17:30:08] RPC request [] submitted to btcworld
[17:30:08] RPC request [] submitted to btcworld
[17:30:12] RPC request [] submitted to btcworld
[17:30:12] RPC request [] submitted to btcworld
[17:30:13] RPC request [] submitted to btcworld
[17:30:13] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000809dee2557a16a175da115ffeef3eb1c6ce7516168b3ed7377049047ee181c444e53b9581a094a866d096303000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:30:14] RPC request [] submitted to btcworld
[17:30:15] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000adbf367e4582898053abd6dff31477db1ecbb753887167c61f34f3a9152c854b4e53b9581a094a864866090a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:30:15] RPC request [] submitted to btcworld
[17:30:15] writing to database
[17:30:16] RPC request [] submitted to btcworld
[17:30:17] RPC request [] submitted to btcworld
[17:30:17] RPC request [] submitted to btcworld
[17:30:20] RPC request [] submitted to btcworld
[17:30:21] RPC request [] submitted to btcworld
[17:30:21] RPC request [] submitted to btcworld
[17:30:24] RPC request [] submitted to btcworld
[17:30:25] RPC request [] submitted to btcworld
[17:30:25] RPC request [] submitted to btcworld
[17:30:28] RPC request [] submitted to btcworld
[17:30:29] RPC request [] submitted to btcworld
[17:30:29] RPC request [] submitted to btcworld
[17:30:33] RPC request [] submitted to btcworld
[17:30:33] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000009f31afa2818794fb486a9ecef97c6c1aba33e1be4fab05e5f96a7093f3889c864e53b9681a094a8609e3ec12000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:30:33] RPC request [] submitted to btcworld
[17:30:33] RPC request [] submitted to btcworld
[17:30:33] RPC request [] submitted to btcworld
[17:30:37] RPC request [] submitted to btcworld
[17:30:37] RPC request [] submitted to btcworld
[17:30:37] RPC request [] submitted to btcworld
[17:30:41] RPC request [] submitted to btcworld
[17:30:41] RPC request [] submitted to btcworld
[17:30:41] RPC request [] submitted to btcworld
[17:30:45] RPC request [] submitted to btcworld
[17:30:46] RPC request [] submitted to btcworld
[17:30:46] RPC request [] submitted to btcworld
[17:30:49] RPC request [] submitted to btcworld
[17:30:50] RPC request [] submitted to btcworld
[17:30:50] RPC request [] submitted to btcworld
[17:30:53] RPC request [] submitted to btcworld
[17:30:54] RPC request [] submitted to btcworld
[17:30:54] RPC request [] submitted to btcworld
[17:30:57] RPC request [] submitted to btcworld
[17:30:58] RPC request [] submitted to btcworld
[17:30:58] RPC request [] submitted to btcworld
[17:31:02] RPC request [] submitted to btcworld
[17:31:02] RPC request [] submitted to btcworld
[17:31:02] RPC request [] submitted to btcworld
[17:31:06] RPC request [] submitted to btcworld
[17:31:06] RPC request [] submitted to btcworld
[17:31:06] RPC request [] submitted to btcworld
[17:31:07] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000933d1e061d895b2100bf5cf537279303ce0b99bd5408a0ef908db5318681d51f4e53b98d1a094a861e83dd07000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:31:07] RPC request [] submitted to btcworld
[17:31:10] RPC request [] submitted to btcworld
[17:31:10] RPC request [] submitted to btcworld
[17:31:11] RPC request [] submitted to btcworld
[17:31:13] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c1f63debdbf2e1ab3b4666e687ec15a0e3cabda149792dd9b8a6f8db5fe4a9e24e53b9921a094a86674fd609000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:31:13] RPC request [] submitted to btcworld
[17:31:14] RPC request [] submitted to btcworld
[17:31:15] RPC request [] submitted to btcworld
[17:31:15] RPC request [] submitted to btcworld
[17:31:15] writing to database
[17:31:16] triple:	7568489	  
[17:31:17] swepool:	4656097	  3.4gh/s 	34079min.
[17:31:18] RPC request [] submitted to btcworld
[17:31:19] RPC request [] submitted to btcworld
[17:31:19] RPC request [] submitted to btcworld
[17:31:19] digbtc:	1802074	  
[17:31:19] slush:	1200078	  1874.2gh/s 	45min.
[17:31:22] RPC request [] submitted to btcworld
[17:31:23] RPC request [] submitted to btcworld
[17:31:23] RPC request [] submitted to btcworld
[17:31:24] btcserv:	1473968	  
[17:31:25] deepbit:	3755620	  5747.0gh/s 
[17:31:26] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000046d0d6f78c6fa8e5737d4c9c174395bd43512fc9224b1a929cbf4797971faaad4e53b99e1a094a86370d140f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:31:26] RPC request [] submitted to btcworld
[17:31:26] bithasher:	2383366	  
[17:31:26] RPC request [] submitted to btcworld
[17:31:27] RPC request [] submitted to btcworld
[17:31:27] RPC request [] submitted to btcworld
[17:31:31] bloodys:	2151614	  
[17:31:31] RPC request [] submitted to btcworld
[17:31:31] RPC request [] submitted to btcworld
[17:31:31] RPC request [] submitted to btcworld
[17:31:32] btcmonkey:	4310297	  1.6gh/s 
[17:31:35] RPC request [] submitted to btcworld
[17:31:35] RPC request [] submitted to btcworld
[17:31:35] bitclockers:	1117519	  232.9gh/s 
[17:31:35] RPC request [] submitted to btcworld
[17:31:37] mtred:	1224722	  220.3gh/s 
[17:31:39] RPC request [] submitted to btcworld
[17:31:39] RPC request [] submitted to btcworld
[17:31:39] RPC request [] submitted to btcworld
[17:31:43] RPC request [] submitted to btcworld
[17:31:44] RPC request [] submitted to btcworld
[17:31:44] RPC request [] submitted to btcworld
[17:31:47] RPC request [] submitted to btcworld
[17:31:48] RPC request [] submitted to btcworld
[17:31:48] RPC request [] submitted to btcworld
[17:31:51] RPC request [] submitted to btcworld
[17:31:52] RPC request [] submitted to btcworld
[17:31:52] RPC request [] submitted to btcworld
[17:31:55] RPC request [] submitted to btcworld
[17:31:56] RPC request [] submitted to btcworld
[17:31:56] RPC request [] submitted to btcworld
[17:32:00] RPC request [] submitted to btcworld
[17:32:00] RPC request [] submitted to btcworld
[17:32:00] RPC request [] submitted to btcworld
[17:32:04] RPC request [] submitted to btcworld
[17:32:04] RPC request [] submitted to btcworld
[17:32:04] RPC request [] submitted to btcworld
[17:32:08] RPC request [] submitted to btcworld
[17:32:08] RPC request [] submitted to btcworld
[17:32:09] RPC request [] submitted to btcworld
[17:32:12] RPC request [] submitted to btcworld
[17:32:13] RPC request [] submitted to btcworld
[17:32:13] RPC request [] submitted to btcworld
[17:32:14] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000036df0453a9f85ba1a1a3ff89bfb1a9f52e907a5090072bd2995471afbfa3d4744e53b9cf1a094a869cb5fa09000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:32:14] RPC request [] submitted to btcworld
[17:32:15] writing to database
[17:32:16] RPC request [] submitted to btcworld
[17:32:17] RPC request [] submitted to btcworld
[17:32:17] RPC request [] submitted to btcworld
[17:32:20] RPC request [] submitted to btcworld
[17:32:21] RPC request [] submitted to btcworld
[17:32:21] RPC request [] submitted to btcworld
[17:32:25] RPC request [] submitted to btcworld
[17:32:25] RPC request [] submitted to btcworld
[17:32:25] RPC request [] submitted to btcworld
[17:32:30] RPC request [] submitted to btcworld
[17:32:30] RPC request [] submitted to btcworld
[17:32:30] RPC request [] submitted to btcworld
[17:32:34] RPC request [] submitted to btcworld
[17:32:34] RPC request [] submitted to btcworld
[17:32:34] RPC request [] submitted to btcworld
[17:32:36] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000006df583e584ee3b8ecb6757ac7d68c0a6a66c15b36b355f0b7c26ae8d1e4372214e53b9e51a094a86bee61c0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:32:36] RPC request [] submitted to btcworld
[17:32:38] RPC request [] submitted to btcworld
[17:32:38] RPC request [] submitted to btcworld
[17:32:38] RPC request [] submitted to btcworld
[17:32:39] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000caf9d7045960e3c53f0e078a66d9359dc07972ef1fa69fa6e78610e3c9d8ed8b4e53b9e91a094a866ef49c05000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:32:39] RPC request [] submitted to btcworld
[17:32:42] RPC request [] submitted to btcworld
[17:32:42] RPC request [] submitted to btcworld
[17:32:42] RPC request [] submitted to btcworld
[17:32:46] RPC request [] submitted to btcworld
[17:32:46] RPC request [] submitted to btcworld
[17:32:46] RPC request [] submitted to btcworld
[17:32:50] RPC request [] submitted to btcworld
[17:32:50] RPC request [] submitted to btcworld
[17:32:50] RPC request [] submitted to btcworld
[17:32:54] RPC request [] submitted to btcworld
[17:32:54] RPC request [] submitted to btcworld
[17:32:54] RPC request [] submitted to btcworld
[17:32:59] RPC request [] submitted to btcworld
[17:32:59] RPC request [] submitted to btcworld
[17:32:59] RPC request [] submitted to btcworld
[17:32:59] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000b22f06a2dce7f2d7d36200b907ee587ae01ff49d9f7b03a7c67cba44ecf31f074e53b9fe1a094a86f730a300000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:32:59] RPC request [] submitted to btcworld
[17:33:03] RPC request [] submitted to btcworld
[17:33:03] RPC request [] submitted to btcworld
[17:33:03] RPC request [] submitted to btcworld
[17:33:04] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000009449704dcdcfcac7f463928373f5c774674d0eb117cb67d69f858c354da66f474e53ba021a094a86b0e10805000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:33:04] RPC request [] submitted to btcworld
[17:33:07] RPC request [] submitted to btcworld
[17:33:07] RPC request [] submitted to btcworld
[17:33:07] RPC request [] submitted to btcworld
[17:33:11] RPC request [] submitted to btcworld
[17:33:11] RPC request [] submitted to btcworld
[17:33:11] RPC request [] submitted to btcworld
[17:33:12] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000024022e7d5940731a51c6484d8d0e50bef2c868cb221b60ee32545fe835ed34c74e53ba0a1a094a862a41d901000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:33:12] RPC request [] submitted to btcworld
[17:33:15] RPC request [] submitted to btcworld
[17:33:15] RPC request [] submitted to btcworld
[17:33:15] RPC request [] submitted to btcworld
[17:33:15] writing to database
[17:33:17] triple:	7569169	  
[17:33:17] swepool:	4656191	  3.4gh/s 	34081min.
[17:33:19] RPC request [] submitted to btcworld
[17:33:19] RPC request [] submitted to btcworld
[17:33:19] RPC request [] submitted to btcworld
[17:33:19] digbtc:	1802221	  
[17:33:19] slush:	1254981	  1874.0gh/s 	48min.
[17:33:23] RPC request [] submitted to btcworld
[17:33:23] RPC request [] submitted to btcworld
[17:33:23] RPC request [] submitted to btcworld
[17:33:24] arsbitcoin:	1532808	  
[17:33:24] btcserv:	1474042	  
[17:33:26] deepbit:	3916581	  5748.0gh/s 
[17:33:27] bithasher:	2383588	  
[17:33:27] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000792b2ebcb254fbcc9fe58ae2df55b54664c9ae32f05de7b15e638abfde7e98fe4e53ba171a094a860ca03b14000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:33:27] RPC request [] submitted to btcworld
[17:33:28] RPC request [] submitted to btcworld
[17:33:28] RPC request [] submitted to btcworld
[17:33:28] RPC request [] submitted to btcworld
[17:33:32] RPC request [] submitted to btcworld
[17:33:32] RPC request [] submitted to btcworld
[17:33:32] RPC request [] submitted to btcworld
[17:33:33] btcmonkey:	4310344	  1.6gh/s 
[17:33:36] RPC request [] submitted to btcworld
[17:33:36] RPC request [] submitted to btcworld
[17:33:36] RPC request [] submitted to btcworld
[17:33:40] RPC request [] submitted to btcworld
[17:33:40] RPC request [] submitted to btcworld
[17:33:40] RPC request [] submitted to btcworld
[17:33:41] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000041339086cd869e84ecfb5c84d1a1695975153be68b681b2c3a48b13fba80facd4e53ba271a094a86fb951504000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:33:41] RPC request [] submitted to btcworld
[17:33:41] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000009146b2d972e01f526dc02dc9acccb6435ae6b77602e4cfaec74888e4918781eb4e53ba271a094a86348e1a05000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:33:41] RPC request [] submitted to btcworld
[17:33:44] RPC request [] submitted to btcworld
[17:33:44] RPC request [] submitted to btcworld
[17:33:44] RPC request [] submitted to btcworld
[17:33:48] RPC request [] submitted to btcworld
[17:33:48] RPC request [] submitted to btcworld
[17:33:48] RPC request [] submitted to btcworld
[17:33:52] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000f4e71172ec6dca5656435ef7a12e89787c5bf30d739610d0e887c2a476e773ae4e53ba301a094a8657da4d11000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:33:52] RPC request [] submitted to btcworld
[17:33:52] RPC request [] submitted to btcworld
[17:33:52] RPC request [] submitted to btcworld
[17:33:53] RPC request [] submitted to btcworld
[17:33:57] RPC request [] submitted to btcworld
[17:33:57] RPC request [] submitted to btcworld
[17:33:57] RPC request [] submitted to btcworld
[17:34:01] RPC request [] submitted to btcworld
[17:34:01] RPC request [] submitted to btcworld
[17:34:01] RPC request [] submitted to btcworld
[17:34:05] RPC request [] submitted to btcworld
[17:34:05] RPC request [] submitted to btcworld
[17:34:05] RPC request [] submitted to btcworld
[17:34:09] RPC request [] submitted to btcworld
[17:34:09] RPC request [] submitted to btcworld
[17:34:09] RPC request [] submitted to btcworld
[17:34:13] RPC request [] submitted to btcworld
[17:34:13] RPC request [] submitted to btcworld
[17:34:13] RPC request [] submitted to btcworld
[17:34:15] writing to database
[17:34:17] RPC request [] submitted to btcworld
[17:34:17] RPC request [] submitted to btcworld
[17:34:17] RPC request [] submitted to btcworld
[17:34:21] RPC request [] submitted to btcworld
[17:34:21] RPC request [] submitted to btcworld
[17:34:22] RPC request [] submitted to btcworld
[17:34:26] RPC request [] submitted to btcworld
[17:34:26] RPC request [] submitted to btcworld
[17:34:26] RPC request [] submitted to btcworld
[17:34:30] RPC request [] submitted to btcworld
[17:34:30] RPC request [] submitted to btcworld
[17:34:30] RPC request [] submitted to btcworld
[17:34:31] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000002d40675a7b00db45451f27a7fb6f0c9469c4c75586c07966c4e29e7b64bde854e53ba591a094a864fe9ec02000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:34:31] RPC request [] submitted to btcworld
[17:34:33] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000047bafab61f9e9e391db46ea1e5a97bbaa9c50fc1cecf7daed832ccd75e728aec4e53ba591a094a86b671bb12000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:34:34] RPC request [] submitted to btcworld
[17:34:34] RPC request [] submitted to btcworld
[17:34:34] RPC request [] submitted to btcworld
[17:34:34] RPC request [] submitted to btcworld
[17:34:38] RPC request [] submitted to btcworld
[17:34:38] RPC request [] submitted to btcworld
[17:34:38] RPC request [] submitted to btcworld
[17:34:42] RPC request [] submitted to btcworld
[17:34:42] RPC request [] submitted to btcworld
[17:34:42] RPC request [] submitted to btcworld
[17:34:43] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000035837f9378ab0960799f35a859832e5d47209f9a845ac4cd9421dfc1a0a2f5294e53ba651a094a86f116d503000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:34:43] RPC request [] submitted to btcworld
[17:34:46] RPC request [] submitted to btcworld
[17:34:46] RPC request [] submitted to btcworld
[17:34:46] RPC request [] submitted to btcworld
[17:34:48] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000c4a8a1c16bbdf844dd414b6548f7dca25e2ea427730405db4271a2dad81a83f54e53ba6a1a094a8621a0c806000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:34:48] RPC request [] submitted to btcworld
[17:34:50] RPC request [] submitted to btcworld
[17:34:51] RPC request [] submitted to btcworld
[17:34:51] RPC request [] submitted to btcworld
[17:34:55] RPC request [] submitted to btcworld
[17:34:55] RPC request [] submitted to btcworld
[17:34:55] RPC request [] submitted to btcworld
[17:34:59] RPC request [] submitted to btcworld
[17:34:59] RPC request [] submitted to btcworld
[17:34:59] RPC request [] submitted to btcworld
[17:35:02] RPC request [] submitted to btcworld
[17:35:03] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add900000067000000000e435db78555bde11ab0490af08091772d32d00a5ccfb0d1a6dc3cd6ed62d04ad4e53ba761a094a867a85c714000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:35:03] RPC request [] submitted to btcworld
[17:35:03] RPC request [] submitted to btcworld
[17:35:03] RPC request [] submitted to btcworld
[17:35:03] RPC request [] submitted to btcworld
[17:35:07] RPC request [] submitted to btcworld
[17:35:07] RPC request [] submitted to btcworld
[17:35:07] RPC request [] submitted to btcworld
[17:35:11] RPC request [] submitted to btcworld
[17:35:11] RPC request [] submitted to btcworld
[17:35:11] RPC request [] submitted to btcworld
[17:35:15] RPC request [] submitted to btcworld
[17:35:15] RPC request [] submitted to btcworld
[17:35:15] writing to database
[17:35:16] RPC request [] submitted to btcworld
[17:35:17] triple:	7569800	  
[17:35:17] swepool:	4656284	  3.4gh/s 	34083min.
[17:35:18] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add90000006700000000041c27c826f36c865299ff45fd98aa4ef9e1dc1e75c3fb88527d71f2621c8595e4e53ba871a094a866b05ad0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:35:18] RPC request [] submitted to btcworld
[17:35:19] RPC request [] submitted to btcworld
[17:35:19] slush:	1309583	  1873.2gh/s 	50min.
[17:35:19] RPC request [] submitted to btcworld
[17:35:20] RPC request [] submitted to btcworld
[17:35:20] digbtc:	1802287	  
[17:35:24] RPC request [] submitted to btcworld
[17:35:24] RPC request [] submitted to btcworld
[17:35:24] RPC request [] submitted to btcworld
[17:35:24] RPC request [u'000000016b308224737bf73f99b3d4e59d6d16c4252e46605a4add9000000670000000000d4777a34d4137a711b0b9aa03634b766afd085950ed56bc5c282c3a90b3e7514e53ba8f1a094a867073d201000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:35:25] RPC request [] submitted to btcworld
[17:35:25] btcserv:	1474126	  
[17:35:26] deepbit:	4077600	  5749.0gh/s 
[17:35:28] bithasher:	2383770	  
[17:35:29] RPC request [] submitted to btcworld
[17:35:29] RPC request [] submitted to btcworld
[17:35:29] RPC request [] submitted to btcworld
[17:35:33] RPC request [] submitted to btcworld
[17:35:33] RPC request [] submitted to btcworld
[17:35:33] RPC request [] submitted to btcworld
[17:35:34] btcmonkey:	4310391	  1.6gh/s 
[17:35:37] RPC request [] submitted to btcworld
[17:35:37] RPC request [] submitted to btcworld
[17:35:37] RPC request [] submitted to btcworld
[17:35:41] RPC request [] submitted to btcworld
[17:35:41] RPC request [] submitted to btcworld
[17:35:41] RPC request [] submitted to btcworld
[17:35:43] mtred:	1239314	  208.9gh/s 
[17:35:45] RPC request [] submitted to btcworld
[17:35:45] RPC request [] submitted to btcworld
[17:35:45] RPC request [] submitted to btcworld
[17:35:49] RPC request [] submitted to btcworld
[17:35:49] RPC request [] submitted to btcworld
[17:35:49] RPC request [] submitted to btcworld
[17:35:53] RPC request [] submitted to btcworld
[17:35:54] RPC request [] submitted to btcworld
[17:35:54] RPC request [] submitted to btcworld
[17:35:58] RPC request [] submitted to btcworld
[17:35:58] RPC request [] submitted to btcworld
[17:35:58] RPC request [] submitted to btcworld
[17:36:02] RPC request [] submitted to btcworld
[17:36:02] RPC request [] submitted to btcworld
[17:36:02] RPC request [] submitted to btcworld
[17:36:06] RPC request [] submitted to btcworld
[17:36:06] RPC request [] submitted to btcworld
[17:36:06] RPC request [] submitted to btcworld
[17:36:07] New Block: b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000
[17:36:07] Block Owner deepbit
[17:36:07] Setting Block Owner deepbit:b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000
[17:36:07] Server change to deepbit
[17:36:07] LP Call http://pit.deepbit.net:8332/listenChannel
[17:36:10] RPC request [] submitted to deepbit
[17:36:10] RPC request [] submitted to deepbit
[17:36:10] LP Call http://mtred.com:8837/LP
[17:36:10] RPC request [] submitted to deepbit
[17:36:12] LP Call http://btcworld.de:8332/LP
[17:36:13] LP Call http://pool.bloodys.com:8332/LP
[17:36:13] LP Call http://digbtc.net:8332/LP
[17:36:14] RPC request [] submitted to deepbit
[17:36:14] RPC request [] submitted to deepbit
[17:36:14] RPC request [] submitted to deepbit
[17:36:16] writing to database
[17:36:17] LP Call http://pool.bitclockers.com:8332/LP
[17:36:19] RPC request [] submitted to deepbit
[17:36:19] RPC request [] submitted to deepbit
[17:36:19] RPC request [] submitted to deepbit
[17:36:20] LP Call http://btcserv.net:8335/LP
[17:36:22] LP Call http://arsbitcoin.com:8344/LP
[17:36:23] RPC request [] submitted to deepbit
[17:36:23] RPC request [] submitted to deepbit
[17:36:23] RPC request [] submitted to deepbit
[17:36:26] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000bf320935245a3b057c25262c62f51fcc91b55dfa9d3a7fe2a826ba3d6f7b03e84e53baae1a094a86662e4c0e000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:36:26] RPC request [] submitted to deepbit
[17:36:27] RPC request [] submitted to deepbit
[17:36:27] RPC request [] submitted to deepbit
[17:36:27] RPC request [] submitted to deepbit
[17:36:29] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000802afcb40f40106c995597931964ea479b4535b58201f342f31332218b13691d4e53bab11a094a86bc73e607000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:36:29] RPC request [] submitted to deepbit
[17:36:29] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000007c73cdb453ed9b0223949650d30f579ca75b3432f12e3547301aca4fff8c3f4f4e53bab11a094a868fdb330a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:36:29] RPC request [] submitted to deepbit
[17:36:31] RPC request [] submitted to deepbit
[17:36:31] RPC request [] submitted to deepbit
[17:36:32] RPC request [] submitted to deepbit
[17:36:35] RPC request [] submitted to deepbit
[17:36:36] RPC request [] submitted to deepbit
[17:36:36] RPC request [] submitted to deepbit
[17:36:36] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000bbb06a5d4d85e37b1f53fec32b267c788896ad6aefca81748b571e8e6fe67adc4e53bab91a094a867d60e800000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:36:36] RPC request [] submitted to deepbit
[17:36:39] RPC request [] submitted to deepbit
[17:36:40] RPC request [] submitted to deepbit
[17:36:40] RPC request [] submitted to deepbit
[17:36:44] RPC request [] submitted to deepbit
[17:36:44] RPC request [] submitted to deepbit
[17:36:44] RPC request [] submitted to deepbit
[17:36:45] LP Call http://swepool.net:8337/LP
[17:36:48] RPC request [] submitted to deepbit
[17:36:48] RPC request [] submitted to deepbit
[17:36:48] RPC request [] submitted to deepbit
[17:36:51] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000003206dc90dfd527a2194a26ef7f50cb6f3d552464d4c8c6c3b8645bdc1bbfd4944e53bac51a094a8696b6310c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:36:51] RPC request [] submitted to deepbit
[17:36:52] RPC request [] submitted to deepbit
[17:36:52] RPC request [] submitted to deepbit
[17:36:52] RPC request [] submitted to deepbit
[17:36:56] RPC request [] submitted to deepbit
[17:36:56] RPC request [] submitted to deepbit
[17:36:57] RPC request [] submitted to deepbit
[17:37:00] LP Call http://ozco.in:8332/LP
[17:37:00] RPC request [] submitted to deepbit
[17:37:01] RPC request [] submitted to deepbit
[17:37:01] RPC request [] submitted to deepbit
[17:37:05] RPC request [] submitted to deepbit
[17:37:05] RPC request [] submitted to deepbit
[17:37:05] RPC request [] submitted to deepbit
[17:37:09] RPC request [] submitted to deepbit
[17:37:09] RPC request [] submitted to deepbit
[17:37:09] RPC request [] submitted to deepbit
[17:37:10] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000bba354749d23f248fe72eccbc34eaa0a56b9e797015b8b0acdff428c0f8200394e53badb1a094a8632816306000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:37:10] RPC request [] submitted to deepbit
[17:37:13] RPC request [] submitted to deepbit
[17:37:13] RPC request [] submitted to deepbit
[17:37:13] RPC request [] submitted to deepbit
[17:37:16] writing to database
[17:37:17] triple:	7570439	  
[17:37:17] RPC request [] submitted to deepbit
[17:37:17] swepool:	4656388	  3.4gh/s 	34085min.
[17:37:18] RPC request [] submitted to deepbit
[17:37:18] RPC request [] submitted to deepbit
[17:37:20] slush:	1361987	  1866.0gh/s 	52min.
[17:37:20] digbtc:	1802431	  
[17:37:22] RPC request [] submitted to deepbit
[17:37:22] RPC request [] submitted to deepbit
[17:37:22] RPC request [] submitted to deepbit
[17:37:22] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000026ce8a22fd837ffaab7c0c7343148bd9bed942a1ace9d05060820405c38181df4e53bae71a094a86354f4003000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:37:22] RPC request [] submitted to deepbit
[17:37:25] btcserv:	1474196	  
[17:37:26] RPC request [] submitted to deepbit
[17:37:26] RPC request [] submitted to deepbit
[17:37:26] RPC request [] submitted to deepbit
[17:37:26] deepbit:	160493	  5729.0gh/s 
[17:37:29] bithasher:	2383952	  
[17:37:30] RPC request [] submitted to deepbit
[17:37:30] RPC request [] submitted to deepbit
[17:37:30] RPC request [] submitted to deepbit
[17:37:34] RPC request [] submitted to deepbit
[17:37:34] RPC request [] submitted to deepbit
[17:37:34] RPC request [] submitted to deepbit
[17:37:35] btcmonkey:	4310450	  1.6gh/s 
[17:37:36] bloodys:	2151761	  
[17:37:36] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000000706dfd083dc438e86cc84244788f097093e821cd5bc62669bf26e25ef19db024e53baf41a094a8605280907000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:37:36] RPC request [] submitted to deepbit
[17:37:38] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000ff456687221910141b43ea4cc80526164e2af37b6e48de7530cfdbf8958e22db4e53baf61a094a866493da08000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:37:38] RPC request [] submitted to deepbit
[17:37:38] RPC request [] submitted to deepbit
[17:37:39] RPC request [] submitted to deepbit
[17:37:39] RPC request [] submitted to deepbit
[17:37:39] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000005df9d3a1dcd76ddec759099d38b82bcc87c7e832c0ac80c5327843c7e3153d6e4e53baf81a094a86dd1c1b03000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:37:39] RPC request [] submitted to deepbit
[17:37:41] bitclockers:	1128023	  230.3gh/s 
[17:37:43] RPC request [] submitted to deepbit
[17:37:43] RPC request [] submitted to deepbit
[17:37:43] RPC request [] submitted to deepbit
[17:37:44] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000001f667265df32148fe9e8b83a0dace0791e2391758fe2d86db00246a05982b99f4e53bafc1a094a86eb6dfa02000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:37:44] RPC request [] submitted to deepbit
[17:37:47] RPC request [] submitted to deepbit
[17:37:47] RPC request [] submitted to deepbit
[17:37:47] RPC request [] submitted to deepbit
[17:37:51] RPC request [] submitted to deepbit
[17:37:51] RPC request [] submitted to deepbit
[17:37:51] RPC request [] submitted to deepbit
[17:37:55] RPC request [] submitted to deepbit
[17:37:55] RPC request [] submitted to deepbit
[17:37:55] RPC request [] submitted to deepbit
[17:37:59] RPC request [] submitted to deepbit
[17:37:59] RPC request [] submitted to deepbit
[17:38:00] RPC request [] submitted to deepbit
[17:38:03] RPC request [] submitted to deepbit
[17:38:04] RPC request [] submitted to deepbit
[17:38:04] RPC request [] submitted to deepbit
[17:38:08] RPC request [] submitted to deepbit
[17:38:08] RPC request [] submitted to deepbit
[17:38:08] RPC request [] submitted to deepbit
[17:38:12] RPC request [] submitted to deepbit
[17:38:12] RPC request [] submitted to deepbit
[17:38:12] RPC request [] submitted to deepbit
[17:38:16] writing to database
[17:38:16] RPC request [] submitted to deepbit
[17:38:16] RPC request [] submitted to deepbit
[17:38:17] RPC request [] submitted to deepbit
[17:38:20] RPC request [] submitted to deepbit
[17:38:20] RPC request [] submitted to deepbit
[17:38:21] RPC request [] submitted to deepbit
[17:38:24] RPC request [] submitted to deepbit
[17:38:24] RPC request [] submitted to deepbit
[17:38:25] RPC request [] submitted to deepbit
[17:38:28] ozco:	1888682	  61.8gh/s 	1243min.
[17:38:28] RPC request [] submitted to deepbit
[17:38:28] RPC request [] submitted to deepbit
[17:38:29] RPC request [] submitted to deepbit
[17:38:32] RPC request [] submitted to deepbit
[17:38:33] RPC request [] submitted to deepbit
[17:38:34] RPC request [] submitted to deepbit
[17:38:37] RPC request [] submitted to deepbit
[17:38:37] RPC request [] submitted to deepbit
[17:38:38] RPC request [] submitted to deepbit
[17:38:41] RPC request [] submitted to deepbit
[17:38:41] RPC request [] submitted to deepbit
[17:38:42] RPC request [] submitted to deepbit
[17:38:45] RPC request [] submitted to deepbit
[17:38:45] RPC request [] submitted to deepbit
[17:38:46] RPC request [] submitted to deepbit
[17:38:49] RPC request [] submitted to deepbit
[17:38:49] RPC request [] submitted to deepbit
[17:38:51] RPC request [] submitted to deepbit
[17:38:53] RPC request [] submitted to deepbit
[17:38:53] RPC request [] submitted to deepbit
[17:38:55] RPC request [] submitted to deepbit
[17:38:55] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000107fc13ba78c41624fcb2bc9138f78d8be9e2012c57eddfaaecbe37db8c8189d4e53bb441a094a863f426c01000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:38:56] RPC request [] submitted to deepbit
[17:38:57] RPC request [] submitted to deepbit
[17:38:57] RPC request [] submitted to deepbit
[17:38:59] RPC request [] submitted to deepbit
[17:39:02] RPC request [] submitted to deepbit
[17:39:02] RPC request [] submitted to deepbit
[17:39:03] RPC request [] submitted to deepbit
[17:39:06] RPC request [] submitted to deepbit
[17:39:06] RPC request [] submitted to deepbit
[17:39:07] RPC request [] submitted to deepbit
[17:39:10] RPC request [] submitted to deepbit
[17:39:10] RPC request [] submitted to deepbit
[17:39:12] RPC request [] submitted to deepbit
[17:39:14] RPC request [] submitted to deepbit
[17:39:14] RPC request [] submitted to deepbit
[17:39:16] RPC request [] submitted to deepbit
[17:39:16] writing to database
[17:39:17] swepool:	4656490	  3.4gh/s 	34087min.
[17:39:17] triple:	7571069	  
[17:39:18] RPC request [] submitted to deepbit
[17:39:19] RPC request [] submitted to deepbit
[17:39:20] slush:	1417187	  1865.2gh/s 	54min.
[17:39:20] RPC request [] submitted to deepbit
[17:39:21] digbtc:	1802587	  
[17:39:22] RPC request [] submitted to deepbit
[17:39:23] RPC request [] submitted to deepbit
[17:39:23] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000200f94348160d69be7fa10e8fd2739f0c33759a5b0e4e37b8f60615157df3af24e53bb601a094a860e4b9203000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:39:23] RPC request [] submitted to deepbit
[17:39:24] RPC request [] submitted to deepbit
[17:39:24] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000009832a810531829f258eadc5ece63de7699414f8da482f06b002e2f54f5fa37f94e53bb611a094a868c2cbd05000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:39:25] RPC request [] submitted to deepbit
[17:39:25] btcserv:	1474289	  
[17:39:26] arsbitcoin:	1568778	  
[17:39:26] RPC request [] submitted to deepbit
[17:39:27] deepbit:	321249	  5741.0gh/s 
[17:39:27] RPC request [] submitted to deepbit
[17:39:28] RPC request [] submitted to deepbit
[17:39:29] bithasher:	2384120	  
[17:39:31] RPC request [] submitted to deepbit
[17:39:31] RPC request [] submitted to deepbit
[17:39:32] RPC request [] submitted to deepbit
[17:39:35] RPC request [] submitted to deepbit
[17:39:35] RPC request [] submitted to deepbit
[17:39:36] btcmonkey:	4310511	  1.6gh/s 
[17:39:36] RPC request [] submitted to deepbit
[17:39:39] RPC request [] submitted to deepbit
[17:39:39] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000088a2591962891fd3c5f980bfd60be4faad8c23c74abd858264598050553d8ae54e53bb6e1a094a8679600e0f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:39:39] RPC request [] submitted to deepbit
[17:39:40] RPC request [] submitted to deepbit
[17:39:40] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000003cbba5e815069e4d686c57f2fef15b165aa37109c3afb49e81158d2bd4ad2c504e53bb711a094a865f484b03000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:39:40] RPC request [] submitted to deepbit
[17:39:41] RPC request [] submitted to deepbit
[17:39:43] RPC request [] submitted to deepbit
[17:39:44] RPC request [] submitted to deepbit
[17:39:45] RPC request [] submitted to deepbit
[17:39:47] RPC request [] submitted to deepbit
[17:39:48] RPC request [] submitted to deepbit
[17:39:49] RPC request [] submitted to deepbit
[17:39:52] RPC request [] submitted to deepbit
[17:39:52] RPC request [] submitted to deepbit
[17:39:53] RPC request [] submitted to deepbit
[17:39:56] RPC request [] submitted to deepbit
[17:39:56] RPC request [] submitted to deepbit
[17:39:58] RPC request [] submitted to deepbit
[17:40:00] RPC request [] submitted to deepbit
[17:40:00] RPC request [] submitted to deepbit
[17:40:02] RPC request [] submitted to deepbit
[17:40:04] RPC request [] submitted to deepbit
[17:40:04] RPC request [] submitted to deepbit
[17:40:06] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000064543bed674b110920e2e76c0c538765a5b2c6a7e9b51998aed917eeb6a071cf4e53bb871a094a8668367e15000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:40:06] RPC request [] submitted to deepbit
[17:40:06] RPC request [] submitted to deepbit
[17:40:08] RPC request [] submitted to deepbit
[17:40:09] RPC request [] submitted to deepbit
[17:40:09] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000001344c51539b6843a41f15d29ea88dbc2743a582ae117f8ee58f5dabb00c6dfc64e53bb8c1a094a869458f60c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:40:09] RPC request [] submitted to deepbit
[17:40:11] RPC request [] submitted to deepbit
[17:40:12] RPC request [] submitted to deepbit
[17:40:13] RPC request [] submitted to deepbit
[17:40:15] RPC request [] submitted to deepbit
[17:40:16] writing to database
[17:40:17] RPC request [] submitted to deepbit
[17:40:17] RPC request [] submitted to deepbit
[17:40:18] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000867aac274045decbe4dc85aaa9de9bf54c49ff587e3233c1267513ad38fd52084e53bb971a094a863ca1b901000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:40:18] RPC request [] submitted to deepbit
[17:40:19] RPC request [] submitted to deepbit
[17:40:21] RPC request [] submitted to deepbit
[17:40:21] RPC request [] submitted to deepbit
[17:40:23] RPC request [] submitted to deepbit
[17:40:25] RPC request [] submitted to deepbit
[17:40:25] RPC request [] submitted to deepbit
[17:40:27] RPC request [] submitted to deepbit
[17:40:29] RPC request [] submitted to deepbit
[17:40:29] RPC request [] submitted to deepbit
[17:40:32] RPC request [] submitted to deepbit
[17:40:33] RPC request [] submitted to deepbit
[17:40:34] RPC request [] submitted to deepbit
[17:40:36] RPC request [] submitted to deepbit
[17:40:37] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000645b3f107cff7cc2e6c399e921c7e861426a824ab5cb12ac62d2298d7a3148884e53bba91a094a867b3fca04000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:40:37] RPC request [] submitted to deepbit
[17:40:37] RPC request [] submitted to deepbit
[17:40:38] RPC request [] submitted to deepbit
[17:40:40] RPC request [] submitted to deepbit
[17:40:41] RPC request [] submitted to deepbit
[17:40:42] RPC request [] submitted to deepbit
[17:40:44] RPC request [] submitted to deepbit
[17:40:46] RPC request [] submitted to deepbit
[17:40:46] RPC request [] submitted to deepbit
[17:40:48] RPC request [] submitted to deepbit
[17:40:50] RPC request [] submitted to deepbit
[17:40:50] RPC request [] submitted to deepbit
[17:40:53] RPC request [] submitted to deepbit
[17:40:54] RPC request [] submitted to deepbit
[17:40:54] RPC request [] submitted to deepbit
[17:40:57] RPC request [] submitted to deepbit
[17:40:58] RPC request [] submitted to deepbit
[17:40:58] RPC request [] submitted to deepbit
[17:41:01] RPC request [] submitted to deepbit
[17:41:03] RPC request [] submitted to deepbit
[17:41:03] RPC request [] submitted to deepbit
[17:41:05] RPC request [] submitted to deepbit
[17:41:07] RPC request [] submitted to deepbit
[17:41:07] RPC request [] submitted to deepbit
[17:41:09] RPC request [] submitted to deepbit
[17:41:11] RPC request [] submitted to deepbit
[17:41:11] RPC request [] submitted to deepbit
[17:41:13] RPC request [] submitted to deepbit
[17:41:15] RPC request [] submitted to deepbit
[17:41:16] RPC request [] submitted to deepbit
[17:41:16] writing to database
[17:41:17] RPC request [] submitted to deepbit
[17:41:18] swepool:	4656583	  3.4gh/s 	34089min.
[17:41:18] triple:	7571541	  
[17:41:19] RPC request [] submitted to deepbit
[17:41:20] RPC request [] submitted to deepbit
[17:41:21] digbtc:	1802709	  
[17:41:22] RPC request [] submitted to deepbit
[17:41:23] RPC request [] submitted to deepbit
[17:41:24] RPC request [] submitted to deepbit
[17:41:25] btcserv:	1474374	  
[17:41:26] RPC request [] submitted to deepbit
[17:41:27] deepbit:	482234	  5749.0gh/s 
[17:41:27] RPC request [] submitted to deepbit
[17:41:28] RPC request [] submitted to deepbit
[17:41:30] RPC request [] submitted to deepbit
[17:41:30] bithasher:	2384308	  
[17:41:30] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000a40fa9ebfddddcc17999e2f2d45f945475b5cc249a1b0559e0ba2eb198bab0c64e53bbdf1a094a8670fc7301000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:30] RPC request [] submitted to deepbit
[17:41:31] RPC request [] submitted to deepbit
[17:41:32] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000d80121642ef98dde23dd81a40a3df399dbec605b98a8c31a9c7bc557036d094e4e53bbdd1a094a86443f7416000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:32] RPC request [] submitted to deepbit
[17:41:32] RPC request [] submitted to deepbit
[17:41:34] RPC request [] submitted to deepbit
[17:41:34] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000f56631d9f46c84119876edb83779854c93b756b4ffb7b5a7a8c6bb5c299ae76e4e53bbe21a094a86d0304c08000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:34] RPC request [] submitted to deepbit
[17:41:36] RPC request [] submitted to deepbit
[17:41:36] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000eec71dd0c9101eab6129832ac860f44dff0453d462c69a70ec44742028ee36e14e53bbe51a094a867694a401000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:37] RPC request [] submitted to deepbit
[17:41:37] RPC request [] submitted to deepbit
[17:41:37] btcmonkey:	4310557	  1.9gh/s 
[17:41:38] RPC request [] submitted to deepbit
[17:41:40] RPC request [] submitted to deepbit
[17:41:41] Error in pool api for slush
[17:41:41] RPC request [] submitted to deepbit
[17:41:42] RPC request [] submitted to deepbit
[17:41:44] RPC request [] submitted to deepbit
[17:41:45] RPC request [] submitted to deepbit
[17:41:46] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000c1be8c4e7564e325bd899699f1349df81395fea0ae00118f77182042703b5cb94e53bbed1a094a8606ec240d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:47] RPC request [] submitted to deepbit
[17:41:47] RPC request [] submitted to deepbit
[17:41:47] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000000dd116629b3213938057253f845d0e3020e549a9f596a52f6d6285737f90db7e4e53bbf01a094a86f777ac02000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:48] RPC request [] submitted to deepbit
[17:41:48] RPC request [] submitted to deepbit
[17:41:49] mtred:	1247180	  112.6gh/s 
[17:41:49] RPC request [] submitted to deepbit
[17:41:50] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000004a19b6b4a22a129f3ec1a239d47070f98fa3d638f21e63adfddeb2e82367cac24e53bbf11a094a86696ecd09000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:50] RPC request [] submitted to deepbit
[17:41:51] RPC request [] submitted to deepbit
[17:41:52] bloodys:	2151907	  
[17:41:52] RPC request [] submitted to deepbit
[17:41:53] RPC request [] submitted to deepbit
[17:41:55] RPC request [] submitted to deepbit
[17:41:56] RPC request [] submitted to deepbit
[17:41:57] bitclockers:	1138006	  216.4gh/s 
[17:41:57] RPC request [] submitted to deepbit
[17:41:59] RPC request [] submitted to deepbit
[17:41:59] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000098d4c7f838994ecf76d310a5a562f5c73455d5411921f109c3eccec952d78c3b4e53bbfa1a094a86f3dd1a0f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:41:59] RPC request [] submitted to deepbit
[17:42:01] RPC request [] submitted to deepbit
[17:42:01] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000056cd3cb30fb03e0d22e418fc655ea62ec745e1750f7a0eb01c4817df351fb5074e53bbfc1a094a865cf53806000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:42:01] RPC request [] submitted to deepbit
[17:42:02] RPC request [] submitted to deepbit
[17:42:03] RPC request [] submitted to deepbit
[17:42:05] RPC request [] submitted to deepbit
[17:42:06] RPC request [] submitted to deepbit
[17:42:08] RPC request [] submitted to deepbit
[17:42:09] RPC request [] submitted to deepbit
[17:42:10] RPC request [] submitted to deepbit
[17:42:12] RPC request [] submitted to deepbit
[17:42:13] RPC request [] submitted to deepbit
[17:42:14] RPC request [] submitted to deepbit
[17:42:16] writing to database
[17:42:16] RPC request [] submitted to deepbit
[17:42:17] RPC request [] submitted to deepbit
[17:42:18] RPC request [] submitted to deepbit
[17:42:20] RPC request [] submitted to deepbit
[17:42:20] RPC request [] submitted to deepbit
[17:42:21] RPC request [] submitted to deepbit
[17:42:22] RPC request [] submitted to deepbit
[17:42:24] RPC request [] submitted to deepbit
[17:42:25] RPC request [] submitted to deepbit
[17:42:25] RPC request [] submitted to deepbit
[17:42:26] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000e61038976e75494f20db4f72f00d53b34a797b384280daba84587bcf45f6f16c4e53bc171a094a863ca31804000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:42:27] RPC request [] submitted to deepbit
[17:42:27] RPC request [] submitted to deepbit
[17:42:27] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000055ba93bc6f908687905ed9cc6ad00c16222f2e917a52f25b8d0fc193622867774e53bc181a094a865d9f0400000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:42:27] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000fccf63f2a91d391c4494c551d5bf2f3e7ad013125ffc76b54d34adc3426cf36f4e53bc161a094a86fe05800a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:42:27] RPC request [] submitted to deepbit
[17:42:27] RPC request [] submitted to deepbit
[17:42:29] RPC request [] submitted to deepbit
[17:42:29] RPC request [] submitted to deepbit
[17:42:30] RPC request [] submitted to deepbit
[17:42:31] RPC request [] submitted to deepbit
[17:42:31] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000028b51cad1eb55d7ac7613030c10e01238ec4f43c3d9c6205031b89de673b90904e53bc1a1a094a8663328e0b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:42:31] RPC request [] submitted to deepbit
[17:42:33] RPC request [] submitted to deepbit
[17:42:33] RPC request [] submitted to deepbit
[17:42:34] RPC request [] submitted to deepbit
[17:42:35] RPC request [] submitted to deepbit
[17:42:37] RPC request [] submitted to deepbit
[17:42:37] RPC request [] submitted to deepbit
[17:42:38] RPC request [] submitted to deepbit
[17:42:39] RPC request [] submitted to deepbit
[17:42:41] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000a35a4e67e9e81f8d63b621e895207ebb6119dedb1845cfdb090e3339eb2f126c4e53bc241a094a86007c3c0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:42:41] RPC request [] submitted to deepbit
[17:42:41] RPC request [] submitted to deepbit
[17:42:41] RPC request [] submitted to deepbit
[17:42:42] RPC request [] submitted to deepbit
[17:42:43] RPC request [] submitted to deepbit
[17:42:45] RPC request [] submitted to deepbit
[17:42:46] RPC request [] submitted to deepbit
[17:42:46] RPC request [] submitted to deepbit
[17:42:47] RPC request [] submitted to deepbit
[17:42:50] RPC request [] submitted to deepbit
[17:42:50] RPC request [] submitted to deepbit
[17:42:51] RPC request [] submitted to deepbit
[17:42:52] RPC request [] submitted to deepbit
[17:42:54] RPC request [] submitted to deepbit
[17:42:54] RPC request [] submitted to deepbit
[17:42:55] RPC request [] submitted to deepbit
[17:42:56] RPC request [] submitted to deepbit
[17:42:56] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000a585c993f90d11637a03ea549a01e78eee097b5f8e53fd878a5486fb1a2542324e53bc331a094a86103d8607000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:42:56] RPC request [] submitted to deepbit
[17:42:58] RPC request [] submitted to deepbit
[17:42:58] RPC request [] submitted to deepbit
[17:42:59] RPC request [] submitted to deepbit
[17:43:00] RPC request [] submitted to deepbit
[17:43:00] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000004eef31e0b02e337ebffb132944a34d07a2baa50a182b1e7ce02f78654ed524344e53bc381a094a86a1803e05000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:43:00] RPC request [] submitted to deepbit
[17:43:01] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000005b278113abd0ad1b1705bc6107af907bffb267f3d5f1a2494a028fd23d2278ad4e53bc391a094a865de6aa02000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:43:01] RPC request [] submitted to deepbit
[17:43:02] RPC request [] submitted to deepbit
[17:43:02] RPC request [] submitted to deepbit
[17:43:03] RPC request [] submitted to deepbit
[17:43:04] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000009316485e41725acd2eef1acd924ed4199f6e9c9925547d2782a64aff6c2d30e64e53bc3a1a094a868186a20f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:43:04] RPC request [] submitted to deepbit
[17:43:04] RPC request [] submitted to deepbit
[17:43:04] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000a7492abf5014a98afcced8f2bb72f4f3457f158870b6b51f8adb41d6765387164e53bc3c1a094a860a2a220b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:43:05] RPC request [] submitted to deepbit
[17:43:06] RPC request [] submitted to deepbit
[17:43:06] RPC request [] submitted to deepbit
[17:43:07] RPC request [] submitted to deepbit
[17:43:09] RPC request [] submitted to deepbit
[17:43:11] RPC request [] submitted to deepbit
[17:43:11] RPC request [] submitted to deepbit
[17:43:12] RPC request [] submitted to deepbit
[17:43:13] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000de2fa9c95ff6fe64f9acc06c8bbf4e5700557e361dca9bccf78b72be118014394e53bc441a094a866924790a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:43:13] RPC request [] submitted to deepbit
[17:43:13] RPC request [] submitted to deepbit
[17:43:15] RPC request [] submitted to deepbit
[17:43:15] RPC request [] submitted to deepbit
[17:43:16] RPC request [] submitted to deepbit
[17:43:16] writing to database
[17:43:17] RPC request [] submitted to deepbit
[17:43:18] swepool:	4656682	  3.4gh/s 	34091min.
[17:43:18] triple:	7572178	  
[17:43:19] RPC request [] submitted to deepbit
[17:43:19] RPC request [] submitted to deepbit
[17:43:20] RPC request [] submitted to deepbit
[17:43:21] RPC request [] submitted to deepbit
[17:43:22] digbtc:	1802854	  
[17:43:23] RPC request [] submitted to deepbit
[17:43:23] RPC request [] submitted to deepbit
[17:43:24] RPC request [] submitted to deepbit
[17:43:25] RPC request [] submitted to deepbit
[17:43:26] btcserv:	1474472	  
[17:43:27] deepbit:	643643	  5758.0gh/s 
[17:43:27] Server change to btcworld
[17:43:27] RPC request [] submitted to deepbit
[17:43:28] RPC request [] submitted to btcworld
[17:43:28] RPC request [] submitted to btcworld
[17:43:29] arsbitcoin:	1603632	  
[17:43:30] RPC request [] submitted to btcworld
[17:43:31] bithasher:	2384494	  
[17:43:32] RPC request [] submitted to btcworld
[17:43:33] RPC request [] submitted to btcworld
[17:43:33] RPC request [] submitted to btcworld
[17:43:35] RPC request [] submitted to btcworld
[17:43:36] RPC request [] submitted to btcworld
[17:43:38] RPC request [] submitted to btcworld
[17:43:38] RPC request [] submitted to btcworld
[17:43:39] btcmonkey:	4310597	  1.9gh/s 
[17:43:39] RPC request [] submitted to btcworld
[17:43:40] RPC request [] submitted to btcworld
[17:43:41] slush:	1526994	  1863.3gh/s 	58min.
[17:43:42] RPC request [] submitted to btcworld
[17:43:42] RPC request [] submitted to btcworld
[17:43:43] RPC request [] submitted to btcworld
[17:43:44] RPC request [] submitted to btcworld
[17:43:46] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000049943e74e6e55bbcd0490d81e9cbff239b5bb2198c6e2b3adb9b9143581271cc4e53bc811a094a86aebad011000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:43:46] RPC request [] submitted to btcworld
[17:43:46] RPC request [] submitted to btcworld
[17:43:46] RPC request [] submitted to btcworld
[17:43:48] RPC request [] submitted to btcworld
[17:43:49] RPC request [] submitted to btcworld
[17:43:50] RPC request [] submitted to btcworld
[17:43:51] RPC request [] submitted to btcworld
[17:43:54] RPC request [] submitted to btcworld
[17:43:55] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000b36181c256f34e7033309984f41cadbc7c9a5d4aae4026c18b891b6d9a690d714e53bc881a094a86a6e38c11000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:43:55] RPC request [] submitted to btcworld
[17:43:55] RPC request [] submitted to btcworld
[17:43:55] RPC request [] submitted to btcworld
[17:43:56] RPC request [] submitted to btcworld
[17:44:00] RPC request [] submitted to btcworld
[17:44:00] RPC request [] submitted to btcworld
[17:44:00] RPC request [] submitted to btcworld
[17:44:00] RPC request [] submitted to btcworld
[17:44:01] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000005bf960bf97fce02711c8466dcee55e9fec174893e706ca0daaad3beb3c54e3ae4e53bc8c1a094a861955f420000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:01] RPC request [] submitted to btcworld
[17:44:07] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000f6bd8b2f668df198c63e8e4506b3953dc5012cb9377ecf40d8cc52f47043c77e4e53bc941a094a86c84a1c12000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:07] RPC request [] submitted to btcworld
[17:44:07] RPC request [] submitted to btcworld
[17:44:07] RPC request [] submitted to btcworld
[17:44:07] RPC request [] submitted to btcworld
[17:44:08] RPC request [] submitted to btcworld
[17:44:11] RPC request [] submitted to btcworld
[17:44:11] RPC request [] submitted to btcworld
[17:44:11] RPC request [] submitted to btcworld
[17:44:12] RPC request [] submitted to btcworld
[17:44:16] RPC request [] submitted to btcworld
[17:44:16] RPC request [] submitted to btcworld
[17:44:16] RPC request [] submitted to btcworld
[17:44:16] RPC request [] submitted to btcworld
[17:44:16] writing to database
[17:44:20] RPC request [] submitted to btcworld
[17:44:20] RPC request [] submitted to btcworld
[17:44:20] RPC request [] submitted to btcworld
[17:44:20] RPC request [] submitted to btcworld
[17:44:25] RPC request [] submitted to btcworld
[17:44:25] RPC request [] submitted to btcworld
[17:44:25] RPC request [] submitted to btcworld
[17:44:25] RPC request [] submitted to btcworld
[17:44:29] RPC request [] submitted to btcworld
[17:44:29] RPC request [] submitted to btcworld
[17:44:29] RPC request [] submitted to btcworld
[17:44:29] RPC request [] submitted to btcworld
[17:44:32] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000004490fb81a722c1624746f6e7ba0fb8f4164918c9f2fc10476fda5d2c327fa14c4e53bcb01a094a8651bf7210000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:33] RPC request [] submitted to btcworld
[17:44:33] RPC request [] submitted to btcworld
[17:44:33] RPC request [] submitted to btcworld
[17:44:33] RPC request [] submitted to btcworld
[17:44:33] RPC request [] submitted to btcworld
[17:44:34] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000cefd5e0878f6af5e87f00be4d11da5f5a6d49e8f236f12bf644b8bc2f8dbd3494e53bcb01a094a863a4d1c17000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:34] RPC request [] submitted to btcworld
[17:44:37] RPC request [] submitted to btcworld
[17:44:37] RPC request [] submitted to btcworld
[17:44:37] RPC request [] submitted to btcworld
[17:44:37] RPC request [] submitted to btcworld
[17:44:38] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000609832b15de1b9a2c139d86adc3be54077873419b79b8f10e486d3293212161f4e53bcb91a094a865cba6400000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:38] RPC request [] submitted to btcworld
[17:44:38] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000061f003fbe4ebea53db28d900e3026eba6d06e5e0926d0e49546b6318bf40a5304e53bcb91a094a86dea7b001000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:38] RPC request [] submitted to btcworld
[17:44:43] RPC request [] submitted to btcworld
[17:44:43] RPC request [] submitted to btcworld
[17:44:43] RPC request [] submitted to btcworld
[17:44:43] RPC request [] submitted to btcworld
[17:44:46] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000004b4f86b60c818e639da28c6ece16402a555d8f00e563d2ea88c52b55095cec164e53bcbd1a094a8603d1850e000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:46] RPC request [] submitted to btcworld
[17:44:47] RPC request [] submitted to btcworld
[17:44:47] RPC request [] submitted to btcworld
[17:44:47] RPC request [] submitted to btcworld
[17:44:47] RPC request [] submitted to btcworld
[17:44:51] RPC request [] submitted to btcworld
[17:44:51] RPC request [] submitted to btcworld
[17:44:51] RPC request [] submitted to btcworld
[17:44:51] RPC request [] submitted to btcworld
[17:44:55] RPC request [] submitted to btcworld
[17:44:55] RPC request [] submitted to btcworld
[17:44:55] RPC request [] submitted to btcworld
[17:44:55] RPC request [] submitted to btcworld
[17:44:58] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000005bbbe768273be4e050cb3d909db241e55c20cb4801ee70c79715c2b760b170594e53bcca1a094a86c20d210f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:44:59] RPC request [] submitted to btcworld
[17:44:59] RPC request [] submitted to btcworld
[17:44:59] RPC request [] submitted to btcworld
[17:44:59] RPC request [] submitted to btcworld
[17:44:59] RPC request [] submitted to btcworld
[17:45:03] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000acdd63a65910947d48fafe539d0fac311448041418197554a79030a26e7016ed4e53bcce1a094a86e64de811000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:45:03] RPC request [] submitted to btcworld
[17:45:03] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000002470cc4285ced2ab465508291af74114e95786fe14194ac076e907e4736c9cd34e53bccf1a094a866aa7fd10000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:45:03] RPC request [] submitted to btcworld
[17:45:03] RPC request [] submitted to btcworld
[17:45:03] RPC request [] submitted to btcworld
[17:45:04] RPC request [] submitted to btcworld
[17:45:04] RPC request [] submitted to btcworld
[17:45:07] RPC request [] submitted to btcworld
[17:45:08] RPC request [] submitted to btcworld
[17:45:08] RPC request [] submitted to btcworld
[17:45:08] btcworld:	541123	  
[17:45:08] RPC request [] submitted to btcworld
[17:45:12] RPC request [] submitted to btcworld
[17:45:12] RPC request [] submitted to btcworld
[17:45:12] RPC request [] submitted to btcworld
[17:45:12] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000069f90de6e6452ebeca6c148acf9a8b8814c54bae2122b132416e38c69f3a07c04e53bcd81a094a86071cdf0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:45:12] RPC request [] submitted to btcworld
[17:45:13] RPC request [] submitted to btcworld
[17:45:16] RPC request [] submitted to btcworld
[17:45:16] RPC request [] submitted to btcworld
[17:45:16] RPC request [] submitted to btcworld
[17:45:17] writing to database
[17:45:17] RPC request [] submitted to btcworld
[17:45:18] swepool:	4656764	  3.4gh/s 	34093min.
[17:45:18] triple:	7572779	  
[17:45:20] RPC request [] submitted to btcworld
[17:45:20] RPC request [] submitted to btcworld
[17:45:20] RPC request [] submitted to btcworld
[17:45:21] RPC request [] submitted to btcworld
[17:45:22] digbtc:	1781707	  
[17:45:24] RPC request [] submitted to btcworld
[17:45:24] RPC request [] submitted to btcworld
[17:45:25] RPC request [] submitted to btcworld
[17:45:25] RPC request [] submitted to btcworld
[17:45:26] btcserv:	1474539	  
[17:45:28] deepbit:	805163	  5763.0gh/s 
[17:45:28] RPC request [] submitted to btcworld
[17:45:29] RPC request [] submitted to btcworld
[17:45:29] RPC request [] submitted to btcworld
[17:45:29] RPC request [] submitted to btcworld
[17:45:32] bithasher:	2384697	  
[17:45:33] RPC request [] submitted to btcworld
[17:45:33] RPC request [] submitted to btcworld
[17:45:33] RPC request [] submitted to btcworld
[17:45:34] RPC request [] submitted to btcworld
[17:45:37] RPC request [] submitted to btcworld
[17:45:37] RPC request [] submitted to btcworld
[17:45:38] RPC request [] submitted to btcworld
[17:45:38] RPC request [] submitted to btcworld
[17:45:44] Error in pool api for btcmonkey
[17:45:44] RPC request [] submitted to btcworld
[17:45:44] RPC request [] submitted to btcworld
[17:45:44] RPC request [] submitted to btcworld
[17:45:44] RPC request [] submitted to btcworld
[17:45:44] slush:	1582294	  1860.8gh/s 	60min.
[17:45:48] RPC request [] submitted to btcworld
[17:45:48] RPC request [] submitted to btcworld
[17:45:48] RPC request [] submitted to btcworld
[17:45:48] RPC request [] submitted to btcworld
[17:45:51] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000003a8e31c907c4fa6238669f68ba6dd4c12a0c6cd8c8df2087f58036caf9eb599e4e53bd001a094a86485f250e000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:45:51] RPC request [] submitted to btcworld
[17:45:52] RPC request [] submitted to btcworld
[17:45:53] RPC request [] submitted to btcworld
[17:45:53] RPC request [] submitted to btcworld
[17:45:53] RPC request [] submitted to btcworld
[17:45:57] RPC request [] submitted to btcworld
[17:45:57] RPC request [] submitted to btcworld
[17:45:57] RPC request [] submitted to btcworld
[17:45:57] RPC request [] submitted to btcworld
[17:45:58] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000071b333bca63922dfdb014c9d5ec4f126b1d0fcc636491e8b531f1f53f8e19e314e53bd081a094a863cb0a307000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:45:58] RPC request [] submitted to btcworld
[17:46:01] RPC request [] submitted to btcworld
[17:46:01] RPC request [] submitted to btcworld
[17:46:01] RPC request [] submitted to btcworld
[17:46:01] RPC request [] submitted to btcworld
[17:46:02] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000001727dddb811ec3f9289456133986e589a44b23387a970bf6df75a057254fb04d4e53bd0c1a094a86962f5903000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:02] RPC request [] submitted to btcworld
[17:46:05] mtred:	1261504	  205.1gh/s 
[17:46:05] RPC request [] submitted to btcworld
[17:46:05] RPC request [] submitted to btcworld
[17:46:05] RPC request [] submitted to btcworld
[17:46:05] RPC request [] submitted to btcworld
[17:46:09] RPC request [] submitted to btcworld
[17:46:09] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000a24a961c91cadd1be157e8203a237518e7318b16793829b9c5e80fc39aec289a4e53bd101a094a86c2be7d17000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:09] RPC request [] submitted to btcworld
[17:46:10] RPC request [] submitted to btcworld
[17:46:10] RPC request [] submitted to btcworld
[17:46:10] RPC request [] submitted to btcworld
[17:46:13] RPC request [] submitted to btcworld
[17:46:14] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000000b5753c78b1fc2853d55e203a13aad76d7ffbc743d1799845ff557166c03ff784e53bd151a094a867cb5cd13000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:14] RPC request [] submitted to btcworld
[17:46:14] RPC request [] submitted to btcworld
[17:46:14] RPC request [] submitted to btcworld
[17:46:14] RPC request [] submitted to btcworld
[17:46:17] writing to database
[17:46:18] RPC request [] submitted to btcworld
[17:46:18] RPC request [] submitted to btcworld
[17:46:18] RPC request [] submitted to btcworld
[17:46:18] RPC request [] submitted to btcworld
[17:46:22] RPC request [] submitted to btcworld
[17:46:22] RPC request [] submitted to btcworld
[17:46:22] RPC request [] submitted to btcworld
[17:46:22] RPC request [] submitted to btcworld
[17:46:26] RPC request [] submitted to btcworld
[17:46:26] RPC request [] submitted to btcworld
[17:46:26] RPC request [] submitted to btcworld
[17:46:27] RPC request [] submitted to btcworld
[17:46:30] RPC request [] submitted to btcworld
[17:46:30] RPC request [] submitted to btcworld
[17:46:31] RPC request [] submitted to btcworld
[17:46:31] RPC request [] submitted to btcworld
[17:46:33] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000b1d9548ef587d7037e4be3f3f9435ebdc3ad295469ec731710f2e438fb0d2a594e53bd2a1a094a8610579309000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:33] RPC request [] submitted to btcworld
[17:46:34] RPC request [] submitted to btcworld
[17:46:35] RPC request [] submitted to btcworld
[17:46:35] RPC request [] submitted to btcworld
[17:46:35] RPC request [] submitted to btcworld
[17:46:39] RPC request [] submitted to btcworld
[17:46:39] RPC request [] submitted to btcworld
[17:46:39] RPC request [] submitted to btcworld
[17:46:39] RPC request [] submitted to btcworld
[17:46:43] RPC request [] submitted to btcworld
[17:46:43] RPC request [] submitted to btcworld
[17:46:43] RPC request [] submitted to btcworld
[17:46:43] RPC request [] submitted to btcworld
[17:46:46] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000004308a6e92d9d45ad311ae409c2df6bb36b9f33b3d9a82739e8f4307383b8e9834e53bd361a094a86fde2820d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:46] RPC request [] submitted to btcworld
[17:46:47] RPC request [] submitted to btcworld
[17:46:47] RPC request [] submitted to btcworld
[17:46:47] RPC request [] submitted to btcworld
[17:46:47] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000eeb3533cbb37a8d82aa7f842ec1bdf2a09157aaf27c81a802273a09cd95f390c4e53bd371a094a862ed6b013000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:48] RPC request [] submitted to btcworld
[17:46:48] RPC request [] submitted to btcworld
[17:46:48] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000b409dd6c7c512ca3b9bf5bb61f305dbbd79d5d56fff9711dcc6ed6b47ada7db54e53bd3b1a094a86008bba00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:48] RPC request [] submitted to btcworld
[17:46:50] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000664104b0105de27ad3cdf02b0b8be7ba094a7f4fbce6dd9021b1269968fb90094e53bd3b1a094a8694394f0d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:50] RPC request [] submitted to btcworld
[17:46:51] RPC request [] submitted to btcworld
[17:46:51] RPC request [] submitted to btcworld
[17:46:52] RPC request [] submitted to btcworld
[17:46:52] RPC request [] submitted to btcworld
[17:46:55] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000edff7a787cc4c40099b87d08c88fd81aa240b2c40353c6a2d1f4adcbaf3db95a4e53bd3f1a094a8680d88610000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:46:55] RPC request [] submitted to btcworld
[17:46:55] RPC request [] submitted to btcworld
[17:46:56] RPC request [] submitted to btcworld
[17:46:56] RPC request [] submitted to btcworld
[17:46:56] RPC request [] submitted to btcworld
[17:46:59] RPC request [] submitted to btcworld
[17:47:00] RPC request [] submitted to btcworld
[17:47:00] RPC request [] submitted to btcworld
[17:47:00] RPC request [] submitted to btcworld
[17:47:04] RPC request [] submitted to btcworld
[17:47:04] RPC request [] submitted to btcworld
[17:47:04] RPC request [] submitted to btcworld
[17:47:05] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000191789351ac2e627b85a16aa9516cdb9c75798e148d7153b2344289375381f2d4e53bd4b1a094a8690073403000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:47:05] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000c931431444b6ee148759fa0b4bd57b18cbe88b7e8ac1feb59d7d6bf2f88323de4e53bd4b1a094a8681a1fd00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:47:05] RPC request [] submitted to btcworld
[17:47:05] RPC request [] submitted to btcworld
[17:47:05] RPC request [] submitted to btcworld
[17:47:08] RPC request [] submitted to btcworld
[17:47:08] RPC request [] submitted to btcworld
[17:47:08] RPC request [] submitted to btcworld
[17:47:09] RPC request [] submitted to btcworld
[17:47:09] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000edff7a787cc4c40099b87d08c88fd81aa240b2c40353c6a2d1f4adcbaf3db95a4e53bd4f1a094a86c408a006000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:47:09] RPC request [] submitted to btcworld
[17:47:12] RPC request [] submitted to btcworld
[17:47:12] RPC request [] submitted to btcworld
[17:47:12] RPC request [] submitted to btcworld
[17:47:13] RPC request [] submitted to btcworld
[17:47:16] RPC request [] submitted to btcworld
[17:47:17] RPC request [] submitted to btcworld
[17:47:17] RPC request [] submitted to btcworld
[17:47:17] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000050f843b8b703cf462771856f885e641de3485f62b11e9916129bf689d13ff4f84e53bd541a094a864e12ea16000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:47:17] writing to database
[17:47:17] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000044ccc4057a294d6d83ce1078a36eaeed0a4ff2781176e2d5c51a68f70d669c504e53bd551a094a8680468e11000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:47:17] RPC request [] submitted to btcworld
[17:47:17] RPC request [] submitted to btcworld
[17:47:18] RPC request [] submitted to btcworld
[17:47:18] swepool:	4656842	  3.5gh/s 	34095min.
[17:47:19] triple:	7573422	  
[17:47:20] RPC request [] submitted to btcworld
[17:47:21] RPC request [] submitted to btcworld
[17:47:21] RPC request [] submitted to btcworld
[17:47:22] RPC request [] submitted to btcworld
[17:47:23] digbtc:	1803141	  
[17:47:24] RPC request [] submitted to btcworld
[17:47:26] RPC request [] submitted to btcworld
[17:47:26] RPC request [] submitted to btcworld
[17:47:26] RPC request [] submitted to btcworld
[17:47:26] btcserv:	1474618	  
[17:47:28] deepbit:	967189	  5775.0gh/s 
[17:47:29] RPC request [] submitted to btcworld
[17:47:30] RPC request [] submitted to btcworld
[17:47:30] RPC request [] submitted to btcworld
[17:47:30] RPC request [] submitted to btcworld
[17:47:32] bithasher:	2384886	  
[17:47:33] RPC request [] submitted to btcworld
[17:47:34] RPC request [] submitted to btcworld
[17:47:34] RPC request [] submitted to btcworld
[17:47:35] RPC request [] submitted to btcworld
[17:47:37] RPC request [] submitted to btcworld
[17:47:38] RPC request [] submitted to btcworld
[17:47:38] RPC request [] submitted to btcworld
[17:47:39] RPC request [] submitted to btcworld
[17:47:41] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000fd2f509d4afcc59e1afeadd29c76e4c7ad9140cb5db3c7c2e670f8ab0f8a5b774e53bd6c1a094a86e222a614000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:47:41] RPC request [] submitted to btcworld
[17:47:41] RPC request [] submitted to btcworld
[17:47:42] RPC request [] submitted to btcworld
[17:47:42] RPC request [] submitted to btcworld
[17:47:43] RPC request [] submitted to btcworld
[17:47:44] slush:	1636096	  1860.9gh/s 	62min.
[17:47:45] RPC request [] submitted to btcworld
[17:47:46] RPC request [] submitted to btcworld
[17:47:46] RPC request [] submitted to btcworld
[17:47:47] btcmonkey:	4310703	  1.6gh/s 
[17:47:47] RPC request [] submitted to btcworld
[17:47:48] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000ff5914eebc2403806acf0cb45236008524f0f1825de68f9812de5c10b93998534e53bd761a094a869ec42503000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:47:48] RPC request [] submitted to btcworld
[17:47:50] RPC request [] submitted to btcworld
[17:47:51] RPC request [] submitted to btcworld
[17:47:51] RPC request [] submitted to btcworld
[17:47:51] RPC request [] submitted to btcworld
[17:47:54] RPC request [] submitted to btcworld
[17:47:55] RPC request [] submitted to btcworld
[17:47:55] RPC request [] submitted to btcworld
[17:47:56] RPC request [] submitted to btcworld
[17:47:58] ozco:	1896599	  63.2gh/s 	1252min.
[17:47:58] RPC request [] submitted to btcworld
[17:47:59] RPC request [] submitted to btcworld
[17:47:59] RPC request [] submitted to btcworld
[17:48:00] RPC request [] submitted to btcworld
[17:48:02] RPC request [] submitted to btcworld
[17:48:03] RPC request [] submitted to btcworld
[17:48:03] RPC request [] submitted to btcworld
[17:48:04] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000ec9af0882c7e029b1f9f24a86228fc657a6bb92af948baf8b97088687fd354e54e53bd821a094a86971a7516000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:48:04] RPC request [] submitted to btcworld
[17:48:04] RPC request [] submitted to btcworld
[17:48:06] RPC request [] submitted to btcworld
[17:48:07] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000a6eaf121bd8fb35c2fd385f7220187b08614d1b14b5e046e6f5a1e91211d4d404e53bd871a094a86d939a90d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:48:07] bloodys:	2152052	  
[17:48:07] RPC request [] submitted to btcworld
[17:48:08] RPC request [] submitted to btcworld
[17:48:08] RPC request [] submitted to btcworld
[17:48:08] RPC request [] submitted to btcworld
[17:48:11] RPC request [] submitted to btcworld
[17:48:12] RPC request [] submitted to btcworld
[17:48:12] RPC request [] submitted to btcworld
[17:48:12] RPC request [] submitted to btcworld
[17:48:13] bitclockers:	1148619	  233.4gh/s 
[17:48:15] RPC request [] submitted to btcworld
[17:48:16] RPC request [] submitted to btcworld
[17:48:16] RPC request [] submitted to btcworld
[17:48:17] RPC request [] submitted to btcworld
[17:48:17] writing to database
[17:48:19] RPC request [] submitted to btcworld
[17:48:20] RPC request [] submitted to btcworld
[17:48:20] RPC request [] submitted to btcworld
[17:48:21] RPC request [] submitted to btcworld
[17:48:23] RPC request [] submitted to btcworld
[17:48:24] RPC request [] submitted to btcworld
[17:48:24] RPC request [] submitted to btcworld
[17:48:25] RPC request [] submitted to btcworld
[17:48:27] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000008205afba4310c60fd459f275ea9d8326aa9515af5b4787daf50d9330144e86484e53bd9a1a094a864b58a315000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:48:27] RPC request [] submitted to btcworld
[17:48:28] RPC request [] submitted to btcworld
[17:48:29] RPC request [] submitted to btcworld
[17:48:29] RPC request [] submitted to btcworld
[17:48:29] RPC request [] submitted to btcworld
[17:48:32] RPC request [] submitted to btcworld
[17:48:33] RPC request [] submitted to btcworld
[17:48:33] RPC request [] submitted to btcworld
[17:48:33] RPC request [] submitted to btcworld
[17:48:36] RPC request [] submitted to btcworld
[17:48:37] RPC request [] submitted to btcworld
[17:48:37] RPC request [] submitted to btcworld
[17:48:38] RPC request [] submitted to btcworld
[17:48:39] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000f2b0226c35f20e72b0cceaba7e8ffa17e5bc9406a545da3d9b3c788db473db5f4e53bda71a094a86c2af630f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:48:39] RPC request [] submitted to btcworld
[17:48:40] RPC request [] submitted to btcworld
[17:48:41] RPC request [] submitted to btcworld
[17:48:41] RPC request [] submitted to btcworld
[17:48:42] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000e7294d178d1829c0d2c0b67d616e4b25a2d4c6aa84d6127b7092f64f07ee85974e53bda91a094a86ece00514000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:48:42] RPC request [] submitted to btcworld
[17:48:42] RPC request [] submitted to btcworld
[17:48:43] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000c7e8080315ebe50bad6c5b9a70090df4e3993fc51d5c05da89537c7747e530334e53bdab1a094a86e0c7ee0f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:48:43] RPC request [] submitted to btcworld
[17:48:44] RPC request [] submitted to btcworld
[17:48:45] RPC request [] submitted to btcworld
[17:48:46] RPC request [] submitted to btcworld
[17:48:46] RPC request [] submitted to btcworld
[17:48:49] RPC request [] submitted to btcworld
[17:48:50] RPC request [] submitted to btcworld
[17:48:50] RPC request [] submitted to btcworld
[17:48:50] RPC request [] submitted to btcworld
[17:48:53] RPC request [] submitted to btcworld
[17:48:54] RPC request [] submitted to btcworld
[17:48:54] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f0000059100000000cbdb0f52d7a7b3288e63920fe169c7aa84e04993d4d6f03496fa70b05802763e4e53bdb51a094a8693735f16000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:48:54] RPC request [] submitted to btcworld
[17:48:54] RPC request [] submitted to btcworld
[17:48:55] RPC request [] submitted to btcworld
[17:48:57] RPC request [] submitted to btcworld
[17:48:58] RPC request [] submitted to btcworld
[17:48:58] RPC request [] submitted to btcworld
[17:48:59] RPC request [] submitted to btcworld
[17:49:00] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000069e305df5e7e06da4e0e7766f6448cd74819fa05b3322e91d86743476e22fb0b4e53bdbd1a094a864a4ce405000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:00] RPC request [] submitted to btcworld
[17:49:01] RPC request [] submitted to btcworld
[17:49:02] RPC request [] submitted to btcworld
[17:49:03] RPC request [] submitted to btcworld
[17:49:03] RPC request [] submitted to btcworld
[17:49:05] RPC request [] submitted to btcworld
[17:49:06] RPC request [] submitted to btcworld
[17:49:07] RPC request [] submitted to btcworld
[17:49:07] RPC request [] submitted to btcworld
[17:49:09] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000008d7694675ef7ea21f3735d568be8b200e27f8bbbeed89ad6c6e943e07d62d4d64e53bdc51a094a861683dd10000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:09] RPC request [] submitted to btcworld
[17:49:10] RPC request [] submitted to btcworld
[17:49:11] RPC request [] submitted to btcworld
[17:49:11] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000002eab0588ad770b483726d578b3d3ad8bf162b9d46f765c83470d10ccb75397294e53bdc91a094a86f06f1106000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:11] RPC request [] submitted to btcworld
[17:49:11] RPC request [] submitted to btcworld
[17:49:11] RPC request [] submitted to btcworld
[17:49:14] RPC request [] submitted to btcworld
[17:49:15] RPC request [] submitted to btcworld
[17:49:15] RPC request [] submitted to btcworld
[17:49:16] RPC request [] submitted to btcworld
[17:49:17] writing to database
[17:49:18] RPC request [] submitted to btcworld
[17:49:19] swepool:	4656928	  3.5gh/s 	34097min.
[17:49:19] RPC request [] submitted to btcworld
[17:49:19] triple:	7574071	  
[17:49:19] RPC request [] submitted to btcworld
[17:49:20] RPC request [] submitted to btcworld
[17:49:22] RPC request [] submitted to btcworld
[17:49:24] digbtc:	1803317	  
[17:49:24] RPC request [] submitted to btcworld
[17:49:24] RPC request [] submitted to btcworld
[17:49:24] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000001c42d6565d296a8e5d7a5785117bb28f8e19f803694416f49e6310e4a56273584e53bdd51a094a86bda17307000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:24] RPC request [] submitted to btcworld
[17:49:24] RPC request [] submitted to btcworld
[17:49:26] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000008139741b4ac7227a76be4b3cad825b809a2dd0360c41d24b275cb631ce0875b4e53bdd71a094a8664d3dc09000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:26] RPC request [] submitted to btcworld
[17:49:26] RPC request [] submitted to btcworld
[17:49:27] btcserv:	1474695	  
[17:49:28] RPC request [] submitted to btcworld
[17:49:28] RPC request [] submitted to btcworld
[17:49:28] RPC request [] submitted to btcworld
[17:49:29] deepbit:	1129159	  5779.0gh/s 
[17:49:31] RPC request [] submitted to btcworld
[17:49:32] RPC request [] submitted to btcworld
[17:49:32] RPC request [] submitted to btcworld
[17:49:33] RPC request [] submitted to btcworld
[17:49:33] arsbitcoin:	1639245	  
[17:49:33] bithasher:	2385103	  
[17:49:35] RPC request [] submitted to btcworld
[17:49:36] RPC request [] submitted to btcworld
[17:49:37] RPC request [] submitted to btcworld
[17:49:37] RPC request [] submitted to btcworld
[17:49:38] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000000db04f444f2073f302b6c93fc039fda1c361a2e9d2d848d1435aa6cefb24ba5a4e53bde41a094a86aa817d03000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:38] RPC request [] submitted to btcworld
[17:49:39] RPC request [] submitted to btcworld
[17:49:41] RPC request [] submitted to btcworld
[17:49:41] RPC request [] submitted to btcworld
[17:49:41] RPC request [] submitted to btcworld
[17:49:43] RPC request [] submitted to btcworld
[17:49:45] slush:	1677597	  1861.9gh/s 	64min.
[17:49:45] RPC request [] submitted to btcworld
[17:49:45] RPC request [] submitted to btcworld
[17:49:45] RPC request [] submitted to btcworld
[17:49:45] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f000005910000000039be4338add5a77193baeb515766f2fea4382f3255e4f06898e35e8de84c6d1d4e53bde81a094a86db480f17000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:45] RPC request [] submitted to btcworld
[17:49:45] RPC request [u'00000001b2d88c2f2a7e748da182c348f13ec4ca1a696b48a27b508f00000591000000007a9f9e6c652a6e83189f5deea8aaeb591cc6d730b61eee749d73c9bd1aa7fcec4e53bdea1a094a86e2ee490c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:49:46] RPC request [] submitted to btcworld
[17:49:47] RPC request [] submitted to btcworld
[17:49:48] btcmonkey:	4310754	  1.6gh/s 
[17:49:49] RPC request [] submitted to btcworld
[17:49:49] RPC request [] submitted to btcworld
[17:49:49] RPC request [] submitted to btcworld
[17:49:51] RPC request [] submitted to btcworld
[17:49:53] RPC request [] submitted to btcworld
[17:49:53] RPC request [] submitted to btcworld
[17:49:54] RPC request [] submitted to btcworld
[17:49:56] RPC request [] submitted to btcworld
[17:49:58] RPC request [] submitted to btcworld
[17:49:58] RPC request [] submitted to btcworld
[17:49:58] RPC request [] submitted to btcworld
[17:50:00] RPC request [] submitted to btcworld
[17:50:02] RPC request [] submitted to btcworld
[17:50:02] RPC request [] submitted to btcworld
[17:50:02] RPC request [] submitted to btcworld
[17:50:04] RPC request [] submitted to btcworld
[17:50:06] RPC request [] submitted to btcworld
[17:50:06] RPC request [] submitted to btcworld
[17:50:06] RPC request [] submitted to btcworld
[17:50:08] RPC request [] submitted to btcworld
[17:50:10] RPC request [] submitted to btcworld
[17:50:10] RPC request [] submitted to btcworld
[17:50:10] RPC request [] submitted to btcworld
[17:50:12] RPC request [] submitted to btcworld
[17:50:13] New Block: c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce00000000
[17:50:13] Block Owner digbtc
[17:50:13] Setting Block Owner digbtc:c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce00000000
[17:50:13] LP Call http://digbtc.net:8332/LP
[17:50:14] LP Call http://pool.bitclockers.com:8332/LP
[17:50:14] RPC request [] submitted to btcworld
[17:50:14] RPC request [] submitted to btcworld
[17:50:15] RPC request [] submitted to btcworld
[17:50:15] LP Call http://pit.deepbit.net:8332/listenChannel
[17:50:15] LP Call http://swepool.net:8337/LP
[17:50:16] LP Call http://arsbitcoin.com:8344/LP
[17:50:17] RPC request [] submitted to btcworld
[17:50:17] writing to database
[17:50:18] LP Call http://mtred.com:8837/LP
[17:50:19] LP Call http://btcworld.de:8332/LP
[17:50:19] RPC request [] submitted to btcworld
[17:50:19] RPC request [] submitted to btcworld
[17:50:19] RPC request [] submitted to btcworld
[17:50:20] LP Call http://pool.bloodys.com:8332/LP
[17:50:21] RPC request [] submitted to btcworld
[17:50:23] RPC request [] submitted to btcworld
[17:50:23] RPC request [] submitted to btcworld
[17:50:23] RPC request [] submitted to btcworld
[17:50:24] LP Call http://btcserv.net:8335/LP
[17:50:25] RPC request [] submitted to btcworld
[17:50:27] RPC request [] submitted to btcworld
[17:50:27] RPC request [] submitted to btcworld
[17:50:27] RPC request [] submitted to btcworld
[17:50:30] RPC request [] submitted to btcworld
[17:50:31] RPC request [] submitted to btcworld
[17:50:31] RPC request [] submitted to btcworld
[17:50:32] RPC request [] submitted to btcworld
[17:50:34] RPC request [] submitted to btcworld
[17:50:35] RPC request [] submitted to btcworld
[17:50:36] RPC request [] submitted to btcworld
[17:50:36] RPC request [] submitted to btcworld
[17:50:38] RPC request [] submitted to btcworld
[17:50:40] RPC request [] submitted to btcworld
[17:50:40] RPC request [] submitted to btcworld
[17:50:40] RPC request [] submitted to btcworld
[17:50:42] RPC request [] submitted to btcworld
[17:50:44] RPC request [] submitted to btcworld
[17:50:44] RPC request [] submitted to btcworld
[17:50:45] RPC request [] submitted to btcworld
[17:50:47] RPC request [] submitted to btcworld
[17:50:48] RPC request [] submitted to btcworld
[17:50:49] RPC request [] submitted to btcworld
[17:50:49] RPC request [] submitted to btcworld
[17:50:51] RPC request [] submitted to btcworld
[17:50:51] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce00000000a753179ba2667d8e131de2807e7aaa7d0abe9e2e343ae2e63d60601521eba1544e53be2c1a094a8638c0eb0b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:50:51] RPC request [] submitted to btcworld
[17:50:53] RPC request [] submitted to btcworld
[17:50:53] RPC request [] submitted to btcworld
[17:50:53] RPC request [] submitted to btcworld
[17:50:55] RPC request [] submitted to btcworld
[17:50:57] RPC request [] submitted to btcworld
[17:50:57] RPC request [] submitted to btcworld
[17:50:57] RPC request [] submitted to btcworld
[17:50:59] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce000000009d7b576756b5af14e0c4f301d6562a033453bed1ff7562325e8961751275d3804e53be341a094a86fd96d308000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:50:59] RPC request [] submitted to btcworld
[17:50:59] RPC request [] submitted to btcworld
[17:51:01] RPC request [] submitted to btcworld
[17:51:01] RPC request [] submitted to btcworld
[17:51:01] RPC request [] submitted to btcworld
[17:51:03] RPC request [] submitted to btcworld
[17:51:05] RPC request [] submitted to btcworld
[17:51:05] RPC request [] submitted to btcworld
[17:51:05] RPC request [] submitted to btcworld
[17:51:07] RPC request [] submitted to btcworld
[17:51:09] RPC request [] submitted to btcworld
[17:51:09] RPC request [] submitted to btcworld
[17:51:10] RPC request [] submitted to btcworld
[17:51:12] RPC request [] submitted to btcworld
[17:51:13] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce00000000940ead69752e3633d6f8a8da75e9801765624a2cbd649c9390f7f8fb95fd624d4e53be411a094a865f13ad11000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:51:13] RPC request [] submitted to btcworld
[17:51:13] RPC request [] submitted to btcworld
[17:51:14] RPC request [] submitted to btcworld
[17:51:14] RPC request [] submitted to btcworld
[17:51:16] RPC request [] submitted to btcworld
[17:51:17] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce00000000f16b235ee07516cbb02407af4c17fa8236e86e094f79210c5b77193614c157dd4e53be451a094a86f3e1ab0f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:51:17] RPC request [] submitted to btcworld
[17:51:17] writing to database
[17:51:18] RPC request [] submitted to btcworld
[17:51:18] RPC request [] submitted to btcworld
[17:51:18] RPC request [] submitted to btcworld
[17:51:19] swepool:	4657029	  3.5gh/s 	34099min.
[17:51:20] triple:	7574579	  
[17:51:20] RPC request [] submitted to btcworld
[17:51:21] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce0000000067f8a42d478125a24d5c02ef998cd207bd7b434f9d07a8adc49bdf749e09c87b4e53be491a094a8608f39b0f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:51:21] RPC request [] submitted to btcworld
[17:51:22] RPC request [] submitted to btcworld
[17:51:22] RPC request [] submitted to btcworld
[17:51:22] RPC request [] submitted to btcworld
[17:51:24] digbtc:	1803489	  
[17:51:24] RPC request [] submitted to btcworld
[17:51:26] RPC request [] submitted to btcworld
[17:51:26] RPC request [] submitted to btcworld
[17:51:26] RPC request [] submitted to btcworld
[17:51:27] btcserv:	1474759	  
[17:51:28] RPC request [] submitted to btcworld
[17:51:29] deepbit:	1291559	  5781.0gh/s 
[17:51:30] RPC request [] submitted to btcworld
[17:51:31] RPC request [] submitted to btcworld
[17:51:31] RPC request [] submitted to btcworld
[17:51:32] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce000000006333acff9fa031ee45ce0c107f8d200bee5bb179bd9e81d8fe9ceda41a52274e4e53be561a094a8656b0a205000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:51:32] RPC request [] submitted to btcworld
[17:51:33] RPC request [] submitted to btcworld
[17:51:35] RPC request [] submitted to btcworld
[17:51:35] bithasher:	2385285	  
[17:51:35] RPC request [] submitted to btcworld
[17:51:35] RPC request [] submitted to btcworld
[17:51:37] RPC request [] submitted to btcworld
[17:51:38] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce000000000bd7df8be60f0f077c419b5c2060a44d7f69b70778ba920657b551d10a36dc1d4e53be5a1a094a86e30ecc12000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:51:39] RPC request [] submitted to btcworld
[17:51:39] RPC request [] submitted to btcworld
[17:51:39] RPC request [] submitted to btcworld
[17:51:39] RPC request [] submitted to btcworld
[17:51:39] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce0000000017a21ac905d921d139d059c6a69cf8fcdde4171c9c8e150f3fe3306a757e18164e53be5a1a094a86dfd9d715000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:51:39] RPC request [] submitted to btcworld
[17:51:41] RPC request [] submitted to btcworld
[17:51:43] RPC request [] submitted to btcworld
[17:51:43] RPC request [] submitted to btcworld
[17:51:43] RPC request [] submitted to btcworld
[17:51:45] slush:	1732899	  1851.7gh/s 	66min.
[17:51:45] RPC request [] submitted to btcworld
[17:51:47] RPC request [] submitted to btcworld
[17:51:47] RPC request [] submitted to btcworld
[17:51:48] RPC request [] submitted to btcworld
[17:51:49] RPC request [] submitted to btcworld
[17:51:50] btcmonkey:	4310814	  1.7gh/s 
[17:51:50] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce00000000e4a4e7947504f17cc6f6b8c9334195c093362abafd806fc32512c4f8e71eb6ff4e53be671a094a86706ebc0f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:51:51] RPC request [] submitted to btcworld
[17:51:51] RPC request [] submitted to btcworld
[17:51:52] RPC request [] submitted to btcworld
[17:51:52] RPC request [] submitted to btcworld
[17:51:54] RPC request [] submitted to btcworld
[17:51:56] RPC request [] submitted to btcworld
[17:51:56] RPC request [] submitted to btcworld
[17:51:56] RPC request [] submitted to btcworld
[17:51:58] RPC request [] submitted to btcworld
[17:52:00] RPC request [] submitted to btcworld
[17:52:00] RPC request [] submitted to btcworld
[17:52:01] RPC request [] submitted to btcworld
[17:52:02] RPC request [] submitted to btcworld
[17:52:04] RPC request [] submitted to btcworld
[17:52:04] RPC request [] submitted to btcworld
[17:52:05] RPC request [] submitted to btcworld
[17:52:05] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce000000008013aa0f53b60491e219962552d3ab80509f9eddc51921bf86b6d653f225d0174e53be771a094a868808b704000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:52:05] RPC request [] submitted to btcworld
[17:52:06] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce00000000644ea657ccdf91ab0b95676550a17c0121bb6373468509c62e7701def4ef8ad64e53be771a094a8634191e07000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:52:06] RPC request [] submitted to btcworld
[17:52:06] RPC request [] submitted to btcworld
[17:52:08] RPC request [] submitted to btcworld
[17:52:08] RPC request [] submitted to btcworld
[17:52:09] RPC request [] submitted to btcworld
[17:52:11] RPC request [] submitted to btcworld
[17:52:12] RPC request [] submitted to btcworld
[17:52:13] RPC request [] submitted to btcworld
[17:52:13] RPC request [] submitted to btcworld
[17:52:14] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce0000000037864758fdc6f2bca8713e4a996e5155280be369cae0e40cbb9827ad72e6b12e4e53be7e1a094a862d727813000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:52:14] RPC request [] submitted to btcworld
[17:52:15] RPC request [] submitted to btcworld
[17:52:17] RPC request [] submitted to btcworld
[17:52:17] RPC request [] submitted to btcworld
[17:52:17] writing to database
[17:52:18] RPC request [] submitted to btcworld
[17:52:19] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce000000002f302fc5309d1b127fa3ac9dcef6b2802a91a401c6f6ca88377f6d78211bc3d74e53be851a094a866ce4e103000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:52:19] RPC request [] submitted to btcworld
[17:52:19] RPC request [u'00000001c365afb34c0c985c435bf094172b8d6e044cb350d27c73cf000000ce000000005f2c92c2f2d2f2db8c8651036fcfadd771db6ccdc1c0b7005c226b6c453bd9ed4e53be841a094a8674e1dc0a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to btcworld
[17:52:19] RPC request [] submitted to btcworld
[17:52:19] RPC request [] submitted to btcworld
[17:52:21] RPC request [] submitted to btcworld
[17:52:21] RPC request [] submitted to btcworld
[17:52:21] mtred:	1274810	  190.5gh/s 
[17:52:22] RPC request [] submitted to btcworld
[17:52:23] RPC request [] submitted to btcworld
[17:52:25] RPC request [] submitted to btcworld
[17:52:25] RPC request [] submitted to btcworld
[17:52:26] RPC request [] submitted to btcworld
[17:52:27] RPC request [] submitted to btcworld
[17:52:29] RPC request [] submitted to btcworld
[17:52:29] RPC request [] submitted to btcworld
[17:52:30] RPC request [] submitted to btcworld
[17:52:32] RPC request [] submitted to btcworld
[17:52:33] RPC request [] submitted to btcworld
[17:52:34] RPC request [] submitted to btcworld
[17:52:34] bloodys:	2152181	  
[17:52:34] RPC request [] submitted to btcworld
[17:52:36] RPC request [] submitted to btcworld
[17:52:36] New Block: 3979124d91a7e1220a9ce9c68c800a33f261c534488a58d10000048000000000
[17:52:36] Block Owner deepbit
[17:52:36] Setting Block Owner deepbit:3979124d91a7e1220a9ce9c68c800a33f261c534488a58d10000048000000000
[17:52:36] Server change to deepbit
[17:52:36] LP Call http://pit.deepbit.net:8332/listenChannel
[17:52:38] RPC request [] submitted to deepbit
[17:52:38] RPC request [] submitted to deepbit
[17:52:39] LP Call http://swepool.net:8337/LP
[17:52:39] LP Call http://btcworld.de:8332/LP
[17:52:40] LP Call http://digbtc.net:8332/LP
[17:52:40] bitclockers:	1159415	  234.6gh/s 
[17:52:40] LP Call http://arsbitcoin.com:8344/LP
[17:52:40] LP Call http://pool.bitclockers.com:8332/LP
[17:52:40] RPC request [] submitted to deepbit
[17:52:40] LP Call http://mtred.com:8837/LP
[17:52:41] LP Call http://pool.bloodys.com:8332/LP
[17:52:42] RPC request [u'000000013979124d91a7e1220a9ce9c68c800a33f261c534488a58d100000480000000008ff1e05b6a06e76078b50cbd61f5e900c40edd743bc7a26362ca35b2144c3de24e53be821a094a86a1a87914000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:52:42] RPC request [] submitted to deepbit
[17:52:42] RPC request [] submitted to deepbit
[17:52:42] RPC request [] submitted to deepbit
[17:52:43] RPC request [u'000000013979124d91a7e1220a9ce9c68c800a33f261c534488a58d10000048000000000719da33ded83678f40d8688a0f18ce9afb239d7d1ffeb8b094f0f67737697b6a4e53be841a094a86f930da0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:52:43] RPC request [] submitted to deepbit
[17:52:43] LP Call http://btcserv.net:8335/LP
[17:52:44] RPC request [] submitted to deepbit
[17:52:46] RPC request [] submitted to deepbit
[17:52:47] RPC request [] submitted to deepbit
[17:52:48] RPC request [] submitted to deepbit
[17:52:50] RPC request [u'000000013979124d91a7e1220a9ce9c68c800a33f261c534488a58d10000048000000000e6101a1a2e23094ef8c399f14c540c3afb34ac1981cf2fb266f39203802612d34e53be881a094a868e57b406000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:52:50] RPC request [] submitted to deepbit
[17:52:51] RPC request [] submitted to deepbit
[17:52:51] RPC request [] submitted to deepbit
[17:52:53] RPC request [] submitted to deepbit
[17:52:55] RPC request [] submitted to deepbit
[17:52:55] RPC request [] submitted to deepbit
[17:52:57] RPC request [] submitted to deepbit
[17:52:59] RPC request [] submitted to deepbit
[17:52:59] RPC request [] submitted to deepbit
[17:53:01] RPC request [] submitted to deepbit
[17:53:03] RPC request [] submitted to deepbit
[17:53:03] RPC request [] submitted to deepbit
[17:53:05] RPC request [] submitted to deepbit
[17:53:07] RPC request [] submitted to deepbit
[17:53:07] RPC request [] submitted to deepbit
[17:53:10] RPC request [] submitted to deepbit
[17:53:12] New Block: 46580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000
[17:53:12] Block Owner btcserv
[17:53:12] Setting Block Owner btcserv:46580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000
[17:53:12] LP Call http://btcserv.net:8335/LP
[17:53:12] LP Call http://pool.bitclockers.com:8332/LP
[17:53:12] LP Call http://swepool.net:8337/LP
[17:53:12] LP Call http://btcworld.de:8332/LP
[17:53:12] RPC request [] submitted to deepbit
[17:53:12] LP Call http://digbtc.net:8332/LP
[17:53:12] RPC request [] submitted to deepbit
[17:53:13] LP Call http://pit.deepbit.net:8332/listenChannel
[17:53:13] LP Call http://pool.bloodys.com:8332/LP
[17:53:13] LP Call http://mtred.com:8837/LP
[17:53:13] LP Call http://arsbitcoin.com:8344/LP
[17:53:14] RPC request [] submitted to deepbit
[17:53:16] RPC request ZWthcGhvZW5peDI6YXNkcnR5cXdlMTIz submitted to deepbit
[17:53:16] RPC request [] submitted to deepbit
[17:53:17] RPC request [] submitted to deepbit
[17:53:17] RPC request [] submitted to deepbit
[17:53:17] writing to database
[17:53:18] RPC request [] submitted to deepbit
[17:53:19] swepool:	4657110	  3.5gh/s 	34101min.
[17:53:19] btcworld:	541126	  
[17:53:20] triple:	7575213	  
[17:53:21] RPC request [] submitted to deepbit
[17:53:21] RPC request [] submitted to deepbit
[17:53:22] RPC request [] submitted to deepbit
[17:53:25] digbtc:	1803635	  
[17:53:25] RPC request [] submitted to deepbit
[17:53:25] RPC request [] submitted to deepbit
[17:53:26] RPC request [] submitted to deepbit
[17:53:27] btcserv:	1474831	  
[17:53:29] RPC request [] submitted to deepbit
[17:53:29] deepbit:	161345	  5761.0gh/s 
[17:53:29] RPC request [] submitted to deepbit
[17:53:30] RPC request [] submitted to deepbit
[17:53:33] RPC request [] submitted to deepbit
[17:53:34] RPC request [] submitted to deepbit
[17:53:35] RPC request [] submitted to deepbit
[17:53:35] bithasher:	2385490	  
[17:53:37] RPC request [] submitted to deepbit
[17:53:38] RPC request [] submitted to deepbit
[17:53:39] RPC request [] submitted to deepbit
[17:53:41] RPC request [] submitted to deepbit
[17:53:42] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000007fa6728b2ee30ca86de6c34c1558568d767dd486c0d199efbd74b2947aa8a4684e53beb71a094a86f7f1e617000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[17:53:42] RPC request [] submitted to deepbit
[17:53:42] RPC request [] submitted to deepbit
[17:53:43] RPC request [] submitted to deepbit
[17:53:45] slush:	7670	  1841.2gh/s 	66min.
[17:53:45] Setting Block Owner slush:46580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000
[17:53:45] Server change to slush
[17:53:46] RPC request [] submitted to slush
[17:53:46] RPC request [] submitted to slush
[17:53:47] RPC request [] submitted to slush
[17:53:47] arsbitcoin:	1674205	  
[17:53:50] RPC request [] submitted to slush
[17:53:51] btcmonkey:	4310875	  1.7gh/s 
[17:53:51] RPC request [] submitted to slush
[17:53:51] RPC request [] submitted to slush
[17:53:54] RPC request [] submitted to slush
[17:53:55] RPC request [] submitted to slush
[17:53:55] RPC request [] submitted to slush
[17:53:59] RPC request [] submitted to slush
[17:53:59] RPC request [] submitted to slush
[17:54:00] RPC request [] submitted to slush
[17:54:03] RPC request [] submitted to slush
[17:54:04] RPC request [] submitted to slush
[17:54:04] RPC request [] submitted to slush
[17:54:06] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000007f8f5867f571c85d7b9230dc3cf6c468346a8a46975af3da4a0e88e6af37d6864e53bedc1a094a86a1b9090d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:06] RPC request [] submitted to slush
[17:54:07] RPC request [] submitted to slush
[17:54:08] RPC request [] submitted to slush
[17:54:08] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000e4dbaf228a8e98116301f87486870909ea0f06daaba16362dba0d2d5560e56ae4e53bedd1a094a865bcc5116000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:08] RPC request [] submitted to slush
[17:54:08] RPC request [] submitted to slush
[17:54:11] RPC request [] submitted to slush
[17:54:12] RPC request [] submitted to slush
[17:54:12] RPC request [] submitted to slush
[17:54:13] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000cc5c1af9d45f9002a096eae7f6d390f0b484a8c9c521c3367687662542482b9e4e53bef91a094a86eb77e006000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:13] RPC request [] submitted to slush
[17:54:16] RPC request [] submitted to slush
[17:54:16] RPC request [] submitted to slush
[17:54:16] RPC request [] submitted to slush
[17:54:17] writing to database
[17:54:18] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b000007900000000024efc3afe591274ad6577b7162dee8b1886527d6b330c3b3bf62500a8d7842ad4e53befd1a094a8641d0740a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:18] RPC request [] submitted to slush
[17:54:20] RPC request [] submitted to slush
[17:54:20] RPC request [] submitted to slush
[17:54:20] RPC request [] submitted to slush
[17:54:22] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b000007900000000036def12c99a31cfcdb1f876cb9278eba7d646018bd62e4b985ee1fbe1e3dd4ab4e53bf021a094a866cc97109000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:23] RPC request [] submitted to slush
[17:54:24] RPC request [] submitted to slush
[17:54:24] RPC request [] submitted to slush
[17:54:25] RPC request [] submitted to slush
[17:54:28] RPC request [] submitted to slush
[17:54:29] RPC request [] submitted to slush
[17:54:29] RPC request [] submitted to slush
[17:54:32] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000e37fde769499293119e38d7d3aff37cb5704e6def32b618443189cf14166fd344e53bf0a1a094a8685c86910000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:32] RPC request [] submitted to slush
[17:54:32] RPC request [] submitted to slush
[17:54:33] RPC request [] submitted to slush
[17:54:33] RPC request [] submitted to slush
[17:54:36] RPC request [] submitted to slush
[17:54:37] RPC request [] submitted to slush
[17:54:37] RPC request [] submitted to slush
[17:54:41] RPC request [] submitted to slush
[17:54:41] RPC request [] submitted to slush
[17:54:41] RPC request [] submitted to slush
[17:54:45] RPC request [] submitted to slush
[17:54:45] RPC request [] submitted to slush
[17:54:45] RPC request [] submitted to slush
[17:54:49] RPC request [] submitted to slush
[17:54:49] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000c09dfecf43bb618783182ce10957270dc24cb180d16b9fd23bf9b3a8de0b150b4e53bf071a094a867a09a313000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:49] RPC request [] submitted to slush
[17:54:49] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000c09dfecf43bb618783182ce10957270dc24cb180d16b9fd23bf9b3a8de0b150b4e53bf071a094a866d024e14000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:54:49] RPC request [] submitted to slush
[17:54:50] RPC request [] submitted to slush
[17:54:50] RPC request [] submitted to slush
[17:54:53] RPC request [] submitted to slush
[17:54:54] RPC request [] submitted to slush
[17:54:54] RPC request [] submitted to slush
[17:54:57] RPC request [] submitted to slush
[17:54:58] RPC request [] submitted to slush
[17:54:58] RPC request [] submitted to slush
[17:55:00] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000919eb0d0d86032588e61c441bf3cfc54cd43a463aba2babdf967ad146e34b4e34e53bf271a094a861279380b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:55:00] RPC request [] submitted to slush
[17:55:01] RPC request [] submitted to slush
[17:55:02] RPC request [] submitted to slush
[17:55:02] RPC request [] submitted to slush
[17:55:06] RPC request [] submitted to slush
[17:55:06] RPC request [] submitted to slush
[17:55:06] RPC request [] submitted to slush
[17:55:10] RPC request [] submitted to slush
[17:55:10] RPC request [] submitted to slush
[17:55:11] RPC request [] submitted to slush
[17:55:14] RPC request [] submitted to slush
[17:55:15] RPC request [] submitted to slush
[17:55:15] RPC request [] submitted to slush
[17:55:17] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000008bd6b3bbd68377f9360f343f58ffe851904e97edf03f7db1b6795760055157514e53bf381a094a864410af0a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:55:17] RPC request [] submitted to slush
[17:55:18] writing to database
[17:55:18] RPC request [] submitted to slush
[17:55:19] RPC request [] submitted to slush
[17:55:19] swepool:	4657190	  3.5gh/s 	34103min.
[17:55:19] RPC request [] submitted to slush
[17:55:20] triple:	7576033	  
[17:55:22] RPC request [] submitted to slush
[17:55:23] RPC request [] submitted to slush
[17:55:23] RPC request [] submitted to slush
[17:55:25] digbtc:	1803759	  
[17:55:26] RPC request [] submitted to slush
[17:55:27] RPC request [] submitted to slush
[17:55:27] btcserv:	1474911	  
[17:55:28] RPC request [] submitted to slush
[17:55:30] deepbit:	322307	  5733.0gh/s 
[17:55:31] RPC request [] submitted to slush
[17:55:31] RPC request [] submitted to slush
[17:55:32] RPC request [] submitted to slush
[17:55:35] RPC request [] submitted to slush
[17:55:35] RPC request [] submitted to slush
[17:55:36] RPC request [] submitted to slush
[17:55:36] bithasher:	2385722	  
[17:55:39] RPC request [] submitted to slush
[17:55:40] RPC request [] submitted to slush
[17:55:40] RPC request [] submitted to slush
[17:55:43] RPC request [] submitted to slush
[17:55:44] RPC request [] submitted to slush
[17:55:44] RPC request [] submitted to slush
[17:55:45] slush:	63273	  1838.5gh/s 	2min.
[17:55:47] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000006f9620954d3519ead01436db2e352222e4840ba30f081e11326db1b1376416ca4e53bf551a094a86d76b2510000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:55:47] RPC request [] submitted to slush
[17:55:47] RPC request [] submitted to slush
[17:55:48] RPC request [] submitted to slush
[17:55:48] RPC request [] submitted to slush
[17:55:51] RPC request [] submitted to slush
[17:55:52] btcmonkey:	4310926	  1.8gh/s 
[17:55:52] RPC request [] submitted to slush
[17:55:53] RPC request [] submitted to slush
[17:55:56] RPC request [] submitted to slush
[17:55:56] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000dd67900edf22e011feac3daecf1f247a33e8acdfb6e1f484c913c143343ed5c64e53bf611a094a86a6125b00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:55:56] RPC request [] submitted to slush
[17:55:56] RPC request [] submitted to slush
[17:55:57] RPC request [] submitted to slush
[17:56:00] RPC request [] submitted to slush
[17:56:00] RPC request [] submitted to slush
[17:56:01] RPC request [] submitted to slush
[17:56:04] RPC request [] submitted to slush
[17:56:05] RPC request [] submitted to slush
[17:56:05] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000004391a12095a11b485ecf0be3d2367a73a2a41ff728399ea6a43508e4fb3de7734e53bf521a094a8631ba5616000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:56:05] RPC request [] submitted to slush
[17:56:05] RPC request [] submitted to slush
[17:56:07] ozco:	1904558	  63.4gh/s 	1260min.
[17:56:08] RPC request [] submitted to slush
[17:56:09] RPC request [] submitted to slush
[17:56:09] RPC request [] submitted to slush
[17:56:12] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b000007900000000048be2b505a693c5c95e517cc15aafbf8d840453ba7ed9eca216f9a39544d315f4e53bf5a1a094a861af1390f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:56:12] RPC request [] submitted to slush
[17:56:12] RPC request [] submitted to slush
[17:56:13] RPC request [] submitted to slush
[17:56:13] RPC request [] submitted to slush
[17:56:16] RPC request [] submitted to slush
[17:56:17] RPC request [] submitted to slush
[17:56:18] RPC request [] submitted to slush
[17:56:18] writing to database
[17:56:21] RPC request [] submitted to slush
[17:56:21] RPC request [] submitted to slush
[17:56:22] RPC request [] submitted to slush
[17:56:25] RPC request [] submitted to slush
[17:56:25] RPC request [] submitted to slush
[17:56:26] RPC request [] submitted to slush
[17:56:29] RPC request [] submitted to slush
[17:56:30] RPC request [] submitted to slush
[17:56:30] RPC request [] submitted to slush
[17:56:33] RPC request [] submitted to slush
[17:56:34] RPC request [] submitted to slush
[17:56:34] RPC request [] submitted to slush
[17:56:34] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000c1267f34a7af1742b26b656cd132de907c7e08e3eed0b65c8049fe6e8f4fad9d4e53bf6f1a094a86415daf15000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:56:34] RPC request [] submitted to slush
[17:56:37] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000c0dbd7562aafff7b819ed4e8f0f85d2ff75c7d8b350affa5ffec2bf422ad41e74e53bf741a094a86a071700c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:56:37] RPC request [] submitted to slush
[17:56:37] RPC request [] submitted to slush
[17:56:38] RPC request [] submitted to slush
[17:56:38] RPC request [] submitted to slush
[17:56:41] RPC request [] submitted to slush
[17:56:42] RPC request [] submitted to slush
[17:56:43] RPC request [] submitted to slush
[17:56:46] RPC request [] submitted to slush
[17:56:46] RPC request [] submitted to slush
[17:56:47] RPC request [] submitted to slush
[17:56:47] mtred:	1288019	  189.1gh/s 
[17:56:50] RPC request [] submitted to slush
[17:56:50] RPC request [] submitted to slush
[17:56:51] RPC request [] submitted to slush
[17:56:52] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000007192461ca6a0be70d76ffb96d5dbb2248f52dfc21f20461fa80eb75374a307cb4e53bf831a094a86d24ae70a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:56:52] RPC request [] submitted to slush
[17:56:54] RPC request [] submitted to slush
[17:56:55] RPC request [] submitted to slush
[17:56:55] RPC request [] submitted to slush
[17:56:58] RPC request [] submitted to slush
[17:56:59] bloodys:	2152331	  
[17:56:59] RPC request [] submitted to slush
[17:56:59] RPC request [] submitted to slush
[17:57:02] RPC request [] submitted to slush
[17:57:03] RPC request [] submitted to slush
[17:57:03] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000005ad38d5ad8c624163ec7f053ee407c4c08f9c40e5d8dcef4e58d428bd6dbd0504e53bfa41a094a861f421303000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:03] RPC request [] submitted to slush
[17:57:03] RPC request [] submitted to slush
[17:57:05] bitclockers:	1169788	  228.1gh/s 
[17:57:07] RPC request [] submitted to slush
[17:57:07] RPC request [] submitted to slush
[17:57:08] RPC request [] submitted to slush
[17:57:11] RPC request [] submitted to slush
[17:57:11] RPC request [] submitted to slush
[17:57:12] RPC request [] submitted to slush
[17:57:14] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000009f0679382f98dc84c6283468f83c07189216e851ca5bb71b33f9940e5bdfc7064e53bfad1a094a868d548e0b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:14] RPC request [] submitted to slush
[17:57:15] RPC request [] submitted to slush
[17:57:15] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000c7752345eea5881c2d5599bed75b4e96f99199993bb5a23215d47fa7b0b214ec4e53bfac1a094a868236fd15000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:15] RPC request [] submitted to slush
[17:57:16] RPC request [] submitted to slush
[17:57:16] RPC request [] submitted to slush
[17:57:18] writing to database
[17:57:19] RPC request [] submitted to slush
[17:57:19] swepool:	4657254	  3.5gh/s 	34105min.
[17:57:20] RPC request [] submitted to slush
[17:57:20] RPC request [] submitted to slush
[17:57:20] triple:	7576639	  
[17:57:23] RPC request [] submitted to slush
[17:57:24] RPC request [] submitted to slush
[17:57:24] RPC request [] submitted to slush
[17:57:26] digbtc:	1803880	  
[17:57:27] RPC request [] submitted to slush
[17:57:28] btcserv:	1474995	  
[17:57:28] RPC request [] submitted to slush
[17:57:28] RPC request [] submitted to slush
[17:57:31] deepbit:	483429	  5744.0gh/s 
[17:57:32] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000bd95c7b86f13b1b5682192b195ee09d48932076c3a00e25c74f20fe421774d554e53bfbd1a094a86a1152013000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:32] RPC request [] submitted to slush
[17:57:32] RPC request [] submitted to slush
[17:57:32] RPC request [] submitted to slush
[17:57:33] RPC request [] submitted to slush
[17:57:34] RPC request [] submitted to slush
[17:57:36] RPC request [] submitted to slush
[17:57:37] RPC request [] submitted to slush
[17:57:37] bithasher:	2385921	  
[17:57:38] RPC request [] submitted to slush
[17:57:40] RPC request [] submitted to slush
[17:57:41] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000004da9aee052303c034604eb39d56ed6b105a6e26bf173cb37849a1180bface4af4e53bfc61a094a86ff3d5e13000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:41] RPC request [] submitted to slush
[17:57:41] RPC request [] submitted to slush
[17:57:42] RPC request [] submitted to slush
[17:57:44] RPC request [] submitted to slush
[17:57:44] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b00000790000000003b8f4728d15b3303f5770eb8a88a4c7fbf0cd9f6c9c8239ebf350b8dd86cd4634e53bfb61a094a8600e30a11000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:45] RPC request [] submitted to slush
[17:57:45] slush:	106977	  1844.2gh/s 	4min.
[17:57:45] RPC request [] submitted to slush
[17:57:46] RPC request [] submitted to slush
[17:57:47] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000da79e6a2e16cbd9a2a4259c0319da6753679b96dab9f289c58b4d713ddab36984e53bfbb1a094a8663748a06000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:47] RPC request [] submitted to slush
[17:57:48] RPC request [] submitted to slush
[17:57:49] RPC request [] submitted to slush
[17:57:50] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000c3142e160fdebedea633c873ad00b8be02df07a64c988ed95868c8f7497469af4e53bfbe1a094a862daad007000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:57:50] RPC request [] submitted to slush
[17:57:50] RPC request [] submitted to slush
[17:57:52] RPC request [] submitted to slush
[17:57:54] btcmonkey:	4310980	  1.8gh/s 
[17:57:54] RPC request [] submitted to slush
[17:57:54] RPC request [] submitted to slush
[17:57:57] RPC request [] submitted to slush
[17:57:58] RPC request [] submitted to slush
[17:57:59] RPC request [] submitted to slush
[17:58:01] RPC request [] submitted to slush
[17:58:02] RPC request [] submitted to slush
[17:58:03] RPC request [] submitted to slush
[17:58:05] RPC request [] submitted to slush
[17:58:06] RPC request [] submitted to slush
[17:58:07] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b000007900000000023aeb0c8b974d1b73df1cf10446437203c7fe44d9627187311bd03b2cfecc64a4e53bfcc1a094a863a25a216000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:58:07] RPC request [] submitted to slush
[17:58:07] RPC request [] submitted to slush
[17:58:09] RPC request [] submitted to slush
[17:58:10] RPC request [] submitted to slush
[17:58:11] RPC request [] submitted to slush
[17:58:14] RPC request [] submitted to slush
[17:58:14] RPC request [] submitted to slush
[17:58:15] RPC request [] submitted to slush
[17:58:18] RPC request [] submitted to slush
[17:58:18] writing to database
[17:58:19] RPC request [] submitted to slush
[17:58:20] RPC request [] submitted to slush
[17:58:22] RPC request [] submitted to slush
[17:58:23] RPC request [u'0000000146580d517b1297a451c21a728c6e684a2d5c76b9070a503b0000079000000000b7d1bb040d79e108270237564ea73f7a969b61c1c9a5c7795f174993a14a7dd64e53bfdd1a094a86894f2c10000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:58:23] RPC request [] submitted to slush
[17:58:23] RPC request [] submitted to slush
[17:58:24] RPC request [] submitted to slush
[17:58:26] RPC request [] submitted to slush
[17:58:27] RPC request [] submitted to slush
[17:58:28] RPC request [] submitted to slush
[17:58:30] RPC request [] submitted to slush
[17:58:31] RPC request [] submitted to slush
[17:58:32] RPC request [] submitted to slush
[17:58:34] RPC request [] submitted to slush
[17:58:35] RPC request [] submitted to slush
[17:58:36] RPC request [] submitted to slush
[17:58:37] New Block: e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000
[17:58:37] Block Owner bitclockers
[17:58:37] Setting Block Owner bitclockers:e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000
[17:58:37] LP Call http://pool.bitclockers.com:8332/LP
[17:58:37] LP Call http://digbtc.net:8332/LP
[17:58:37] LP Call http://pit.deepbit.net:8332/listenChannel
[17:58:37] LP Call http://mtred.com:8837/LP
[17:58:38] LP Call http://pool.bloodys.com:8332/LP
[17:58:38] LP Call http://btcworld.de:8332/LP
[17:58:38] LP Call http://arsbitcoin.com:8344/LP
[17:58:38] RPC request [] submitted to slush
[17:58:39] RPC request [] submitted to slush
[17:58:41] RPC request [] submitted to slush
[17:58:43] RPC request [] submitted to slush
[17:58:44] RPC request [] submitted to slush
[17:58:44] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af000000008c8e64d8b570983fdde4a3290ab2c79b6a2d94aaafb10c764ad301c88c6bd9894e53c0061a094a8631736211000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:58:44] RPC request [] submitted to slush
[17:58:45] RPC request [] submitted to slush
[17:58:47] RPC request [] submitted to slush
[17:58:48] RPC request [] submitted to slush
[17:58:49] RPC request [] submitted to slush
[17:58:51] RPC request [] submitted to slush
[17:58:52] RPC request [] submitted to slush
[17:58:53] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000917c8457e8eafbdf6ca10f9a75ff774ac869b30c9f67fbe557b5997c9e0b260d4e53bffd1a094a86b7071602000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:58:53] RPC request [] submitted to slush
[17:58:53] RPC request [] submitted to slush
[17:58:55] RPC request [] submitted to slush
[17:58:56] RPC request [] submitted to slush
[17:58:57] RPC request [] submitted to slush
[17:58:59] RPC request [] submitted to slush
[17:59:00] RPC request [] submitted to slush
[17:59:02] RPC request [] submitted to slush
[17:59:03] RPC request [] submitted to slush
[17:59:04] RPC request [] submitted to slush
[17:59:06] RPC request [] submitted to slush
[17:59:08] RPC request [] submitted to slush
[17:59:09] RPC request [] submitted to slush
[17:59:10] RPC request [] submitted to slush
[17:59:12] RPC request [] submitted to slush
[17:59:13] RPC request [] submitted to slush
[17:59:14] RPC request [] submitted to slush
[17:59:16] RPC request [] submitted to slush
[17:59:17] RPC request [] submitted to slush
[17:59:18] writing to database
[17:59:18] RPC request [] submitted to slush
[17:59:20] swepool:	4657328	  3.5gh/s 	34107min.
[17:59:20] RPC request [] submitted to slush
[17:59:21] triple:	7577188	  
[17:59:21] RPC request [] submitted to slush
[17:59:22] RPC request [] submitted to slush
[17:59:24] RPC request [] submitted to slush
[17:59:26] RPC request [] submitted to slush
[17:59:26] digbtc:	1804023	  
[17:59:27] RPC request [] submitted to slush
[17:59:28] btcserv:	1475073	  
[17:59:28] RPC request [] submitted to slush
[17:59:30] RPC request [] submitted to slush
[17:59:31] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000e69ab991f80fd923f735a9ef5909f66aceaf01ac35dc81ae9f7133809de1e0644e53c0221a094a86d1d5b40a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:59:31] RPC request [] submitted to slush
[17:59:31] RPC request [] submitted to slush
[17:59:31] deepbit:	645361	  5773.0gh/s 
[17:59:33] RPC request [] submitted to slush
[17:59:34] RPC request [] submitted to slush
[17:59:35] RPC request [] submitted to slush
[17:59:37] RPC request [] submitted to slush
[17:59:38] bithasher:	2386123	  
[17:59:38] RPC request [] submitted to slush
[17:59:39] RPC request [] submitted to slush
[17:59:41] RPC request [] submitted to slush
[17:59:42] RPC request [] submitted to slush
[17:59:43] RPC request [] submitted to slush
[17:59:45] slush:	19799	  1841.3gh/s 	4min.
[17:59:45] Setting Block Owner slush:e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000
[17:59:45] RPC request [] submitted to slush
[17:59:47] RPC request [] submitted to slush
[17:59:47] RPC request [] submitted to slush
[17:59:49] RPC request [] submitted to slush
[17:59:51] RPC request [] submitted to slush
[17:59:52] RPC request [] submitted to slush
[17:59:53] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af0000000084aba981587eca962d51088a71589c3dfa37c0643209443e5f428c4acff407be4e53c0391a094a8699bdf706000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:59:53] RPC request [] submitted to slush
[17:59:53] RPC request [] submitted to slush
[17:59:55] btcmonkey:	4311030	  1.8gh/s 
[17:59:55] RPC request [] submitted to slush
[17:59:56] RPC request [] submitted to slush
[17:59:58] RPC request [] submitted to slush
[17:59:59] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af000000008eb5631095baed72e7fb0a198fc33f379144d7ad10ca0363df031759f9cbdb364e53c0511a094a86d85ba00f000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[17:59:59] RPC request [] submitted to slush
[17:59:59] RPC request [] submitted to slush
[18:00:00] arsbitcoin:	1706455	  
[18:00:00] RPC request [] submitted to slush
[18:00:02] RPC request [] submitted to slush
[18:00:03] RPC request [] submitted to slush
[18:00:04] RPC request [] submitted to slush
[18:00:06] RPC request [] submitted to slush
[18:00:07] RPC request [] submitted to slush
[18:00:09] RPC request [] submitted to slush
[18:00:10] RPC request [] submitted to slush
[18:00:12] RPC request [] submitted to slush
[18:00:13] RPC request [] submitted to slush
[18:00:13] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000f29f3f7d687f19e7097e1a686d0235b20e4d234baa8771c2812773ed70ebd0b74e53c04b1a094a869837ba10000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:00:14] RPC request [] submitted to slush
[18:00:14] RPC request [] submitted to slush
[18:00:16] RPC request [] submitted to slush
[18:00:17] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af000000005b3227bcd80936546a6c9c97f434040dfeb71e0471522c414536a98167d21bc44e53c0641a094a86decdea0a000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:00:17] RPC request [] submitted to slush
[18:00:17] RPC request [] submitted to slush
[18:00:18] writing to database
[18:00:19] RPC request [] submitted to slush
[18:00:20] RPC request [] submitted to slush
[18:00:21] RPC request [] submitted to slush
[18:00:23] RPC request [] submitted to slush
[18:00:24] RPC request [] submitted to slush
[18:00:25] RPC request [] submitted to slush
[18:00:27] RPC request [] submitted to slush
[18:00:29] RPC request [] submitted to slush
[18:00:30] RPC request [] submitted to slush
[18:00:31] RPC request [] submitted to slush
[18:00:33] RPC request [] submitted to slush
[18:00:34] RPC request [] submitted to slush
[18:00:35] RPC request [] submitted to slush
[18:00:38] RPC request [] submitted to slush
[18:00:39] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000af154e799357cdc595e2b6ab11084efbbf2d10aef32d5facf16c7afd141722b44e53c0631a094a860868520c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:00:39] RPC request [] submitted to slush
[18:00:39] RPC request [] submitted to slush
[18:00:39] RPC request [] submitted to slush
[18:00:42] RPC request [] submitted to slush
[18:00:44] RPC request [] submitted to slush
[18:00:44] RPC request [] submitted to slush
[18:00:47] RPC request [] submitted to slush
[18:00:48] RPC request [] submitted to slush
[18:00:48] RPC request [] submitted to slush
[18:00:50] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af000000003d5fb57ee900cd61af93b468d93bd48441919e543204f788da9bcf4682ba39314e53c0711a094a86ba36cb09000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:00:50] RPC request [] submitted to slush
[18:00:51] RPC request [] submitted to slush
[18:00:52] RPC request [] submitted to slush
[18:00:52] RPC request [] submitted to slush
[18:00:55] RPC request [] submitted to slush
[18:00:56] RPC request [] submitted to slush
[18:00:56] RPC request [] submitted to slush
[18:00:59] RPC request [] submitted to slush
[18:01:00] RPC request [] submitted to slush
[18:01:00] RPC request [] submitted to slush
[18:01:04] RPC request [] submitted to slush
[18:01:04] RPC request [] submitted to slush
[18:01:04] RPC request [] submitted to slush
[18:01:08] RPC request [] submitted to slush
[18:01:09] RPC request [] submitted to slush
[18:01:09] RPC request [] submitted to slush
[18:01:12] RPC request [] submitted to slush
[18:01:12] mtred:	1302042	  200.8gh/s 
[18:01:13] RPC request [] submitted to slush
[18:01:13] RPC request [] submitted to slush
[18:01:16] RPC request [] submitted to slush
[18:01:17] RPC request [] submitted to slush
[18:01:17] RPC request [] submitted to slush
[18:01:18] writing to database
[18:01:20] swepool:	4657417	  3.0gh/s 	34109min.
[18:01:20] RPC request [] submitted to slush
[18:01:21] triple:	7577842	  
[18:01:21] RPC request [] submitted to slush
[18:01:21] RPC request [] submitted to slush
[18:01:24] RPC request [] submitted to slush
[18:01:25] RPC request [] submitted to slush
[18:01:25] RPC request [] submitted to slush
[18:01:27] digbtc:	1782880	  
[18:01:28] btcserv:	1475154	  
[18:01:29] RPC request [] submitted to slush
[18:01:29] bitclockers:	1180093	  226.0gh/s 
[18:01:29] RPC request [] submitted to slush
[18:01:29] RPC request [] submitted to slush
[18:01:31] deepbit:	806455	  5750.0gh/s 
[18:01:33] RPC request [] submitted to slush
[18:01:34] RPC request [] submitted to slush
[18:01:34] RPC request [] submitted to slush
[18:01:37] RPC request [] submitted to slush
[18:01:38] RPC request [] submitted to slush
[18:01:38] RPC request [] submitted to slush
[18:01:38] bithasher:	2386307	  
[18:01:41] RPC request [] submitted to slush
[18:01:42] RPC request [] submitted to slush
[18:01:42] RPC request [] submitted to slush
[18:01:45] slush:	82333	  1848.3gh/s 	3min.
[18:01:45] RPC request [] submitted to slush
[18:01:46] RPC request [] submitted to slush
[18:01:46] RPC request [] submitted to slush
[18:01:50] RPC request [] submitted to slush
[18:01:50] RPC request [] submitted to slush
[18:01:50] RPC request [] submitted to slush
[18:01:54] RPC request [] submitted to slush
[18:01:54] RPC request [] submitted to slush
[18:01:54] RPC request [] submitted to slush
[18:01:56] btcmonkey:	4311081	  1.8gh/s 
[18:01:58] RPC request [] submitted to slush
[18:01:58] RPC request [] submitted to slush
[18:01:59] RPC request [] submitted to slush
[18:02:02] RPC request [] submitted to slush
[18:02:03] RPC request [] submitted to slush
[18:02:03] RPC request [] submitted to slush
[18:02:06] RPC request [] submitted to slush
[18:02:07] RPC request [] submitted to slush
[18:02:07] RPC request [] submitted to slush
[18:02:10] RPC request [] submitted to slush
[18:02:11] RPC request [] submitted to slush
[18:02:11] RPC request [] submitted to slush
[18:02:14] RPC request [] submitted to slush
[18:02:15] RPC request [] submitted to slush
[18:02:15] RPC request [] submitted to slush
[18:02:18] writing to database
[18:02:19] RPC request [] submitted to slush
[18:02:19] RPC request [] submitted to slush
[18:02:20] RPC request [] submitted to slush
[18:02:23] RPC request [] submitted to slush
[18:02:24] RPC request [] submitted to slush
[18:02:24] RPC request [] submitted to slush
[18:02:27] RPC request [] submitted to slush
[18:02:28] RPC request [] submitted to slush
[18:02:28] RPC request [] submitted to slush
[18:02:31] RPC request [] submitted to slush
[18:02:32] RPC request [] submitted to slush
[18:02:32] RPC request [] submitted to slush
[18:02:34] ozco:	1909776	  63.0gh/s 	1268min.
[18:02:35] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af0000000003d1f24fd7de12a885e001b0500190d8ce6c43005227a2e5cceebef6ee748bad4e53c0d91a094a868b7f400d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:02:35] RPC request [] submitted to slush
[18:02:35] RPC request [] submitted to slush
[18:02:35] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af000000003c02a119c21b89349affc19c4b16ac8a7230930111b39f84a5882bd334e6dc874e53c0d81a094a8607f7d517000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:02:36] RPC request [] submitted to slush
[18:02:36] RPC request [] submitted to slush
[18:02:36] RPC request [] submitted to slush
[18:02:37] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000013b05372bfc35bc50ce8f37d7732479ee9c5e3134dc59610b764a26d794ef8e4e53c0dd1a094a869307ad01000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:02:37] RPC request [] submitted to slush
[18:02:39] RPC request [] submitted to slush
[18:02:40] RPC request [] submitted to slush
[18:02:40] RPC request [] submitted to slush
[18:02:42] RPC request [u'00000001e07c54c92138ecfca852a93619d9065ce25ca174ef3a2f33000006af00000000e4a928e49ca01b5dbeea9e3b9f4ea134eef4110022af2680d23131b56b8c2e984e53c0f61a094a869b5c1905000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:02:42] RPC request [] submitted to slush
[18:02:44] RPC request [] submitted to slush
[18:02:45] RPC request [] submitted to slush
[18:02:45] RPC request [] submitted to slush
[18:02:48] RPC request [] submitted to slush
[18:02:49] RPC request [] submitted to slush
[18:02:49] RPC request [] submitted to slush
[18:02:52] RPC request [] submitted to slush
[18:02:53] RPC request [] submitted to slush
[18:02:53] RPC request [] submitted to slush
[18:02:53] New Block: 962aec0127251b5768c9cd5487dc1e29afb1a930a3fa49bf0000064200000000
[18:02:53] Block Owner digbtc
[18:02:53] Setting Block Owner digbtc:962aec0127251b5768c9cd5487dc1e29afb1a930a3fa49bf0000064200000000
[18:02:53] LP Call http://digbtc.net:8332/LP
[18:02:54] LP Call http://mtred.com:8837/LP
[18:02:54] LP Call http://pool.bitclockers.com:8332/LP
[18:02:54] LP Call http://btcworld.de:8332/LP
[18:02:55] LP Call http://pit.deepbit.net:8332/listenChannel
[18:02:55] LP Call http://pool.bloodys.com:8332/LP
[18:02:55] LP Call http://arsbitcoin.com:8344/LP
[18:02:55] LP Call http://swepool.net:8337/LP
[18:02:57] RPC request [] submitted to slush
[18:02:57] RPC request [] submitted to slush
[18:02:57] RPC request [] submitted to slush
[18:03:01] RPC request [] submitted to slush
[18:03:01] RPC request [] submitted to slush
[18:03:01] RPC request [] submitted to slush
[18:03:05] RPC request [] submitted to slush
[18:03:05] RPC request [] submitted to slush
[18:03:05] RPC request [] submitted to slush
[18:03:09] RPC request [u'00000001962aec0127251b5768c9cd5487dc1e29afb1a930a3fa49bf00000642000000003bf349df72597835867f3f86591b8a8dc556fd95e9b49ada119763db3c18cf3e4e53c10e1a094a869e638316000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:03:09] RPC request [] submitted to slush
[18:03:09] RPC request [] submitted to slush
[18:03:09] RPC request [] submitted to slush
[18:03:10] RPC request [] submitted to slush
[18:03:13] RPC request [] submitted to slush
[18:03:14] RPC request [] submitted to slush
[18:03:14] RPC request [] submitted to slush
[18:03:18] RPC request [] submitted to slush
[18:03:18] RPC request [] submitted to slush
[18:03:18] RPC request [] submitted to slush
[18:03:18] writing to database
[18:03:20] swepool:	4657489	  3.0gh/s 	34111min.
[18:03:21] triple:	7578434	  
[18:03:22] RPC request [] submitted to slush
[18:03:22] RPC request [] submitted to slush
[18:03:22] RPC request [] submitted to slush
[18:03:23] bloodys:	2152481	  
[18:03:23] New Block: 783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d100000000
[18:03:23] Block Owner bitclockers
[18:03:23] Setting Block Owner bitclockers:783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d100000000
[18:03:23] LP Call http://pool.bitclockers.com:8332/LP
[18:03:23] LP Call http://arsbitcoin.com:8344/LP
[18:03:24] LP Call http://digbtc.net:8332/LP
[18:03:24] LP Call http://btcworld.de:8332/LP
[18:03:24] LP Call http://mtred.com:8837/LP
[18:03:24] LP Call http://swepool.net:8337/LP
[18:03:25] LP Call http://pit.deepbit.net:8332/listenChannel
[18:03:25] LP Call http://pool.bloodys.com:8332/LP
[18:03:26] RPC request [] submitted to slush
[18:03:26] RPC request [] submitted to slush
[18:03:26] RPC request [] submitted to slush
[18:03:27] digbtc:	1804310	  
[18:03:28] btcserv:	1475237	  
[18:03:30] RPC request [] submitted to slush
[18:03:30] RPC request [] submitted to slush
[18:03:30] RPC request [] submitted to slush
[18:03:32] deepbit:	967823	  5752.0gh/s 
[18:03:34] RPC request [] submitted to slush
[18:03:34] RPC request [] submitted to slush
[18:03:35] RPC request [] submitted to slush
[18:03:38] RPC request [] submitted to slush
[18:03:39] RPC request [] submitted to slush
[18:03:39] RPC request [] submitted to slush
[18:03:39] bithasher:	2386490	  
[18:03:43] RPC request [] submitted to slush
[18:03:43] RPC request [] submitted to slush
[18:03:43] RPC request [] submitted to slush
[18:03:45] RPC request [u'00000001783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d1000000001e528d591aaa66aac85d0155ad6c299e3a3cbbfa90f98cee51af0876300809934e53c1341a094a8635632e0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:03:45] RPC request [] submitted to slush
[18:03:45] slush:	122734	  1846.9gh/s 	4min.
[18:03:47] RPC request [] submitted to slush
[18:03:47] RPC request [] submitted to slush
[18:03:47] RPC request [] submitted to slush
[18:03:51] RPC request [] submitted to slush
[18:03:51] RPC request [] submitted to slush
[18:03:51] RPC request [] submitted to slush
[18:03:54] RPC request [u'00000001783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d10000000020cc0c6405185da89aef12305bb9bf4d21d9ea817e8479d3543d3f443d3fd4364e53c13d1a094a86a234020b000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:03:54] RPC request [] submitted to slush
[18:03:55] RPC request [] submitted to slush
[18:03:55] RPC request [] submitted to slush
[18:03:56] RPC request [] submitted to slush
[18:03:57] btcmonkey:	4311194	  1.8gh/s 
[18:03:59] RPC request [] submitted to slush
[18:04:00] RPC request [] submitted to slush
[18:04:00] RPC request [] submitted to slush
[18:04:03] RPC request [] submitted to slush
[18:04:04] RPC request [] submitted to slush
[18:04:04] RPC request [] submitted to slush
[18:04:05] RPC request [u'00000001783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d1000000007f56d3347726cd6d886d7e068f5f61cc47d260dd3f2f65355d9c0658495e8f4c4e53c1491a094a8699a0a802000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:04:05] RPC request [] submitted to slush
[18:04:08] RPC request [] submitted to slush
[18:04:08] RPC request [] submitted to slush
[18:04:08] RPC request [] submitted to slush
[18:04:12] RPC request [] submitted to slush
[18:04:12] RPC request [] submitted to slush
[18:04:12] RPC request [] submitted to slush
[18:04:16] RPC request [] submitted to slush
[18:04:16] RPC request [] submitted to slush
[18:04:16] RPC request [] submitted to slush
[18:04:18] writing to database
[18:04:20] RPC request [] submitted to slush
[18:04:20] RPC request [] submitted to slush
[18:04:21] RPC request [] submitted to slush
[18:04:23] arsbitcoin:	1737637	  
[18:04:25] RPC request [] submitted to slush
[18:04:25] RPC request [] submitted to slush
[18:04:25] RPC request [] submitted to slush
[18:04:29] RPC request [] submitted to slush
[18:04:29] RPC request [] submitted to slush
[18:04:29] RPC request [] submitted to slush
[18:04:32] RPC request [u'00000001783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d100000000fbd1759fc1f5e91054d80dc16a25a7e2d001ae8c061a5f075426dcf142c6e2834e53c1621a094a861e2be10d000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:04:32] RPC request [] submitted to slush
[18:04:33] RPC request [] submitted to slush
[18:04:33] RPC request [] submitted to slush
[18:04:33] RPC request [] submitted to slush
[18:04:35] RPC request [u'00000001783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d100000000a0633c94215c4ab19d43c601a859683f0191d8044abe6f25eeda7492097f57f84e53c1521a094a8604971109000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:04:35] RPC request [] submitted to slush
[18:04:37] RPC request [] submitted to slush
[18:04:37] RPC request [] submitted to slush
[18:04:37] RPC request [] submitted to slush
[18:04:41] RPC request [] submitted to slush
[18:04:41] RPC request [] submitted to slush
[18:04:41] RPC request [] submitted to slush
[18:04:45] RPC request [] submitted to slush
[18:04:46] RPC request [] submitted to slush
[18:04:46] RPC request [] submitted to slush
[18:04:49] RPC request [u'00000001783ff3465b9047fcfa2aa396fc95cc8c04a3f2c541d31d5a000001d100000000abff6e70b5bed1382b8e79f8f568908493bd28903e37eebb763b4616749ecdfe4e53c1731a094a865c7cee15000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to slush
[18:04:49] RPC request [] submitted to slush
[18:04:50] RPC request [] submitted to slush
[18:04:50] RPC request [] submitted to slush
[18:04:50] RPC request [] submitted to slush
[18:04:53] New Block: a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d00000000
[18:04:53] Block Owner deepbit
[18:04:53] Setting Block Owner deepbit:a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d00000000
[18:04:53] Server change to deepbit
[18:04:53] LP Call http://pit.deepbit.net:8332/listenChannel
[18:04:54] RPC request [] submitted to deepbit
[18:04:54] RPC request [] submitted to deepbit
[18:04:54] RPC request [] submitted to deepbit
[18:04:58] RPC request [] submitted to deepbit
[18:04:58] RPC request [] submitted to deepbit
[18:04:58] RPC request [] submitted to deepbit
[18:05:02] RPC request [] submitted to deepbit
[18:05:02] RPC request [] submitted to deepbit
[18:05:03] RPC request [] submitted to deepbit
[18:05:06] RPC request [] submitted to deepbit
[18:05:06] RPC request [] submitted to deepbit
[18:05:07] RPC request [] submitted to deepbit
[18:05:07] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d00000000eb443217287c4901e9bb392c2d5fca6136e769f63438b27d0d880053e9ac29b24e53c1691a094a86026fe703000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:05:07] RPC request [] submitted to deepbit
[18:05:11] RPC request [] submitted to deepbit
[18:05:11] RPC request [] submitted to deepbit
[18:05:11] RPC request [] submitted to deepbit
[18:05:15] RPC request [] submitted to deepbit
[18:05:15] RPC request [] submitted to deepbit
[18:05:15] RPC request [] submitted to deepbit
[18:05:19] writing to database
[18:05:19] RPC request [] submitted to deepbit
[18:05:19] RPC request [] submitted to deepbit
[18:05:19] RPC request [] submitted to deepbit
[18:05:20] swepool:	4657550	  3.0gh/s 	34113min.
[18:05:21] triple:	7579185	  
[18:05:23] RPC request [] submitted to deepbit
[18:05:23] RPC request [] submitted to deepbit
[18:05:23] RPC request [] submitted to deepbit
[18:05:27] RPC request [] submitted to deepbit
[18:05:28] RPC request [] submitted to deepbit
[18:05:28] digbtc:	1804464	  
[18:05:28] RPC request [] submitted to deepbit
[18:05:29] btcserv:	1475303	  
[18:05:31] RPC request [] submitted to deepbit
[18:05:32] RPC request [] submitted to deepbit
[18:05:32] RPC request [] submitted to deepbit
[18:05:32] deepbit:	160449	  5720.0gh/s 
[18:05:35] RPC request [] submitted to deepbit
[18:05:36] RPC request [] submitted to deepbit
[18:05:36] RPC request [] submitted to deepbit
[18:05:40] bithasher:	2386693	  
[18:05:40] RPC request [] submitted to deepbit
[18:05:40] RPC request [] submitted to deepbit
[18:05:40] RPC request [] submitted to deepbit
[18:05:44] RPC request [] submitted to deepbit
[18:05:44] RPC request [] submitted to deepbit
[18:05:45] RPC request [] submitted to deepbit
[18:05:45] slush:	176939	  1838.0gh/s 	6min.
[18:05:48] RPC request [] submitted to deepbit
[18:05:48] RPC request [] submitted to deepbit
[18:05:49] RPC request [] submitted to deepbit
[18:05:52] RPC request [] submitted to deepbit
[18:05:52] RPC request [] submitted to deepbit
[18:05:53] RPC request [] submitted to deepbit
[18:05:56] RPC request [] submitted to deepbit
[18:05:56] RPC request [] submitted to deepbit
[18:05:57] RPC request [] submitted to deepbit
[18:05:57] RPC request [] submitted to deepbit
[18:05:58] btcmonkey:	4311246	  2.6gh/s 
[18:06:00] RPC request [] submitted to deepbit
[18:06:00] RPC request [] submitted to deepbit
[18:06:01] RPC request [] submitted to deepbit
[18:06:02] RPC request [] submitted to deepbit
[18:06:05] RPC request [] submitted to deepbit
[18:06:05] RPC request [] submitted to deepbit
[18:06:05] RPC request [] submitted to deepbit
[18:06:06] RPC request [] submitted to deepbit
[18:06:09] RPC request [] submitted to deepbit
[18:06:09] RPC request [] submitted to deepbit
[18:06:09] RPC request [] submitted to deepbit
[18:06:10] RPC request [] submitted to deepbit
[18:06:13] RPC request [] submitted to deepbit
[18:06:13] RPC request [] submitted to deepbit
[18:06:13] RPC request [] submitted to deepbit
[18:06:14] RPC request [] submitted to deepbit
[18:06:17] RPC request [] submitted to deepbit
[18:06:17] RPC request [] submitted to deepbit
[18:06:17] RPC request [] submitted to deepbit
[18:06:18] RPC request [] submitted to deepbit
[18:06:19] writing to database
[18:06:21] RPC request [] submitted to deepbit
[18:06:21] RPC request [] submitted to deepbit
[18:06:22] RPC request [] submitted to deepbit
[18:06:22] RPC request [] submitted to deepbit
[18:06:23] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d0000000029e540c9c5faff745f76901e245ab35d43597f4ba185c27102f5175595b800154e53c1b41a094a8657d26703000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:06:23] RPC request [] submitted to deepbit
[18:06:26] RPC request [] submitted to deepbit
[18:06:26] RPC request [] submitted to deepbit
[18:06:26] RPC request [] submitted to deepbit
[18:06:26] RPC request [] submitted to deepbit
[18:06:30] RPC request [] submitted to deepbit
[18:06:30] RPC request [] submitted to deepbit
[18:06:30] RPC request [] submitted to deepbit
[18:06:31] RPC request [] submitted to deepbit
[18:06:34] RPC request [] submitted to deepbit
[18:06:34] RPC request [] submitted to deepbit
[18:06:34] RPC request [] submitted to deepbit
[18:06:34] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d0000000007aa7743163cb5ad57a4678e666c3c3e2b74b718e0108cc60434a9b03111c5814e53c1bb1a094a86afbe0b16000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:06:34] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d00000000fa70562011ea915c2aedcad7a11b7f134d4d720400fa617195a6ae4300fd1e524e53c1bb1a094a86fc6e7115000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:06:34] RPC request [] submitted to deepbit
[18:06:34] RPC request [] submitted to deepbit
[18:06:35] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d00000000b84d370004fc88b85a59db5dd290835e8041b247546ba9661698370083c834f24e53c1c01a094a869f71ff00000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:06:35] RPC request [] submitted to deepbit
[18:06:35] RPC request [] submitted to deepbit
[18:06:36] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d0000000001b74fb07a483c91b9e92f809597cab8c631aa08366abe572b68aa97072b19814e53c1c01a094a86bba76b06000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:06:36] RPC request [] submitted to deepbit
[18:06:38] RPC request [] submitted to deepbit
[18:06:38] RPC request [] submitted to deepbit
[18:06:38] RPC request [] submitted to deepbit
[18:06:39] RPC request [] submitted to deepbit
[18:06:42] RPC request [] submitted to deepbit
[18:06:42] RPC request [] submitted to deepbit
[18:06:43] RPC request [] submitted to deepbit
[18:06:43] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d000000003883550c46596ccfc2ebe950816c10f6302c012d31551f1238914dde5c10de4e4e53c1c51a094a86d5887314000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:06:43] RPC request [] submitted to deepbit
[18:06:43] RPC request [] submitted to deepbit
[18:06:46] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d00000000a7898f1335090970ccbabbfe6b2e167fae5af8a652aa1d6a7b42a57a907159f84e53c1c81a094a867850d012000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:06:46] RPC request [] submitted to deepbit
[18:06:47] RPC request [] submitted to deepbit
[18:06:47] RPC request [] submitted to deepbit
[18:06:47] RPC request [] submitted to deepbit
[18:06:48] RPC request [] submitted to deepbit
[18:06:51] RPC request [] submitted to deepbit
[18:06:51] RPC request [] submitted to deepbit
[18:06:51] RPC request [] submitted to deepbit
[18:06:52] RPC request [] submitted to deepbit
[18:06:55] RPC request [] submitted to deepbit
[18:06:55] RPC request [] submitted to deepbit
[18:06:55] RPC request [] submitted to deepbit
[18:06:56] RPC request [] submitted to deepbit
[18:06:59] RPC request [] submitted to deepbit
[18:06:59] RPC request [] submitted to deepbit
[18:06:59] RPC request [] submitted to deepbit
[18:07:00] RPC request [] submitted to deepbit
[18:07:02] RPC request [u'00000001a1cca90036cd71e277af8bf7328862ecce44b71f0d36e0e20000072d0000000090542e62e235ce4cea41900c0f4ad8968b443d46956c74a045f7ba7f6da9fdaa4e53c1da1a094a86d4ca3a0c000000800000000000000000000000000000000000000000000000000000000000000000000000000000000080020000'] submitted to deepbit
[18:07:02] RPC request [] submitted to deepbit
[18:07:03] RPC request [] submitted to deepbit
[18:07:03] RPC request [] submitted to deepbit
[18:07:03] RPC request [] submitted to deepbit
[18:07:04] RPC request [] submitted to deepbit
[18:07:07] RPC request [] submitted to deepbit
[18:07:08] RPC request [] submitted to deepbit
[18:07:08] RPC request [] submitted to deepbit
[18:07:08] RPC request [] submitted to deepbit
[18:07:10] LP Call http://digbtc.net:8332/LP
[18:07:19] writing to database
[18:08:19] writing to database
2 DBWRITE CALLS FOUND IN A ROW 2
diff:25:         with self.lock:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:74:         self.counter -= 1
eventlet.semaphore:75:         return True
threading:124:         if rc:
threading:125:             self.__owner = me
threading:126:             self.__count = 1
threading:128:                 self._note("%s.acquire(%s): initial success", self, blocking)
threading:65:             if self.__verbose:
threading:132:         return rc
diff:26:             return self.difficulty
threading:150:         self.release()
threading:137:         if self.__owner != _get_ident():
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:139:         self.__count = count = self.__count - 1
threading:140:         if not count:
threading:141:             self.__owner = None
threading:142:             self.__block.release()
eventlet.semaphore:87:         self.counter += 1
eventlet.semaphore:88:         if self._waiters:
eventlet.semaphore:90:         return True
threading:144:                 self._note("%s.release(): final release", self)
threading:65:             if self.__verbose:
threading:150:         self.release()
threading:137:         if self.__owner != _get_ident():
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:139:         self.__count = count = self.__count - 1
threading:140:         if not count:
threading:141:             self.__owner = None
threading:142:             self.__block.release()
eventlet.semaphore:87:         self.counter += 1
eventlet.semaphore:88:         if self._waiters:
eventlet.semaphore:90:         return True
threading:144:                 self._note("%s.release(): final release", self)
threading:65:             if self.__verbose:
eventlet.greenthread:25:     hub = hubs.get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.greenthread:26:     current = getcurrent()
eventlet.greenthread:27:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.greenthread:28:     timer = hub.schedule_call_global(seconds, current.switch)
eventlet.hubs.hub:313:         t = timer.Timer(seconds, cb, *args, **kw)
eventlet.hubs.timer:19:         self.seconds = seconds
eventlet.hubs.timer:20:         self.tpl = cb, args, kw
eventlet.hubs.timer:21:         self.called = False
eventlet.hubs.timer:22:         if _g_debug:
eventlet.hubs.hub:314:         self.add_timer(t)
eventlet.hubs.hub:269:         scheduled_time = self.clock() + timer.seconds
eventlet.hubs.hub:270:         self.next_timers.append((scheduled_time, timer))
eventlet.hubs.hub:271:         return scheduled_time
eventlet.hubs.hub:315:         return t
eventlet.greenthread:29:     try:
eventlet.greenthread:30:         hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:286:             if item[1].called:
eventlet.hubs.hub:289:                 heappush(t, item)
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.greenthread:191:         try:
eventlet.greenthread:192:             result = function(*args, **kwargs)
pool:430:         if self.servers[server]['role'] not in self.api_pull:
pool:432:         info = self.servers[server]
pool:433:         self.bitHopper.scheduler.update_api_server(server)
scheduler:136:         return
pool:434:         value = self.bitHopper.work.get(info['api_address'])
work:53:         header = {'User-Agent':'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))'}
work:54:         with self.get_http(url) as http:
work:26:         if address not in self.connect_pool:
work:28:         return self.connect_pool[address].item()
contextlib:83:         return GeneratorContextManager(func(*args, **kwds))
contextlib:12:         self.gen = gen
contextlib:15:         try:
contextlib:16:             return self.gen.next()
eventlet.pools:15:     >>> from eventlet import pools
eventlet.pools:114:         if self.free_items:
eventlet.pools:115:             return self.free_items.popleft()
eventlet.pools:16:     >>> pool = pools.TokenPool(max_size=4)
eventlet.pools:17:     >>> with pool.item() as obj:
work:55:             try:
work:56:                 content = http.request( url, 'GET', headers=header)[1] # Returns response dict and content str
httplib20_7_1:1277:         try:
httplib20_7_1:1278:             if headers is None:
httplib20_7_1:1281:                 headers = self._normalize_headers(headers)
httplib20_7_1:1249:         return _normalize_headers(headers)
httplib20_7_1:249:     return dict([ (key.lower(), NORMALIZE_SPACE.sub(value, ' ').strip())  for (key, value) in headers.iteritems()])
httplib20_7_1:249:     return dict([ (key.lower(), NORMALIZE_SPACE.sub(value, ' ').strip())  for (key, value) in headers.iteritems()])
httplib20_7_1:1283:             if not headers.has_key('user-agent'):
httplib20_7_1:1286:             uri = iri2uri(uri)
httplib20_7_1.iri2uri:69:     if isinstance(uri ,unicode):
httplib20_7_1.iri2uri:77:     return uri
httplib20_7_1:1288:             (scheme, authority, request_uri, defrag_uri) = urlnorm(uri)
httplib20_7_1:201:     (scheme, authority, path, query, fragment) = parse_uri(uri)
httplib20_7_1:197:     groups = URI.match(uri).groups()
httplib20_7_1:198:     return (groups[1], groups[3], groups[4], groups[6], groups[8])
httplib20_7_1:202:     if not scheme or not authority:
httplib20_7_1:204:     authority = authority.lower()
httplib20_7_1:205:     scheme = scheme.lower()
httplib20_7_1:206:     if not path:
httplib20_7_1:210:     request_uri = query and "?".join([path, query]) or path
httplib20_7_1:211:     scheme = scheme.lower()
httplib20_7_1:212:     defrag_uri = scheme + "://" + authority + request_uri
httplib20_7_1:213:     return scheme, authority, request_uri, defrag_uri
httplib20_7_1:1289:             domain_port = authority.split(":")[0:2]
httplib20_7_1:1290:             if len(domain_port) == 2 and domain_port[1] == '443' and scheme == 'http':
httplib20_7_1:1294:             conn_key = scheme+":"+authority
httplib20_7_1:1295:             if conn_key in self.connections:
httplib20_7_1:1296:                 conn = self.connections[conn_key]
httplib20_7_1:1323:             if 'range' not in headers and 'accept-encoding' not in headers:
httplib20_7_1:1324:                 headers['accept-encoding'] = 'gzip, deflate'
httplib20_7_1:1326:             info = email.Message.Message()
email.message:106:         self._headers = []
email.message:107:         self._unixfrom = None
email.message:108:         self._payload = None
email.message:109:         self._charset = None
email.message:111:         self.preamble = self.epilogue = None
email.message:112:         self.defects = []
email.message:114:         self._default_type = 'text/plain'
httplib20_7_1:1327:             cached_value = None
httplib20_7_1:1328:             if self.cache:
httplib20_7_1:1348:                 cachekey = None
httplib20_7_1:1350:             if method in self.optimistic_concurrency_methods and self.cache and info.has_key('etag') and not self.ignore_etag and 'if-match' not in headers:
httplib20_7_1:1354:             if method not in ["GET", "HEAD"] and self.cache and cachekey:
httplib20_7_1:1360:             if method in ['GET', 'HEAD'] and 'vary' in info:
email.message:313:         return name.lower() in [k.lower() for k, v in self._headers]
httplib20_7_1:1370:             if cached_value and method in ["GET", "HEAD"] and self.cache and 'range' not in headers:
httplib20_7_1:1430:                 cc = _parse_cache_control(headers)
httplib20_7_1:252:     retval = {}
httplib20_7_1:253:     if headers.has_key('cache-control'):
httplib20_7_1:258:     return retval
httplib20_7_1:1431:                 if cc.has_key('only-if-cached'):
httplib20_7_1:1436:                     (response, content) = self._request(conn, authority, uri, request_uri, method, body, headers, redirections, cachekey)
httplib20_7_1:1183:         auths = [(auth.depth(request_uri), auth) for auth in self.authorizations if auth.inscope(host, request_uri)]
httplib20_7_1:1184:         auth = auths and sorted(auths)[0][1] or None
httplib20_7_1:1185:         if auth:
httplib20_7_1:1188:         (response, content) = self._conn_request(conn, request_uri, method, body, headers)
httplib20_7_1:1120:         for i in range(2):
httplib20_7_1:1121:             try:
httplib20_7_1:1122:                 if conn.sock is None:
httplib20_7_1:1124:                 conn.request(method, request_uri, body, headers)
httplib:909:         try:
httplib:910:             self._send_request(method, url, body, headers)
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:921:         skips = {}
httplib:922:         if 'host' in header_names:
httplib:924:         if 'accept-encoding' in header_names:
httplib:925:             skips['skip_accept_encoding'] = 1
httplib:927:         self.putrequest(method, url, **skips)
httplib:789:         if self.__response and self.__response.isclosed():
httplib:509:         return self.fp is None
httplib:790:             self.__response = None
httplib:811:         if self.__state == _CS_IDLE:
httplib:812:             self.__state = _CS_REQ_STARTED
httplib:817:         self._method = method
httplib:818:         if not url:
httplib:820:         str = '%s %s %s' % (method, url, self._http_vsn_str)
httplib:822:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:824:         if self._http_vsn == 11:
httplib:827:             if not skip_host:
httplib:842:                 netloc = ''
httplib:843:                 if url.startswith('http'):
httplib:846:                 if netloc:
httplib:853:                     try:
httplib:854:                         host_enc = self.host.encode("ascii")
httplib:857:                     if self.port == self.default_port:
httplib:858:                         self.putheader('Host', host_enc)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:870:             if not skip_accept_encoding:
httplib:883:             pass
httplib:929:         if body and ('content-length' not in header_names):
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:947:         self.endheaders()
httplib:899:         if self.__state == _CS_REQ_STARTED:
httplib:900:             self.__state = _CS_REQ_SENT
httplib:904:         self._send_output()
httplib:773:         self._buffer.extend(("", ""))
httplib:774:         msg = "\r\n".join(self._buffer)
httplib:775:         del self._buffer[:]
httplib:776:         self.send(msg)
httplib:733:         if self.sock is None:
httplib:744:         if self.debuglevel > 0:
httplib:746:         try:
httplib:747:             blocksize=8192
httplib:748:             if hasattr(str,'read') and not isinstance(str, array):
httplib:755:                 self.sock.sendall(str)
eventlet.greenio:283:         tail = self.send(data, flags)
eventlet.greenio:259:         fd = self.fd
eventlet.greenio:260:         if self.act_non_blocking:
eventlet.greenio:264:         total_sent = 0
eventlet.greenio:265:         len_data = len(data)
eventlet.greenio:267:         while 1:
eventlet.greenio:268:             try:
eventlet.greenio:269:                 total_sent += fd.send(data[total_sent:], flags)
eventlet.greenio:274:             if total_sent == len_data:
eventlet.greenio:275:                 break
eventlet.greenio:280:         return total_sent
eventlet.greenio:284:         len_data = len(data)
eventlet.greenio:285:         while tail < len_data:
httplib:949:         if body:
httplib20_7_1:1157:             try:
httplib20_7_1:1158:                 response = conn.getresponse()
httplib:956:         if self.__response and self.__response.isclosed():
httplib:975:         if self.__state != _CS_REQ_SENT or self.__response:
httplib:978:         if self.debuglevel > 0:
httplib:983:             response = self.response_class(self.sock, strict=self.strict,
httplib:984:                                            method=self._method)
httplib:330:         self.fp = sock.makefile('rb', 0)
eventlet.greenio:214:         return _fileobject(self.dup(), *args, **kw)
eventlet.greenio:207:         sock = self.fd.dup(*args, **kw)
socket:203:         return _socketobject(_sock=self._sock)
socket:181:         if _sock is None:
socket:183:         self._sock = _sock
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
eventlet.greenio:208:         set_nonblocking(sock)
eventlet.greenio:76:     try:
eventlet.greenio:77:         setblocking = fd.setblocking
eventlet.greenio:100:         setblocking(0)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:209:         newsock = type(self)(sock)
eventlet.greenio:115:         if isinstance(family_or_realsock, (int, long)):
eventlet.greenio:118:             fd = family_or_realsock
eventlet.greenio:119:             assert not args, args
eventlet.greenio:120:             assert not kwargs, kwargs
eventlet.greenio:123:         try:
eventlet.greenio:124:             self._timeout = fd.gettimeout() or socket.getdefaulttimeout()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:128:         set_nonblocking(fd)
eventlet.greenio:76:     try:
eventlet.greenio:77:         setblocking = fd.setblocking
eventlet.greenio:100:         setblocking(0)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:129:         self.fd = fd
eventlet.greenio:132:         self.act_non_blocking = False
eventlet.greenio:210:         newsock.settimeout(self.gettimeout())
eventlet.greenio:317:         return self._timeout
eventlet.greenio:301:         if howlong is None or howlong == _GLOBAL_DEFAULT_TIMEOUT:
eventlet.greenio:302:             self.setblocking(True)
eventlet.greenio:293:         if flag:
eventlet.greenio:294:             self.act_non_blocking = False
eventlet.greenio:295:             self._timeout = None
eventlet.greenio:303:             return
eventlet.greenio:211:         return newsock
socket:236:         self._sock = sock
socket:237:         self.mode = mode # Not actually used in this version
socket:238:         if bufsize < 0:
socket:240:         self.bufsize = bufsize
socket:241:         self.softspace = False
socket:245:         if bufsize == 0:
socket:246:             self._rbufsize = 1
socket:251:         self._wbufsize = bufsize
socket:256:         self._rbuf = StringIO()
socket:257:         self._wbuf = [] # A list of strings
socket:258:         self._wbuf_len = 0
socket:259:         self._close = close
httplib:331:         self.debuglevel = debuglevel
httplib:332:         self.strict = strict
httplib:333:         self._method = method
httplib:335:         self.msg = None
httplib:338:         self.version = _UNKNOWN # HTTP-Version
httplib:339:         self.status = _UNKNOWN  # Status-Code
httplib:340:         self.reason = _UNKNOWN  # Reason-Phrase
httplib:342:         self.chunked = _UNKNOWN         # is "chunked" being used?
httplib:343:         self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
httplib:344:         self.length = _UNKNOWN          # number of bytes left in response
httplib:345:         self.will_close = _UNKNOWN      # conn will close at end of response
httplib:986:         response.begin()
httplib:385:         if self.msg is not None:
httplib:390:         while True:
httplib:391:             version, status, reason = self._read_status()
httplib:349:         line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:399:                         break
socket:401:                 return "".join(buffers)
httplib:350:         if self.debuglevel > 0:
httplib:352:         if not line:
httplib:355:             raise BadStatusLine(line)
httplib:1199:         self.args = line,
httplib:1200:         self.line = line
httplib20_7_1:1159:             except (socket.error, httplib.HTTPException):
httplib20_7_1:1160:                 if i == 0:
httplib20_7_1:1161:                     conn.close()
httplib:723:         if self.sock:
httplib:724:             self.sock.close()   # close it manually... there may be other refs
eventlet.greenio:145:         attr = getattr(self.fd, name)
eventlet.greenio:146:         setattr(self, name, attr)
eventlet.greenio:147:         return attr
socket:188:         self._sock = _closedsocket()
socket:189:         dummy = self._sock._dummy
socket:190:         for method in _delegate_methods:
socket:191:             setattr(self, method, dummy)
socket:190:         for method in _delegate_methods:
socket:191:             setattr(self, method, dummy)
socket:190:         for method in _delegate_methods:
socket:191:             setattr(self, method, dummy)
socket:190:         for method in _delegate_methods:
socket:191:             setattr(self, method, dummy)
socket:190:         for method in _delegate_methods:
socket:191:             setattr(self, method, dummy)
socket:190:         for method in _delegate_methods:
socket:191:             setattr(self, method, dummy)
socket:190:         for method in _delegate_methods:
httplib:725:             self.sock = None
httplib:726:         if self.__response:
httplib:729:         self.__state = _CS_IDLE
httplib20_7_1:1162:                     conn.connect()
httplib20_7_1:765:         if self.proxy_info and socks is None:
httplib20_7_1:768:         msg = "getaddrinfo returns an empty list"
httplib20_7_1:769:         for res in socket.getaddrinfo(self.host, self.port, 0,
httplib20_7_1:770:                 socket.SOCK_STREAM):
httplib20_7_1:771:             af, socktype, proto, canonname, sa = res
httplib20_7_1:772:             try:
httplib20_7_1:773:                 if self.proxy_info and self.proxy_info.isgood():
httplib20_7_1:777:                     self.sock = socket.socket(af, socktype, proto)
eventlet.greenio:115:         if isinstance(family_or_realsock, (int, long)):
eventlet.greenio:116:             fd = _original_socket(family_or_realsock, *args, **kwargs)
socket:181:         if _sock is None:
socket:182:             _sock = _realsocket(family, type, proto)
socket:183:         self._sock = _sock
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
eventlet.greenio:123:         try:
eventlet.greenio:124:             self._timeout = fd.gettimeout() or socket.getdefaulttimeout()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:128:         set_nonblocking(fd)
eventlet.greenio:76:     try:
eventlet.greenio:77:         setblocking = fd.setblocking
eventlet.greenio:100:         setblocking(0)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:129:         self.fd = fd
eventlet.greenio:132:         self.act_non_blocking = False
httplib20_7_1:778:                     self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
eventlet.greenio:145:         attr = getattr(self.fd, name)
eventlet.greenio:146:         setattr(self, name, attr)
eventlet.greenio:147:         return attr
socket:1: # Wrapper module for _socket, providing some additional facilities
httplib20_7_1:780:                 if has_timeout(self.timeout):
httplib20_7_1:97:     if hasattr(socket, '_GLOBAL_DEFAULT_TIMEOUT'):
httplib20_7_1:98:         return (timeout is not None and timeout is not socket._GLOBAL_DEFAULT_TIMEOUT)
httplib20_7_1:783:                 if self.debuglevel > 0:
httplib20_7_1:786:                 self.sock.connect(sa)
eventlet.greenio:163:         if self.act_non_blocking:
eventlet.greenio:165:         fd = self.fd
eventlet.greenio:166:         if self.gettimeout() is None:
eventlet.greenio:317:         return self._timeout
eventlet.greenio:167:             while not socket_connect(fd, address):
eventlet.greenio:33:     err = descriptor.connect_ex(address)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:34:     if err in CONNECT_ERR:
eventlet.greenio:35:         return None
eventlet.greenio:168:                 trampoline(fd, write=True)
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:118:         elif write:
eventlet.hubs:119:             listener = hub.add(hub.WRITE, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:40:             mask |= WRITE_MASK | EXC_MASK
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
socket:275:         try:
socket:276:             self.close()
socket:266:         try:
socket:267:             if self._sock:
socket:268:                 self.flush()
socket:282:         if self._wbuf:
socket:270:             if self._close:
socket:272:             self._sock = None
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.timer:58:                 try:
eventlet.hubs.timer:59:                     del self.tpl
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:99:                     writers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.greenio:169:                 socket_checkerr(fd)
eventlet.greenio:41:     err = descriptor.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:42:     if err not in CONNECT_SUCCESS:
eventlet.greenio:167:             while not socket_connect(fd, address):
eventlet.greenio:33:     err = descriptor.connect_ex(address)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:34:     if err in CONNECT_ERR:
eventlet.greenio:36:     if err not in CONNECT_SUCCESS:
eventlet.greenio:38:     return descriptor
httplib20_7_1:794:             break
httplib20_7_1:795:         if not self.sock:
httplib20_7_1:1163:                     continue
httplib20_7_1:1120:         for i in range(2):
httplib20_7_1:1121:             try:
httplib20_7_1:1122:                 if conn.sock is None:
httplib20_7_1:1124:                 conn.request(method, request_uri, body, headers)
httplib:909:         try:
httplib:910:             self._send_request(method, url, body, headers)
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:921:         skips = {}
httplib:922:         if 'host' in header_names:
httplib:924:         if 'accept-encoding' in header_names:
httplib:925:             skips['skip_accept_encoding'] = 1
httplib:927:         self.putrequest(method, url, **skips)
httplib:789:         if self.__response and self.__response.isclosed():
httplib:811:         if self.__state == _CS_IDLE:
httplib:812:             self.__state = _CS_REQ_STARTED
httplib:817:         self._method = method
httplib:818:         if not url:
httplib:820:         str = '%s %s %s' % (method, url, self._http_vsn_str)
httplib:822:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:824:         if self._http_vsn == 11:
httplib:827:             if not skip_host:
httplib:842:                 netloc = ''
httplib:843:                 if url.startswith('http'):
httplib:846:                 if netloc:
httplib:853:                     try:
httplib:854:                         host_enc = self.host.encode("ascii")
httplib:857:                     if self.port == self.default_port:
httplib:858:                         self.putheader('Host', host_enc)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:870:             if not skip_accept_encoding:
httplib:883:             pass
httplib:929:         if body and ('content-length' not in header_names):
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:947:         self.endheaders()
httplib:899:         if self.__state == _CS_REQ_STARTED:
httplib:900:             self.__state = _CS_REQ_SENT
httplib:904:         self._send_output()
httplib:773:         self._buffer.extend(("", ""))
httplib:774:         msg = "\r\n".join(self._buffer)
httplib:775:         del self._buffer[:]
httplib:776:         self.send(msg)
httplib:733:         if self.sock is None:
httplib:744:         if self.debuglevel > 0:
httplib:746:         try:
httplib:747:             blocksize=8192
httplib:748:             if hasattr(str,'read') and not isinstance(str, array):
httplib:755:                 self.sock.sendall(str)
eventlet.greenio:283:         tail = self.send(data, flags)
eventlet.greenio:259:         fd = self.fd
eventlet.greenio:260:         if self.act_non_blocking:
eventlet.greenio:264:         total_sent = 0
eventlet.greenio:265:         len_data = len(data)
eventlet.greenio:267:         while 1:
eventlet.greenio:268:             try:
eventlet.greenio:269:                 total_sent += fd.send(data[total_sent:], flags)
eventlet.greenio:274:             if total_sent == len_data:
eventlet.greenio:275:                 break
eventlet.greenio:280:         return total_sent
eventlet.greenio:284:         len_data = len(data)
eventlet.greenio:285:         while tail < len_data:
httplib:949:         if body:
httplib20_7_1:1157:             try:
httplib20_7_1:1158:                 response = conn.getresponse()
httplib:956:         if self.__response and self.__response.isclosed():
httplib:975:         if self.__state != _CS_REQ_SENT or self.__response:
httplib:978:         if self.debuglevel > 0:
httplib:983:             response = self.response_class(self.sock, strict=self.strict,
httplib:984:                                            method=self._method)
httplib:330:         self.fp = sock.makefile('rb', 0)
eventlet.greenio:214:         return _fileobject(self.dup(), *args, **kw)
eventlet.greenio:207:         sock = self.fd.dup(*args, **kw)
socket:203:         return _socketobject(_sock=self._sock)
socket:181:         if _sock is None:
socket:183:         self._sock = _sock
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
eventlet.greenio:208:         set_nonblocking(sock)
eventlet.greenio:76:     try:
eventlet.greenio:77:         setblocking = fd.setblocking
eventlet.greenio:100:         setblocking(0)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:209:         newsock = type(self)(sock)
eventlet.greenio:115:         if isinstance(family_or_realsock, (int, long)):
eventlet.greenio:118:             fd = family_or_realsock
eventlet.greenio:119:             assert not args, args
eventlet.greenio:120:             assert not kwargs, kwargs
eventlet.greenio:123:         try:
eventlet.greenio:124:             self._timeout = fd.gettimeout() or socket.getdefaulttimeout()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:128:         set_nonblocking(fd)
eventlet.greenio:76:     try:
eventlet.greenio:77:         setblocking = fd.setblocking
eventlet.greenio:100:         setblocking(0)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:129:         self.fd = fd
eventlet.greenio:132:         self.act_non_blocking = False
eventlet.greenio:210:         newsock.settimeout(self.gettimeout())
eventlet.greenio:317:         return self._timeout
eventlet.greenio:301:         if howlong is None or howlong == _GLOBAL_DEFAULT_TIMEOUT:
eventlet.greenio:302:             self.setblocking(True)
eventlet.greenio:293:         if flag:
eventlet.greenio:294:             self.act_non_blocking = False
eventlet.greenio:295:             self._timeout = None
eventlet.greenio:303:             return
eventlet.greenio:211:         return newsock
socket:236:         self._sock = sock
socket:237:         self.mode = mode # Not actually used in this version
socket:238:         if bufsize < 0:
socket:240:         self.bufsize = bufsize
socket:241:         self.softspace = False
socket:245:         if bufsize == 0:
socket:246:             self._rbufsize = 1
socket:251:         self._wbufsize = bufsize
socket:256:         self._rbuf = StringIO()
socket:257:         self._wbuf = [] # A list of strings
socket:258:         self._wbuf_len = 0
socket:259:         self._close = close
httplib:331:         self.debuglevel = debuglevel
httplib:332:         self.strict = strict
httplib:333:         self._method = method
httplib:335:         self.msg = None
httplib:338:         self.version = _UNKNOWN # HTTP-Version
httplib:339:         self.status = _UNKNOWN  # Status-Code
httplib:340:         self.reason = _UNKNOWN  # Reason-Phrase
httplib:342:         self.chunked = _UNKNOWN         # is "chunked" being used?
httplib:343:         self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
httplib:344:         self.length = _UNKNOWN          # number of bytes left in response
httplib:345:         self.will_close = _UNKNOWN      # conn will close at end of response
httplib:986:         response.begin()
httplib:385:         if self.msg is not None:
httplib:390:         while True:
httplib:391:             version, status, reason = self._read_status()
httplib:349:         line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
eventlet.greenio:228:             except socket.error, e:
eventlet.greenio:229:                 if get_errno(e) in SOCKET_BLOCKING:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.greenio:230:                     pass
eventlet.greenio:235:             trampoline(fd,
eventlet.greenio:236:                 read=True,
eventlet.greenio:237:                 timeout=self.gettimeout(),
eventlet.greenio:317:         return self._timeout
eventlet.greenio:238:                 timeout_exc=socket.timeout("timed out"))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:350:         if self.debuglevel > 0:
httplib:352:         if not line:
httplib:356:         try:
httplib:357:             [version, status, reason] = line.split(None, 2)
httplib:366:         if not version.startswith('HTTP/'):
httplib:376:         try:
httplib:377:             status = int(status)
httplib:378:             if status < 100 or status > 999:
httplib:382:         return version, status, reason
httplib:392:             if status != CONTINUE:
httplib:393:                 break
httplib:402:         self.status = status
httplib:403:         self.reason = reason.strip()
httplib:404:         if version == 'HTTP/1.0':
httplib:406:         elif version.startswith('HTTP/1.'):
httplib:407:             self.version = 11   # use HTTP/1.1 code for HTTP/1.x where x>=1
httplib:413:         if self.version == 9:
httplib:420:         self.msg = HTTPMessage(self.fp, 0)
mimetools:25:         rfc822.Message.__init__(self, fp, seekable)
rfc822:90:         if seekable == 1:
rfc822:97:         self.fp = fp
rfc822:98:         self.seekable = seekable
rfc822:99:         self.startofheaders = None
rfc822:100:         self.startofbody = None
rfc822:102:         if self.seekable:
rfc822:108:         self.readheaders()
httplib:258:         self.dict = {}
httplib:259:         self.unixfrom = ''
httplib:260:         self.headers = hlist = []
httplib:261:         self.status = ''
httplib:262:         headerseen = ""
httplib:263:         firstline = 1
httplib:264:         startofline = unread = tell = None
httplib:265:         if hasattr(self.fp, 'unread'):
httplib:267:         elif self.seekable:
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:297:                 break
rfc822:110:         if self.seekable:
mimetools:27:                 self.getheader('content-transfer-encoding')
rfc822:292:         return self.dict.get(name.lower(), default)
mimetools:29:                 self.getheader('content-type')
rfc822:292:         return self.dict.get(name.lower(), default)
mimetools:30:         self.parsetype()
mimetools:34:         str = self.typeheader
mimetools:35:         if str is None:
mimetools:37:         if ';' in str:
mimetools:42:             self.plisttext = ''
mimetools:43:         fields = str.split('/')
mimetools:44:         for i in range(len(fields)):
mimetools:45:             fields[i] = fields[i].strip().lower()
mimetools:44:         for i in range(len(fields)):
mimetools:45:             fields[i] = fields[i].strip().lower()
mimetools:44:         for i in range(len(fields)):
mimetools:46:         self.type = '/'.join(fields)
mimetools:47:         self.maintype = fields[0]
mimetools:48:         self.subtype = '/'.join(fields[1:])
mimetools:31:         self.parseplist()
mimetools:51:         str = self.plisttext
mimetools:52:         self.plist = []
mimetools:53:         while str[:1] == ';':
httplib:421:         if self.debuglevel > 0:
httplib:426:         self.msg.fp = None
httplib:429:         tr_enc = self.msg.getheader('transfer-encoding')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:430:         if tr_enc and tr_enc.lower() == "chunked":
httplib:434:             self.chunked = 0
httplib:437:         self.will_close = self._check_close()
httplib:468:         conn = self.msg.getheader('connection')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:469:         if self.version == 11:
httplib:472:             conn = self.msg.getheader('connection')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:473:             if conn and "close" in conn.lower():
httplib:475:             return False
httplib:441:         length = self.msg.getheader('content-length')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:442:         if length and not self.chunked:
httplib:443:             try:
httplib:444:                 self.length = int(length)
httplib:448:                 if self.length < 0:  # ignore nonsensical negative lengths
httplib:454:         if (status == NO_CONTENT or status == NOT_MODIFIED or
httplib:455:             100 <= status < 200 or      # 1xx codes
httplib:456:             self._method == 'HEAD'):
httplib:462:         if not self.will_close and \
httplib:463:            not self.chunked and \
httplib:464:            self.length is None:
httplib:987:         assert response.will_close != _UNKNOWN
httplib:988:         self.__state = _CS_IDLE
httplib:990:         if response.will_close:
httplib:995:             self.__response = response
httplib:997:         return response
httplib20_7_1:1167:                 content = ""
httplib20_7_1:1168:                 if method == "HEAD":
httplib20_7_1:1171:                     content = response.read()
httplib:514:         if self.fp is None:
httplib:517:         if self.chunked:
httplib:520:         if amt is None:
httplib:522:             if self.length is None:
httplib:525:                 s = self._safe_read(self.length)
httplib:613:         s = []
httplib:614:         while amt > 0:
httplib:615:             chunk = self.fp.read(min(amt, MAXAMOUNT))
socket:319:         rbufsize = max(self._rbufsize, self.default_bufsize)
socket:323:         buf = self._rbuf
socket:324:         buf.seek(0, 2)  # seek end
socket:325:         if size < 0:
socket:336:             buf_len = buf.tell()
socket:337:             if buf_len >= size:
socket:345:             self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:346:             while True:
socket:347:                 left = size - buf_len
socket:353:                 data = self._sock.recv(left)
eventlet.greenio:222:         fd = self.fd
eventlet.greenio:223:         if self.act_non_blocking:
eventlet.greenio:225:         while True:
eventlet.greenio:226:             try:
eventlet.greenio:227:                 return fd.recv(buflen, flags)
socket:354:                 if not data:
socket:356:                 n = len(data)
socket:357:                 if n == size and not buf_len:
socket:363:                     return data
httplib:616:             if not chunk:
httplib:618:             s.append(chunk)
httplib:619:             amt -= len(chunk)
httplib:614:         while amt > 0:
httplib:620:         return ''.join(s)
httplib:526:                 self.length = 0
httplib:527:             self.close()        # we read everything
httplib:498:         if self.fp:
httplib:499:             self.fp.close()
socket:266:         try:
socket:267:             if self._sock:
socket:268:                 self.flush()
socket:282:         if self._wbuf:
socket:270:             if self._close:
socket:272:             self._sock = None
httplib:500:             self.fp = None
socket:275:         try:
socket:276:             self.close()
socket:266:         try:
socket:267:             if self._sock:
socket:270:             if self._close:
socket:272:             self._sock = None
httplib:528:             return s
httplib20_7_1:1172:                 response = Response(response)
httplib20_7_1:1488:         if isinstance(info, httplib.HTTPResponse):
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib:629:         if self.msg is None:
httplib:631:         return self.msg.items()
rfc822:459:         return self.dict.items()
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1491:             self.status = info.status
httplib20_7_1:1492:             self['status'] = str(self.status)
httplib20_7_1:1493:             self.reason = info.reason
httplib20_7_1:1494:             self.version = info.version
httplib20_7_1:1173:                 if method != "HEAD":
httplib20_7_1:1174:                     content = _decompressContent(response, content)
httplib20_7_1:379:     content = new_content
httplib20_7_1:380:     try:
httplib20_7_1:381:         encoding = response.get('content-encoding', None)
httplib20_7_1:382:         if encoding in ['gzip', 'deflate']:
httplib20_7_1:383:             if encoding == 'gzip':
httplib20_7_1:384:                 content = gzip.GzipFile(fileobj=StringIO.StringIO(new_content)).read()
StringIO:56:         if not isinstance(buf, basestring):
StringIO:58:         self.buf = buf
StringIO:59:         self.len = len(buf)
StringIO:60:         self.buflist = []
StringIO:61:         self.pos = 0
StringIO:62:         self.closed = False
StringIO:63:         self.softspace = 0
gzip:76:         if mode and 'b' not in mode:
gzip:78:         if fileobj is None:
gzip:80:         if filename is None:
gzip:81:             if hasattr(fileobj, 'name'): filename = fileobj.name
gzip:82:             else: filename = ''
gzip:83:         if mode is None:
gzip:84:             if hasattr(fileobj, 'mode'): mode = fileobj.mode
gzip:85:             else: mode = 'rb'
gzip:87:         if mode[0:1] == 'r':
gzip:88:             self.mode = READ
gzip:90:             self._new_member = True
gzip:91:             self.extrabuf = ""
gzip:92:             self.extrasize = 0
gzip:93:             self.name = filename
gzip:95:             self.min_readsize = 100
gzip:108:         self.fileobj = fileobj
gzip:109:         self.offset = 0
gzip:111:         if self.mode == WRITE:
gzip:201:         if self.mode != READ:
gzip:205:         if self.extrasize <= 0 and self.fileobj is None:
gzip:208:         readsize = 1024
gzip:209:         if size < 0:        # get the whole thing
gzip:210:             try:
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:247:             pos = self.fileobj.tell()   # Save current position
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:248:             self.fileobj.seek(0, 2)     # Seek to end of file
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:111:             pos += self.len
StringIO:112:         self.pos = max(0, pos)
gzip:249:             if pos == self.fileobj.tell():
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:252:                 self.fileobj.seek( pos ) # Return to original position
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:112:         self.pos = max(0, pos)
gzip:254:             self._init_read()
gzip:150:         self.crc = zlib.crc32("") & 0xffffffffL
gzip:151:         self.size = 0
gzip:255:             self._read_gzip_header()
gzip:154:         magic = self.fileobj.read(2)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:155:         if magic != '\037\213':
gzip:157:         method = ord( self.fileobj.read(1) )
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:158:         if method != 8:
gzip:160:         flag = ord( self.fileobj.read(1) )
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:164:         self.fileobj.read(6)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:166:         if flag & FEXTRA:
gzip:171:         if flag & FNAME:
gzip:177:         if flag & FCOMMENT:
gzip:183:         if flag & FHCRC:
gzip:256:             self.decompress = zlib.decompressobj(-zlib.MAX_WBITS)
gzip:257:             self._new_member = False
gzip:260:         buf = self.fileobj.read(size)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:265:         if buf == "":
gzip:271:         uncompress = self.decompress.decompress(buf)
gzip:272:         self._add_read_data( uncompress )
gzip:288:         self.crc = zlib.crc32(data, self.crc) & 0xffffffffL
gzip:289:         self.extrabuf = self.extrabuf + data
gzip:290:         self.extrasize = self.extrasize + len(data)
gzip:291:         self.size = self.size + len(data)
gzip:274:         if self.decompress.unused_data != "":
gzip:213:                     readsize = min(self.max_read_chunk, readsize * 2)
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:260:         buf = self.fileobj.read(size)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:265:         if buf == "":
gzip:271:         uncompress = self.decompress.decompress(buf)
gzip:272:         self._add_read_data( uncompress )
gzip:288:         self.crc = zlib.crc32(data, self.crc) & 0xffffffffL
gzip:289:         self.extrabuf = self.extrabuf + data
gzip:290:         self.extrasize = self.extrasize + len(data)
gzip:291:         self.size = self.size + len(data)
gzip:274:         if self.decompress.unused_data != "":
gzip:213:                     readsize = min(self.max_read_chunk, readsize * 2)
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:260:         buf = self.fileobj.read(size)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:265:         if buf == "":
gzip:271:         uncompress = self.decompress.decompress(buf)
gzip:272:         self._add_read_data( uncompress )
gzip:288:         self.crc = zlib.crc32(data, self.crc) & 0xffffffffL
gzip:289:         self.extrabuf = self.extrabuf + data
gzip:290:         self.extrasize = self.extrasize + len(data)
gzip:291:         self.size = self.size + len(data)
gzip:274:         if self.decompress.unused_data != "":
gzip:280:             self.fileobj.seek( -len(self.decompress.unused_data)+8, 1)
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:109:             pos += self.pos
StringIO:112:         self.pos = max(0, pos)
gzip:284:             self._read_eof()
gzip:299:         self.fileobj.seek(-8, 1)
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:109:             pos += self.pos
StringIO:112:         self.pos = max(0, pos)
gzip:300:         crc32 = read32(self.fileobj)
gzip:24:     return struct.unpack("<I", input.read(4))[0]
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:301:         isize = read32(self.fileobj)  # may exceed 2GB
gzip:24:     return struct.unpack("<I", input.read(4))[0]
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:302:         if crc32 != self.crc:
gzip:305:         elif isize != (self.size & 0xffffffffL):
gzip:285:             self._new_member = True
gzip:213:                     readsize = min(self.max_read_chunk, readsize * 2)
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:247:             pos = self.fileobj.tell()   # Save current position
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:248:             self.fileobj.seek(0, 2)     # Seek to end of file
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:111:             pos += self.len
StringIO:112:         self.pos = max(0, pos)
gzip:249:             if pos == self.fileobj.tell():
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:250:                 raise EOFError, "Reached EOF"
gzip:214:             except EOFError:
gzip:215:                 size = self.extrasize
gzip:225:         chunk = self.extrabuf[:size]
gzip:226:         self.extrabuf = self.extrabuf[size:]
gzip:227:         self.extrasize = self.extrasize - size
gzip:229:         self.offset += size
gzip:230:         return chunk
gzip:324:         try:
gzip:325:             if (self.myfileobj is None and
gzip:326:                 self.fileobj is None):
gzip:330:         self.close()
gzip:309:         if self.fileobj is None:
gzip:311:         if self.mode == WRITE:
gzip:317:         elif self.mode == READ:
gzip:318:             self.fileobj = None
gzip:319:         if self.myfileobj:
httplib20_7_1:385:             if encoding == 'deflate':
httplib20_7_1:387:             response['content-length'] = str(len(content))
httplib20_7_1:389:             response['-content-encoding'] = response['content-encoding']
httplib20_7_1:390:             del response['content-encoding']
httplib20_7_1:394:     return content
httplib20_7_1:1175:             break
httplib20_7_1:1176:         return (response, content)
httplib20_7_1:1190:         if auth:
httplib20_7_1:1196:         if response.status == 401:
httplib20_7_1:1205:         if (self.follow_all_redirects or (method in ["GET", "HEAD"]) or response.status == 303):
httplib20_7_1:1206:             if self.follow_redirects and response.status in [300, 301, 302, 303, 307]:
httplib20_7_1:1240:             elif response.status in [200, 203] and method in ["GET", "HEAD"]:
httplib20_7_1:1242:                 if not response.has_key('content-location'):
httplib20_7_1:1243:                     response['content-location'] = absolute_uri
httplib20_7_1:1244:                 _updateCache(headers, response, content, self.cache, cachekey)
httplib20_7_1:397:     if cachekey:
httplib20_7_1:1246:         return (response, content)
httplib20_7_1:1464:         return (response, content)
contextlib:21:         if type is None:
contextlib:22:             try:
contextlib:23:                 self.gen.next()
eventlet.pools:19:     ...
eventlet.pools:129:         if self.current_size > self.max_size:
eventlet.pools:133:         if self.waiting():
eventlet.pools:161:         return max(0, self.channel.getting() - self.channel.putting())
eventlet.queue:202:         return len(self.getters)
eventlet.queue:197:         return len(self.putters)
eventlet.pools:136:             if self.order_as_stack:
eventlet.pools:139:                 self.free_items.append(item)
contextlib:24:             except StopIteration:
contextlib:25:                 return
work:62:         return content
pool:435:         try:
pool:436:             self.selectsharesResponse( value, server)
pool:195:         server = self.servers[server_name]
pool:196:         if server['role'] not in self.api_pull:
pool:199:         if server['api_method'] == 'json':
pool:224:         elif server['api_method'] == 'json_ec':
pool:233:         elif server['api_method'] == 're':
pool:234:             output = re.search(server['api_key'],response)
re:142:     return _compile(pattern, flags).search(string)
re:231:     cachekey = (type(key[0]),) + key
re:232:     p = _cache.get(cachekey)
re:233:     if p is not None:
re:234:         return p
pool:235:             if output == None:
pool:237:             if 'api_group' in server:
pool:240:                 output = output.group(1)
pool:241:             if 'api_index' in server:
pool:248:             if 'api_strip' in server:
pool:249:                 strip_str = server['api_strip'][1:-1]
pool:250:                 output = output.replace(strip_str,'')
pool:251:             round_shares = int(output)
pool:252:             if round_shares == None:
pool:254:             self.UpdateShares(server_name,round_shares)
pool:133:         with self.lock:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:68:             self._waiters.add(greenthread.getcurrent())
eventlet.semaphore:69:             try:
eventlet.semaphore:70:                 while self.counter <= 0:
eventlet.semaphore:71:                     hubs.get_hub().switch()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.greenthread:191:         try:
eventlet.greenthread:192:             result = function(*args, **kwargs)
pool:430:         if self.servers[server]['role'] not in self.api_pull:
pool:432:         info = self.servers[server]
pool:433:         self.bitHopper.scheduler.update_api_server(server)
scheduler:136:         return
pool:434:         value = self.bitHopper.work.get(info['api_address'])
work:53:         header = {'User-Agent':'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))'}
work:54:         with self.get_http(url) as http:
work:26:         if address not in self.connect_pool:
work:28:         return self.connect_pool[address].item()
contextlib:83:         return GeneratorContextManager(func(*args, **kwds))
contextlib:12:         self.gen = gen
contextlib:15:         try:
contextlib:16:             return self.gen.next()
eventlet.pools:15:     >>> from eventlet import pools
eventlet.pools:114:         if self.free_items:
eventlet.pools:115:             return self.free_items.popleft()
eventlet.pools:16:     >>> pool = pools.TokenPool(max_size=4)
eventlet.pools:17:     >>> with pool.item() as obj:
work:55:             try:
work:56:                 content = http.request( url, 'GET', headers=header)[1] # Returns response dict and content str
httplib20_7_1:1277:         try:
httplib20_7_1:1278:             if headers is None:
httplib20_7_1:1281:                 headers = self._normalize_headers(headers)
httplib20_7_1:1249:         return _normalize_headers(headers)
httplib20_7_1:249:     return dict([ (key.lower(), NORMALIZE_SPACE.sub(value, ' ').strip())  for (key, value) in headers.iteritems()])
httplib20_7_1:249:     return dict([ (key.lower(), NORMALIZE_SPACE.sub(value, ' ').strip())  for (key, value) in headers.iteritems()])
httplib20_7_1:1283:             if not headers.has_key('user-agent'):
httplib20_7_1:1286:             uri = iri2uri(uri)
httplib20_7_1.iri2uri:69:     if isinstance(uri ,unicode):
httplib20_7_1.iri2uri:77:     return uri
httplib20_7_1:1288:             (scheme, authority, request_uri, defrag_uri) = urlnorm(uri)
httplib20_7_1:201:     (scheme, authority, path, query, fragment) = parse_uri(uri)
httplib20_7_1:197:     groups = URI.match(uri).groups()
httplib20_7_1:198:     return (groups[1], groups[3], groups[4], groups[6], groups[8])
httplib20_7_1:202:     if not scheme or not authority:
httplib20_7_1:204:     authority = authority.lower()
httplib20_7_1:205:     scheme = scheme.lower()
httplib20_7_1:206:     if not path:
httplib20_7_1:210:     request_uri = query and "?".join([path, query]) or path
httplib20_7_1:211:     scheme = scheme.lower()
httplib20_7_1:212:     defrag_uri = scheme + "://" + authority + request_uri
httplib20_7_1:213:     return scheme, authority, request_uri, defrag_uri
httplib20_7_1:1289:             domain_port = authority.split(":")[0:2]
httplib20_7_1:1290:             if len(domain_port) == 2 and domain_port[1] == '443' and scheme == 'http':
httplib20_7_1:1294:             conn_key = scheme+":"+authority
httplib20_7_1:1295:             if conn_key in self.connections:
httplib20_7_1:1296:                 conn = self.connections[conn_key]
httplib20_7_1:1323:             if 'range' not in headers and 'accept-encoding' not in headers:
httplib20_7_1:1324:                 headers['accept-encoding'] = 'gzip, deflate'
httplib20_7_1:1326:             info = email.Message.Message()
email.message:106:         self._headers = []
email.message:107:         self._unixfrom = None
email.message:108:         self._payload = None
email.message:109:         self._charset = None
email.message:111:         self.preamble = self.epilogue = None
email.message:112:         self.defects = []
email.message:114:         self._default_type = 'text/plain'
httplib20_7_1:1327:             cached_value = None
httplib20_7_1:1328:             if self.cache:
httplib20_7_1:1348:                 cachekey = None
httplib20_7_1:1350:             if method in self.optimistic_concurrency_methods and self.cache and info.has_key('etag') and not self.ignore_etag and 'if-match' not in headers:
httplib20_7_1:1354:             if method not in ["GET", "HEAD"] and self.cache and cachekey:
httplib20_7_1:1360:             if method in ['GET', 'HEAD'] and 'vary' in info:
email.message:313:         return name.lower() in [k.lower() for k, v in self._headers]
httplib20_7_1:1370:             if cached_value and method in ["GET", "HEAD"] and self.cache and 'range' not in headers:
httplib20_7_1:1430:                 cc = _parse_cache_control(headers)
httplib20_7_1:252:     retval = {}
httplib20_7_1:253:     if headers.has_key('cache-control'):
httplib20_7_1:258:     return retval
httplib20_7_1:1431:                 if cc.has_key('only-if-cached'):
httplib20_7_1:1436:                     (response, content) = self._request(conn, authority, uri, request_uri, method, body, headers, redirections, cachekey)
httplib20_7_1:1183:         auths = [(auth.depth(request_uri), auth) for auth in self.authorizations if auth.inscope(host, request_uri)]
httplib20_7_1:1184:         auth = auths and sorted(auths)[0][1] or None
httplib20_7_1:1185:         if auth:
httplib20_7_1:1188:         (response, content) = self._conn_request(conn, request_uri, method, body, headers)
httplib20_7_1:1120:         for i in range(2):
httplib20_7_1:1121:             try:
httplib20_7_1:1122:                 if conn.sock is None:
httplib20_7_1:1124:                 conn.request(method, request_uri, body, headers)
httplib:909:         try:
httplib:910:             self._send_request(method, url, body, headers)
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:921:         skips = {}
httplib:922:         if 'host' in header_names:
httplib:924:         if 'accept-encoding' in header_names:
httplib:925:             skips['skip_accept_encoding'] = 1
httplib:927:         self.putrequest(method, url, **skips)
httplib:789:         if self.__response and self.__response.isclosed():
httplib:509:         return self.fp is None
httplib:790:             self.__response = None
httplib:811:         if self.__state == _CS_IDLE:
httplib:812:             self.__state = _CS_REQ_STARTED
httplib:817:         self._method = method
httplib:818:         if not url:
httplib:820:         str = '%s %s %s' % (method, url, self._http_vsn_str)
httplib:822:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:824:         if self._http_vsn == 11:
httplib:827:             if not skip_host:
httplib:842:                 netloc = ''
httplib:843:                 if url.startswith('http'):
httplib:846:                 if netloc:
httplib:853:                     try:
httplib:854:                         host_enc = self.host.encode("ascii")
httplib:857:                     if self.port == self.default_port:
httplib:858:                         self.putheader('Host', host_enc)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:870:             if not skip_accept_encoding:
httplib:883:             pass
httplib:929:         if body and ('content-length' not in header_names):
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:947:         self.endheaders()
httplib:899:         if self.__state == _CS_REQ_STARTED:
httplib:900:             self.__state = _CS_REQ_SENT
httplib:904:         self._send_output()
httplib:773:         self._buffer.extend(("", ""))
httplib:774:         msg = "\r\n".join(self._buffer)
httplib:775:         del self._buffer[:]
httplib:776:         self.send(msg)
httplib:733:         if self.sock is None:
httplib:744:         if self.debuglevel > 0:
httplib:746:         try:
httplib:747:             blocksize=8192
httplib:748:             if hasattr(str,'read') and not isinstance(str, array):
httplib:755:                 self.sock.sendall(str)
eventlet.green.ssl:123:         if self._sslobj:
eventlet.green.ssl:124:             if flags != 0:
eventlet.green.ssl:128:             amount = len(data)
eventlet.green.ssl:129:             count = 0
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:131:                 v = self.send(data[count:])
eventlet.green.ssl:105:         if self._sslobj:
eventlet.green.ssl:106:             return self._call_trampolining(
eventlet.green.ssl:107:                 super(GreenSSLSocket, self).send, data, flags)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:167:         if self._sslobj:
ssl:168:             if flags != 0:
ssl:172:             while True:
ssl:173:                 try:
ssl:174:                     v = self._sslobj.write(data)
ssl:183:                     return v
eventlet.green.ssl:132:                 count += v
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:133:             return amount
httplib:949:         if body:
httplib20_7_1:1157:             try:
httplib20_7_1:1158:                 response = conn.getresponse()
httplib:956:         if self.__response and self.__response.isclosed():
httplib:975:         if self.__state != _CS_REQ_SENT or self.__response:
httplib:978:         if self.debuglevel > 0:
httplib:983:             response = self.response_class(self.sock, strict=self.strict,
httplib:984:                                            method=self._method)
httplib:330:         self.fp = sock.makefile('rb', 0)
ssl:335:         self._makefile_refs += 1
ssl:336:         return _fileobject(self, mode, bufsize)
socket:236:         self._sock = sock
socket:237:         self.mode = mode # Not actually used in this version
socket:238:         if bufsize < 0:
socket:240:         self.bufsize = bufsize
socket:241:         self.softspace = False
socket:245:         if bufsize == 0:
socket:246:             self._rbufsize = 1
socket:251:         self._wbufsize = bufsize
socket:256:         self._rbuf = StringIO()
socket:257:         self._wbuf = [] # A list of strings
socket:258:         self._wbuf_len = 0
socket:259:         self._close = close
httplib:331:         self.debuglevel = debuglevel
httplib:332:         self.strict = strict
httplib:333:         self._method = method
httplib:335:         self.msg = None
httplib:338:         self.version = _UNKNOWN # HTTP-Version
httplib:339:         self.status = _UNKNOWN  # Status-Code
httplib:340:         self.reason = _UNKNOWN  # Reason-Phrase
httplib:342:         self.chunked = _UNKNOWN         # is "chunked" being used?
httplib:343:         self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
httplib:344:         self.length = _UNKNOWN          # number of bytes left in response
httplib:345:         self.will_close = _UNKNOWN      # conn will close at end of response
httplib:986:         response.begin()
httplib:385:         if self.msg is not None:
httplib:390:         while True:
httplib:391:             version, status, reason = self._read_status()
httplib:349:         line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
ssl:137:         except SSLError, x:
ssl:138:             if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs:
ssl:139:                 return ''
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:399:                         break
socket:401:                 return "".join(buffers)
httplib:350:         if self.debuglevel > 0:
httplib:352:         if not line:
httplib:355:             raise BadStatusLine(line)
httplib:1199:         self.args = line,
httplib:1200:         self.line = line
httplib20_7_1:1159:             except (socket.error, httplib.HTTPException):
httplib20_7_1:1160:                 if i == 0:
httplib20_7_1:1161:                     conn.close()
httplib:723:         if self.sock:
httplib:724:             self.sock.close()   # close it manually... there may be other refs
ssl:283:         if self._makefile_refs < 1:
ssl:287:             self._makefile_refs -= 1
httplib:725:             self.sock = None
httplib:726:         if self.__response:
httplib:729:         self.__state = _CS_IDLE
httplib20_7_1:1162:                     conn.connect()
httplib20_7_1:874:         msg = "getaddrinfo returns an empty list"
httplib20_7_1:875:         for family, socktype, proto, canonname, sockaddr in socket.getaddrinfo(
httplib20_7_1:876:             self.host, self.port, 0, socket.SOCK_STREAM):
httplib20_7_1:877:             try:
httplib20_7_1:878:                 if self.proxy_info and self.proxy_info.isgood():
httplib20_7_1:882:                     sock = socket.socket(family, socktype, proto)
eventlet.greenio:115:         if isinstance(family_or_realsock, (int, long)):
eventlet.greenio:116:             fd = _original_socket(family_or_realsock, *args, **kwargs)
socket:181:         if _sock is None:
socket:182:             _sock = _realsocket(family, type, proto)
socket:183:         self._sock = _sock
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
eventlet.greenio:123:         try:
eventlet.greenio:124:             self._timeout = fd.gettimeout() or socket.getdefaulttimeout()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:128:         set_nonblocking(fd)
eventlet.greenio:76:     try:
eventlet.greenio:77:         setblocking = fd.setblocking
eventlet.greenio:100:         setblocking(0)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:129:         self.fd = fd
eventlet.greenio:132:         self.act_non_blocking = False
httplib20_7_1:883:                     sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
eventlet.greenio:145:         attr = getattr(self.fd, name)
eventlet.greenio:146:         setattr(self, name, attr)
eventlet.greenio:147:         return attr
socket:1: # Wrapper module for _socket, providing some additional facilities
httplib20_7_1:885:                 if has_timeout(self.timeout):
httplib20_7_1:97:     if hasattr(socket, '_GLOBAL_DEFAULT_TIMEOUT'):
httplib20_7_1:98:         return (timeout is not None and timeout is not socket._GLOBAL_DEFAULT_TIMEOUT)
httplib20_7_1:887:                 sock.connect((self.host, self.port))
eventlet.greenio:163:         if self.act_non_blocking:
eventlet.greenio:165:         fd = self.fd
eventlet.greenio:166:         if self.gettimeout() is None:
eventlet.greenio:317:         return self._timeout
eventlet.greenio:167:             while not socket_connect(fd, address):
eventlet.greenio:33:     err = descriptor.connect_ex(address)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:34:     if err in CONNECT_ERR:
eventlet.greenio:35:         return None
eventlet.greenio:168:                 trampoline(fd, write=True)
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:118:         elif write:
eventlet.hubs:119:             listener = hub.add(hub.WRITE, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:40:             mask |= WRITE_MASK | EXC_MASK
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
socket:275:         try:
socket:276:             self.close()
socket:266:         try:
socket:267:             if self._sock:
socket:268:                 self.flush()
socket:282:         if self._wbuf:
socket:270:             if self._close:
socket:272:             self._sock = None
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.timer:58:                 try:
eventlet.hubs.timer:59:                     del self.tpl
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:99:                     writers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.greenio:169:                 socket_checkerr(fd)
eventlet.greenio:41:     err = descriptor.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:42:     if err not in CONNECT_SUCCESS:
eventlet.greenio:167:             while not socket_connect(fd, address):
eventlet.greenio:33:     err = descriptor.connect_ex(address)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:34:     if err in CONNECT_ERR:
eventlet.greenio:36:     if err not in CONNECT_SUCCESS:
eventlet.greenio:38:     return descriptor
httplib20_7_1:888:                 self.sock =_ssl_wrap_socket(
httplib20_7_1:889:                     sock, self.key_file, self.cert_file,
httplib20_7_1:890:                     self.disable_ssl_certificate_validation, self.ca_certs)
httplib20_7_1:68:         if disable_validation:
httplib20_7_1:69:             cert_reqs = ssl.CERT_NONE
httplib20_7_1:75:         return ssl.wrap_socket(sock, keyfile=key_file, certfile=cert_file,
httplib20_7_1:76:                                cert_reqs=cert_reqs, ca_certs=ca_certs)
eventlet.green.ssl:285:     return GreenSSLSocket(sock, *a, **kw)
eventlet.green.ssl:41:         if not isinstance(sock, GreenSocket):
eventlet.green.ssl:44:         self.act_non_blocking = sock.act_non_blocking
eventlet.green.ssl:45:         self._timeout = sock.gettimeout()
eventlet.greenio:317:         return self._timeout
eventlet.green.ssl:46:         super(GreenSSLSocket, self).__init__(sock.fd, *args, **kw)
ssl:92:         socket.__init__(self, _sock=sock._sock)
socket:181:         if _sock is None:
socket:183:         self._sock = _sock
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
ssl:94:         self.send = lambda data, flags=0: SSLSocket.send(self, data, flags)
ssl:95:         self.sendto = lambda data, addr, flags=0: SSLSocket.sendto(self, data, addr, flags)
ssl:96:         self.recv = lambda buflen=1024, flags=0: SSLSocket.recv(self, buflen, flags)
ssl:97:         self.recvfrom = lambda addr, buflen=1024, flags=0: SSLSocket.recvfrom(self, addr, buflen, flags)
ssl:98:         self.recv_into = lambda buffer, nbytes=None, flags=0: SSLSocket.recv_into(self, buffer, nbytes, flags)
ssl:99:         self.recvfrom_into = lambda buffer, nbytes=None, flags=0: SSLSocket.recvfrom_into(self, buffer, nbytes, flags)
ssl:101:         if certfile and not keyfile:
ssl:104:         try:
ssl:105:             socket.getpeername(self)
socket:1: # Wrapper module for _socket, providing some additional facilities
ssl:111:             self._sslobj = _ssl.sslwrap(self._sock, server_side,
ssl:112:                                         keyfile, certfile,
ssl:113:                                         cert_reqs, ssl_version, ca_certs)
ssl:114:             if do_handshake_on_connect:
ssl:115:                 timeout = self.gettimeout()
eventlet.green.ssl:61:         return self._timeout
ssl:116:                 try:
ssl:117:                     self.settimeout(None)
eventlet.green.ssl:58:         self._timeout = timeout
ssl:118:                     self.do_handshake()
eventlet.green.ssl:192:         return self._call_trampolining(
eventlet.green.ssl:193:             super(GreenSSLSocket, self).do_handshake)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
ssl:120:                     self.settimeout(timeout)
eventlet.green.ssl:58:         self._timeout = timeout
ssl:121:         self.keyfile = keyfile
ssl:122:         self.certfile = certfile
ssl:123:         self.cert_reqs = cert_reqs
ssl:124:         self.ssl_version = ssl_version
ssl:125:         self.ca_certs = ca_certs
ssl:126:         self.do_handshake_on_connect = do_handshake_on_connect
ssl:127:         self.suppress_ragged_eofs = suppress_ragged_eofs
ssl:128:         self._makefile_refs = 0
eventlet.green.ssl:51:         try:
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
httplib20_7_1:891:                 if self.debuglevel > 0:
httplib20_7_1:893:                 if not self.disable_ssl_certificate_validation:
httplib20_7_1:923:             break
httplib20_7_1:924:         if not self.sock:
httplib20_7_1:1163:                     continue
httplib20_7_1:1120:         for i in range(2):
httplib20_7_1:1121:             try:
httplib20_7_1:1122:                 if conn.sock is None:
httplib20_7_1:1124:                 conn.request(method, request_uri, body, headers)
httplib:909:         try:
httplib:910:             self._send_request(method, url, body, headers)
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:921:         skips = {}
httplib:922:         if 'host' in header_names:
httplib:924:         if 'accept-encoding' in header_names:
httplib:925:             skips['skip_accept_encoding'] = 1
httplib:927:         self.putrequest(method, url, **skips)
httplib:789:         if self.__response and self.__response.isclosed():
httplib:811:         if self.__state == _CS_IDLE:
httplib:812:             self.__state = _CS_REQ_STARTED
httplib:817:         self._method = method
httplib:818:         if not url:
httplib:820:         str = '%s %s %s' % (method, url, self._http_vsn_str)
httplib:822:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:824:         if self._http_vsn == 11:
httplib:827:             if not skip_host:
httplib:842:                 netloc = ''
httplib:843:                 if url.startswith('http'):
httplib:846:                 if netloc:
httplib:853:                     try:
httplib:854:                         host_enc = self.host.encode("ascii")
httplib:857:                     if self.port == self.default_port:
httplib:858:                         self.putheader('Host', host_enc)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:870:             if not skip_accept_encoding:
httplib:883:             pass
httplib:929:         if body and ('content-length' not in header_names):
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:947:         self.endheaders()
httplib:899:         if self.__state == _CS_REQ_STARTED:
httplib:900:             self.__state = _CS_REQ_SENT
httplib:904:         self._send_output()
httplib:773:         self._buffer.extend(("", ""))
httplib:774:         msg = "\r\n".join(self._buffer)
httplib:775:         del self._buffer[:]
httplib:776:         self.send(msg)
httplib:733:         if self.sock is None:
httplib:744:         if self.debuglevel > 0:
httplib:746:         try:
httplib:747:             blocksize=8192
httplib:748:             if hasattr(str,'read') and not isinstance(str, array):
httplib:755:                 self.sock.sendall(str)
eventlet.green.ssl:123:         if self._sslobj:
eventlet.green.ssl:124:             if flags != 0:
eventlet.green.ssl:128:             amount = len(data)
eventlet.green.ssl:129:             count = 0
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:131:                 v = self.send(data[count:])
eventlet.green.ssl:105:         if self._sslobj:
eventlet.green.ssl:106:             return self._call_trampolining(
eventlet.green.ssl:107:                 super(GreenSSLSocket, self).send, data, flags)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:167:         if self._sslobj:
ssl:168:             if flags != 0:
ssl:172:             while True:
ssl:173:                 try:
ssl:174:                     v = self._sslobj.write(data)
ssl:183:                     return v
eventlet.green.ssl:132:                 count += v
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:133:             return amount
httplib:949:         if body:
httplib20_7_1:1157:             try:
httplib20_7_1:1158:                 response = conn.getresponse()
httplib:956:         if self.__response and self.__response.isclosed():
httplib:975:         if self.__state != _CS_REQ_SENT or self.__response:
httplib:978:         if self.debuglevel > 0:
httplib:983:             response = self.response_class(self.sock, strict=self.strict,
httplib:984:                                            method=self._method)
httplib:330:         self.fp = sock.makefile('rb', 0)
ssl:335:         self._makefile_refs += 1
ssl:336:         return _fileobject(self, mode, bufsize)
socket:236:         self._sock = sock
socket:237:         self.mode = mode # Not actually used in this version
socket:238:         if bufsize < 0:
socket:240:         self.bufsize = bufsize
socket:241:         self.softspace = False
socket:245:         if bufsize == 0:
socket:246:             self._rbufsize = 1
socket:251:         self._wbufsize = bufsize
socket:256:         self._rbuf = StringIO()
socket:257:         self._wbuf = [] # A list of strings
socket:258:         self._wbuf_len = 0
socket:259:         self._close = close
httplib:331:         self.debuglevel = debuglevel
httplib:332:         self.strict = strict
httplib:333:         self._method = method
httplib:335:         self.msg = None
httplib:338:         self.version = _UNKNOWN # HTTP-Version
httplib:339:         self.status = _UNKNOWN  # Status-Code
httplib:340:         self.reason = _UNKNOWN  # Reason-Phrase
httplib:342:         self.chunked = _UNKNOWN         # is "chunked" being used?
httplib:343:         self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
httplib:344:         self.length = _UNKNOWN          # number of bytes left in response
httplib:345:         self.will_close = _UNKNOWN      # conn will close at end of response
httplib:986:         response.begin()
httplib:385:         if self.msg is not None:
httplib:390:         while True:
httplib:391:             version, status, reason = self._read_status()
httplib:349:         line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
ssl:137:         except SSLError, x:
ssl:138:             if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs:
ssl:141:                 raise
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.hubs.timer:67:         if not self.called:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:74:         self.counter -= 1
eventlet.semaphore:75:         return True
threading:124:         if rc:
threading:125:             self.__owner = me
threading:126:             self.__count = 1
threading:128:                 self._note("%s.acquire(%s): initial success", self, blocking)
threading:65:             if self.__verbose:
threading:132:         return rc
threading:150:         self.release()
threading:137:         if self.__owner != _get_ident():
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:139:         self.__count = count = self.__count - 1
threading:140:         if not count:
threading:141:             self.__owner = None
threading:142:             self.__block.release()
eventlet.semaphore:87:         self.counter += 1
eventlet.semaphore:88:         if self._waiters:
eventlet.semaphore:90:         return True
threading:144:                 self._note("%s.release(): final release", self)
threading:65:             if self.__verbose:
eventlet.greenthread:25:     hub = hubs.get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.greenthread:26:     current = getcurrent()
eventlet.greenthread:27:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.greenthread:28:     timer = hub.schedule_call_global(seconds, current.switch)
eventlet.hubs.hub:313:         t = timer.Timer(seconds, cb, *args, **kw)
eventlet.hubs.timer:19:         self.seconds = seconds
eventlet.hubs.timer:20:         self.tpl = cb, args, kw
eventlet.hubs.timer:21:         self.called = False
eventlet.hubs.timer:22:         if _g_debug:
eventlet.hubs.hub:314:         self.add_timer(t)
eventlet.hubs.hub:269:         scheduled_time = self.clock() + timer.seconds
eventlet.hubs.hub:270:         self.next_timers.append((scheduled_time, timer))
eventlet.hubs.hub:271:         return scheduled_time
eventlet.hubs.hub:315:         return t
eventlet.greenthread:29:     try:
eventlet.greenthread:30:         hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.timer:58:                 try:
eventlet.hubs.timer:59:                     del self.tpl
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:286:             if item[1].called:
eventlet.hubs.hub:289:                 heappush(t, item)
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:350:         if self.debuglevel > 0:
httplib:352:         if not line:
httplib:356:         try:
httplib:357:             [version, status, reason] = line.split(None, 2)
httplib:366:         if not version.startswith('HTTP/'):
httplib:376:         try:
httplib:377:             status = int(status)
httplib:378:             if status < 100 or status > 999:
httplib:382:         return version, status, reason
httplib:392:             if status != CONTINUE:
httplib:393:                 break
httplib:402:         self.status = status
httplib:403:         self.reason = reason.strip()
httplib:404:         if version == 'HTTP/1.0':
httplib:406:         elif version.startswith('HTTP/1.'):
httplib:407:             self.version = 11   # use HTTP/1.1 code for HTTP/1.x where x>=1
httplib:413:         if self.version == 9:
httplib:420:         self.msg = HTTPMessage(self.fp, 0)
mimetools:25:         rfc822.Message.__init__(self, fp, seekable)
rfc822:90:         if seekable == 1:
rfc822:97:         self.fp = fp
rfc822:98:         self.seekable = seekable
rfc822:99:         self.startofheaders = None
rfc822:100:         self.startofbody = None
rfc822:102:         if self.seekable:
rfc822:108:         self.readheaders()
httplib:258:         self.dict = {}
httplib:259:         self.unixfrom = ''
httplib:260:         self.headers = hlist = []
httplib:261:         self.status = ''
httplib:262:         headerseen = ""
httplib:263:         firstline = 1
httplib:264:         startofline = unread = tell = None
httplib:265:         if hasattr(self.fp, 'unread'):
httplib:267:         elif self.seekable:
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:297:                 break
rfc822:110:         if self.seekable:
mimetools:27:                 self.getheader('content-transfer-encoding')
rfc822:292:         return self.dict.get(name.lower(), default)
mimetools:29:                 self.getheader('content-type')
rfc822:292:         return self.dict.get(name.lower(), default)
mimetools:30:         self.parsetype()
mimetools:34:         str = self.typeheader
mimetools:35:         if str is None:
mimetools:37:         if ';' in str:
mimetools:42:             self.plisttext = ''
mimetools:43:         fields = str.split('/')
mimetools:44:         for i in range(len(fields)):
mimetools:45:             fields[i] = fields[i].strip().lower()
mimetools:44:         for i in range(len(fields)):
mimetools:45:             fields[i] = fields[i].strip().lower()
mimetools:44:         for i in range(len(fields)):
mimetools:46:         self.type = '/'.join(fields)
mimetools:47:         self.maintype = fields[0]
mimetools:48:         self.subtype = '/'.join(fields[1:])
mimetools:31:         self.parseplist()
mimetools:51:         str = self.plisttext
mimetools:52:         self.plist = []
mimetools:53:         while str[:1] == ';':
httplib:421:         if self.debuglevel > 0:
httplib:426:         self.msg.fp = None
httplib:429:         tr_enc = self.msg.getheader('transfer-encoding')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:430:         if tr_enc and tr_enc.lower() == "chunked":
httplib:434:             self.chunked = 0
httplib:437:         self.will_close = self._check_close()
httplib:468:         conn = self.msg.getheader('connection')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:469:         if self.version == 11:
httplib:472:             conn = self.msg.getheader('connection')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:473:             if conn and "close" in conn.lower():
httplib:475:             return False
httplib:441:         length = self.msg.getheader('content-length')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:442:         if length and not self.chunked:
httplib:443:             try:
httplib:444:                 self.length = int(length)
httplib:448:                 if self.length < 0:  # ignore nonsensical negative lengths
httplib:454:         if (status == NO_CONTENT or status == NOT_MODIFIED or
httplib:455:             100 <= status < 200 or      # 1xx codes
httplib:456:             self._method == 'HEAD'):
httplib:462:         if not self.will_close and \
httplib:463:            not self.chunked and \
httplib:464:            self.length is None:
httplib:987:         assert response.will_close != _UNKNOWN
httplib:988:         self.__state = _CS_IDLE
httplib:990:         if response.will_close:
httplib:995:             self.__response = response
httplib:997:         return response
httplib20_7_1:1167:                 content = ""
httplib20_7_1:1168:                 if method == "HEAD":
httplib20_7_1:1171:                     content = response.read()
httplib:514:         if self.fp is None:
httplib:517:         if self.chunked:
httplib:520:         if amt is None:
httplib:522:             if self.length is None:
httplib:525:                 s = self._safe_read(self.length)
httplib:613:         s = []
httplib:614:         while amt > 0:
httplib:615:             chunk = self.fp.read(min(amt, MAXAMOUNT))
socket:319:         rbufsize = max(self._rbufsize, self.default_bufsize)
socket:323:         buf = self._rbuf
socket:324:         buf.seek(0, 2)  # seek end
socket:325:         if size < 0:
socket:336:             buf_len = buf.tell()
socket:337:             if buf_len >= size:
socket:345:             self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:346:             while True:
socket:347:                 left = size - buf_len
socket:353:                 data = self._sock.recv(left)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:354:                 if not data:
socket:356:                 n = len(data)
socket:357:                 if n == size and not buf_len:
socket:364:                 if n == left:
socket:368:                 assert n <= left, "recv(%d) returned %d bytes" % (left, n)
socket:369:                 buf.write(data)
socket:370:                 buf_len += n
socket:371:                 del data  # explicit free
socket:346:             while True:
socket:347:                 left = size - buf_len
socket:353:                 data = self._sock.recv(left)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:354:                 if not data:
socket:356:                 n = len(data)
socket:357:                 if n == size and not buf_len:
socket:364:                 if n == left:
socket:368:                 assert n <= left, "recv(%d) returned %d bytes" % (left, n)
socket:369:                 buf.write(data)
socket:370:                 buf_len += n
socket:371:                 del data  # explicit free
socket:346:             while True:
socket:347:                 left = size - buf_len
socket:353:                 data = self._sock.recv(left)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:354:                 if not data:
socket:356:                 n = len(data)
socket:357:                 if n == size and not buf_len:
socket:364:                 if n == left:
socket:365:                     buf.write(data)
socket:366:                     del data  # explicit free
socket:367:                     break
socket:373:             return buf.getvalue()
httplib:616:             if not chunk:
httplib:618:             s.append(chunk)
httplib:619:             amt -= len(chunk)
httplib:614:         while amt > 0:
httplib:620:         return ''.join(s)
httplib:526:                 self.length = 0
httplib:527:             self.close()        # we read everything
httplib:498:         if self.fp:
httplib:499:             self.fp.close()
socket:266:         try:
socket:267:             if self._sock:
socket:268:                 self.flush()
socket:282:         if self._wbuf:
socket:270:             if self._close:
socket:272:             self._sock = None
httplib:500:             self.fp = None
socket:275:         try:
socket:276:             self.close()
socket:266:         try:
socket:267:             if self._sock:
socket:270:             if self._close:
socket:272:             self._sock = None
httplib:528:             return s
httplib20_7_1:1172:                 response = Response(response)
httplib20_7_1:1488:         if isinstance(info, httplib.HTTPResponse):
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib:629:         if self.msg is None:
httplib:631:         return self.msg.items()
rfc822:459:         return self.dict.items()
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1491:             self.status = info.status
httplib20_7_1:1492:             self['status'] = str(self.status)
httplib20_7_1:1493:             self.reason = info.reason
httplib20_7_1:1494:             self.version = info.version
httplib20_7_1:1173:                 if method != "HEAD":
httplib20_7_1:1174:                     content = _decompressContent(response, content)
httplib20_7_1:379:     content = new_content
httplib20_7_1:380:     try:
httplib20_7_1:381:         encoding = response.get('content-encoding', None)
httplib20_7_1:382:         if encoding in ['gzip', 'deflate']:
httplib20_7_1:383:             if encoding == 'gzip':
httplib20_7_1:384:                 content = gzip.GzipFile(fileobj=StringIO.StringIO(new_content)).read()
StringIO:56:         if not isinstance(buf, basestring):
StringIO:58:         self.buf = buf
StringIO:59:         self.len = len(buf)
StringIO:60:         self.buflist = []
StringIO:61:         self.pos = 0
StringIO:62:         self.closed = False
StringIO:63:         self.softspace = 0
gzip:76:         if mode and 'b' not in mode:
gzip:78:         if fileobj is None:
gzip:80:         if filename is None:
gzip:81:             if hasattr(fileobj, 'name'): filename = fileobj.name
gzip:82:             else: filename = ''
gzip:83:         if mode is None:
gzip:84:             if hasattr(fileobj, 'mode'): mode = fileobj.mode
gzip:85:             else: mode = 'rb'
gzip:87:         if mode[0:1] == 'r':
gzip:88:             self.mode = READ
gzip:90:             self._new_member = True
gzip:91:             self.extrabuf = ""
gzip:92:             self.extrasize = 0
gzip:93:             self.name = filename
gzip:95:             self.min_readsize = 100
gzip:108:         self.fileobj = fileobj
gzip:109:         self.offset = 0
gzip:111:         if self.mode == WRITE:
gzip:201:         if self.mode != READ:
gzip:205:         if self.extrasize <= 0 and self.fileobj is None:
gzip:208:         readsize = 1024
gzip:209:         if size < 0:        # get the whole thing
gzip:210:             try:
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:247:             pos = self.fileobj.tell()   # Save current position
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:248:             self.fileobj.seek(0, 2)     # Seek to end of file
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:111:             pos += self.len
StringIO:112:         self.pos = max(0, pos)
gzip:249:             if pos == self.fileobj.tell():
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:252:                 self.fileobj.seek( pos ) # Return to original position
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:112:         self.pos = max(0, pos)
gzip:254:             self._init_read()
gzip:150:         self.crc = zlib.crc32("") & 0xffffffffL
gzip:151:         self.size = 0
gzip:255:             self._read_gzip_header()
gzip:154:         magic = self.fileobj.read(2)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:155:         if magic != '\037\213':
gzip:157:         method = ord( self.fileobj.read(1) )
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:158:         if method != 8:
gzip:160:         flag = ord( self.fileobj.read(1) )
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:164:         self.fileobj.read(6)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:166:         if flag & FEXTRA:
gzip:171:         if flag & FNAME:
gzip:177:         if flag & FCOMMENT:
gzip:183:         if flag & FHCRC:
gzip:256:             self.decompress = zlib.decompressobj(-zlib.MAX_WBITS)
gzip:257:             self._new_member = False
gzip:260:         buf = self.fileobj.read(size)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:265:         if buf == "":
gzip:271:         uncompress = self.decompress.decompress(buf)
gzip:272:         self._add_read_data( uncompress )
gzip:288:         self.crc = zlib.crc32(data, self.crc) & 0xffffffffL
gzip:289:         self.extrabuf = self.extrabuf + data
gzip:290:         self.extrasize = self.extrasize + len(data)
gzip:291:         self.size = self.size + len(data)
gzip:274:         if self.decompress.unused_data != "":
gzip:280:             self.fileobj.seek( -len(self.decompress.unused_data)+8, 1)
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:109:             pos += self.pos
StringIO:112:         self.pos = max(0, pos)
gzip:284:             self._read_eof()
gzip:299:         self.fileobj.seek(-8, 1)
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:109:             pos += self.pos
StringIO:112:         self.pos = max(0, pos)
gzip:300:         crc32 = read32(self.fileobj)
gzip:24:     return struct.unpack("<I", input.read(4))[0]
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:301:         isize = read32(self.fileobj)  # may exceed 2GB
gzip:24:     return struct.unpack("<I", input.read(4))[0]
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:302:         if crc32 != self.crc:
gzip:305:         elif isize != (self.size & 0xffffffffL):
gzip:285:             self._new_member = True
gzip:213:                     readsize = min(self.max_read_chunk, readsize * 2)
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:247:             pos = self.fileobj.tell()   # Save current position
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:248:             self.fileobj.seek(0, 2)     # Seek to end of file
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:111:             pos += self.len
StringIO:112:         self.pos = max(0, pos)
gzip:249:             if pos == self.fileobj.tell():
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:250:                 raise EOFError, "Reached EOF"
gzip:214:             except EOFError:
gzip:215:                 size = self.extrasize
gzip:225:         chunk = self.extrabuf[:size]
gzip:226:         self.extrabuf = self.extrabuf[size:]
gzip:227:         self.extrasize = self.extrasize - size
gzip:229:         self.offset += size
gzip:230:         return chunk
gzip:324:         try:
gzip:325:             if (self.myfileobj is None and
gzip:326:                 self.fileobj is None):
gzip:330:         self.close()
gzip:309:         if self.fileobj is None:
gzip:311:         if self.mode == WRITE:
gzip:317:         elif self.mode == READ:
gzip:318:             self.fileobj = None
gzip:319:         if self.myfileobj:
httplib20_7_1:385:             if encoding == 'deflate':
httplib20_7_1:387:             response['content-length'] = str(len(content))
httplib20_7_1:389:             response['-content-encoding'] = response['content-encoding']
httplib20_7_1:390:             del response['content-encoding']
httplib20_7_1:394:     return content
httplib20_7_1:1175:             break
httplib20_7_1:1176:         return (response, content)
httplib20_7_1:1190:         if auth:
httplib20_7_1:1196:         if response.status == 401:
httplib20_7_1:1205:         if (self.follow_all_redirects or (method in ["GET", "HEAD"]) or response.status == 303):
httplib20_7_1:1206:             if self.follow_redirects and response.status in [300, 301, 302, 303, 307]:
httplib20_7_1:1240:             elif response.status in [200, 203] and method in ["GET", "HEAD"]:
httplib20_7_1:1242:                 if not response.has_key('content-location'):
httplib20_7_1:1243:                     response['content-location'] = absolute_uri
httplib20_7_1:1244:                 _updateCache(headers, response, content, self.cache, cachekey)
httplib20_7_1:397:     if cachekey:
httplib20_7_1:1246:         return (response, content)
httplib20_7_1:1464:         return (response, content)
contextlib:21:         if type is None:
contextlib:22:             try:
contextlib:23:                 self.gen.next()
eventlet.pools:19:     ...
eventlet.pools:129:         if self.current_size > self.max_size:
eventlet.pools:133:         if self.waiting():
eventlet.pools:161:         return max(0, self.channel.getting() - self.channel.putting())
eventlet.queue:202:         return len(self.getters)
eventlet.queue:197:         return len(self.putters)
eventlet.pools:136:             if self.order_as_stack:
eventlet.pools:139:                 self.free_items.append(item)
contextlib:24:             except StopIteration:
contextlib:25:                 return
work:62:         return content
pool:435:         try:
pool:436:             self.selectsharesResponse( value, server)
pool:195:         server = self.servers[server_name]
pool:196:         if server['role'] not in self.api_pull:
pool:199:         if server['api_method'] == 'json':
pool:200:             info = json.loads(response)
json:304:     if (cls is None and encoding is None and object_hook is None and
json:305:             parse_int is None and parse_float is None and
json:306:             parse_constant is None and not kw):
json:307:         return _default_decoder.decode(s)
json.decoder:319:         obj, end = self.raw_decode(s, idx=_w(s, 0).end())
json.decoder:334:         kw.setdefault('context', self)
json.decoder:335:         try:
json.decoder:336:             obj, end = self._scanner.iterscan(s, **kw).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:163:     pairs = {}
json.decoder:164:     s = match.string
json.decoder:165:     end = _w(s, match.end()).end()
json.decoder:166:     nextchar = s[end:end + 1]
json.decoder:168:     if nextchar == '}':
json.decoder:170:     if nextchar != '"':
json.decoder:172:     end += 1
json.decoder:173:     encoding = getattr(context, 'encoding', None)
json.decoder:174:     strict = getattr(context, 'strict', True)
json.decoder:175:     iterscan = JSONScanner.iterscan
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:191:             break
json.decoder:199:     object_hook = getattr(context, 'object_hook', None)
json.decoder:200:     if object_hook is not None:
json.decoder:202:     return pairs, end
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:339:         return obj, end
json.decoder:320:         end = _w(s, end).end()
json.decoder:321:         if end != len(s):
json.decoder:323:         return obj
pool:201:             for value in server['api_key'].split(','):
pool:202:                 info = info[value]
pool:201:             for value in server['api_key'].split(','):
pool:203:             if 'api_strip' in server:
pool:207:             round_shares = int(info)
pool:208:             if round_shares == None:
pool:211:             ghash = self.get_ghash(server, response, True)
pool:333:         if is_json == True:
pool:334:             info = json.loads(response)
json:304:     if (cls is None and encoding is None and object_hook is None and
json:305:             parse_int is None and parse_float is None and
json:306:             parse_constant is None and not kw):
json:307:         return _default_decoder.decode(s)
json.decoder:319:         obj, end = self.raw_decode(s, idx=_w(s, 0).end())
json.decoder:334:         kw.setdefault('context', self)
json.decoder:335:         try:
json.decoder:336:             obj, end = self._scanner.iterscan(s, **kw).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:163:     pairs = {}
json.decoder:164:     s = match.string
json.decoder:165:     end = _w(s, match.end()).end()
json.decoder:166:     nextchar = s[end:end + 1]
json.decoder:168:     if nextchar == '}':
json.decoder:170:     if nextchar != '"':
json.decoder:172:     end += 1
json.decoder:173:     encoding = getattr(context, 'encoding', None)
json.decoder:174:     strict = getattr(context, 'strict', True)
json.decoder:175:     iterscan = JSONScanner.iterscan
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:191:             break
json.decoder:199:     object_hook = getattr(context, 'object_hook', None)
json.decoder:200:     if object_hook is not None:
json.decoder:202:     return pairs, end
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:339:         return obj, end
json.decoder:320:         end = _w(s, end).end()
json.decoder:321:         if end != len(s):
json.decoder:323:         return obj
pool:335:             if 'api_key_ghashrate' in server:
pool:339:             if 'api_key_mhashrate' in server:
pool:343:             if 'api_key_khashrate' in server:
pool:347:             if 'api_key_hashrate' in server:
pool:352:         if 'api_key_ghashrate' in server:
pool:355:         if 'api_key_mhashrate' in server:
pool:358:         if 'api_key_khashrate' in server:
pool:361:         if 'api_key_hashrate' in server:
pool:365:         return -1
pool:212:             if ghash > 0:
pool:214:             if 'api_key_duration' in server:
pool:222:             self.UpdateShares(server_name,round_shares)
pool:133:         with self.lock:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:68:             self._waiters.add(greenthread.getcurrent())
eventlet.semaphore:69:             try:
eventlet.semaphore:70:                 while self.counter <= 0:
eventlet.semaphore:71:                     hubs.get_hub().switch()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.greenthread:191:         try:
eventlet.greenthread:192:             result = function(*args, **kwargs)
pool:430:         if self.servers[server]['role'] not in self.api_pull:
pool:432:         info = self.servers[server]
pool:433:         self.bitHopper.scheduler.update_api_server(server)
scheduler:136:         return
pool:434:         value = self.bitHopper.work.get(info['api_address'])
work:53:         header = {'User-Agent':'Mozilla/5.0 (Windows; U; MSIE 9.0; WIndows NT 9.0; en-US))'}
work:54:         with self.get_http(url) as http:
work:26:         if address not in self.connect_pool:
work:28:         return self.connect_pool[address].item()
contextlib:83:         return GeneratorContextManager(func(*args, **kwds))
contextlib:12:         self.gen = gen
contextlib:15:         try:
contextlib:16:             return self.gen.next()
eventlet.pools:15:     >>> from eventlet import pools
eventlet.pools:114:         if self.free_items:
eventlet.pools:115:             return self.free_items.popleft()
eventlet.pools:16:     >>> pool = pools.TokenPool(max_size=4)
eventlet.pools:17:     >>> with pool.item() as obj:
work:55:             try:
work:56:                 content = http.request( url, 'GET', headers=header)[1] # Returns response dict and content str
httplib20_7_1:1277:         try:
httplib20_7_1:1278:             if headers is None:
httplib20_7_1:1281:                 headers = self._normalize_headers(headers)
httplib20_7_1:1249:         return _normalize_headers(headers)
httplib20_7_1:249:     return dict([ (key.lower(), NORMALIZE_SPACE.sub(value, ' ').strip())  for (key, value) in headers.iteritems()])
httplib20_7_1:249:     return dict([ (key.lower(), NORMALIZE_SPACE.sub(value, ' ').strip())  for (key, value) in headers.iteritems()])
httplib20_7_1:1283:             if not headers.has_key('user-agent'):
httplib20_7_1:1286:             uri = iri2uri(uri)
httplib20_7_1.iri2uri:69:     if isinstance(uri ,unicode):
httplib20_7_1.iri2uri:77:     return uri
httplib20_7_1:1288:             (scheme, authority, request_uri, defrag_uri) = urlnorm(uri)
httplib20_7_1:201:     (scheme, authority, path, query, fragment) = parse_uri(uri)
httplib20_7_1:197:     groups = URI.match(uri).groups()
httplib20_7_1:198:     return (groups[1], groups[3], groups[4], groups[6], groups[8])
httplib20_7_1:202:     if not scheme or not authority:
httplib20_7_1:204:     authority = authority.lower()
httplib20_7_1:205:     scheme = scheme.lower()
httplib20_7_1:206:     if not path:
httplib20_7_1:210:     request_uri = query and "?".join([path, query]) or path
httplib20_7_1:211:     scheme = scheme.lower()
httplib20_7_1:212:     defrag_uri = scheme + "://" + authority + request_uri
httplib20_7_1:213:     return scheme, authority, request_uri, defrag_uri
httplib20_7_1:1289:             domain_port = authority.split(":")[0:2]
httplib20_7_1:1290:             if len(domain_port) == 2 and domain_port[1] == '443' and scheme == 'http':
httplib20_7_1:1294:             conn_key = scheme+":"+authority
httplib20_7_1:1295:             if conn_key in self.connections:
httplib20_7_1:1296:                 conn = self.connections[conn_key]
httplib20_7_1:1323:             if 'range' not in headers and 'accept-encoding' not in headers:
httplib20_7_1:1324:                 headers['accept-encoding'] = 'gzip, deflate'
httplib20_7_1:1326:             info = email.Message.Message()
email.message:106:         self._headers = []
email.message:107:         self._unixfrom = None
email.message:108:         self._payload = None
email.message:109:         self._charset = None
email.message:111:         self.preamble = self.epilogue = None
email.message:112:         self.defects = []
email.message:114:         self._default_type = 'text/plain'
httplib20_7_1:1327:             cached_value = None
httplib20_7_1:1328:             if self.cache:
httplib20_7_1:1348:                 cachekey = None
httplib20_7_1:1350:             if method in self.optimistic_concurrency_methods and self.cache and info.has_key('etag') and not self.ignore_etag and 'if-match' not in headers:
httplib20_7_1:1354:             if method not in ["GET", "HEAD"] and self.cache and cachekey:
httplib20_7_1:1360:             if method in ['GET', 'HEAD'] and 'vary' in info:
email.message:313:         return name.lower() in [k.lower() for k, v in self._headers]
httplib20_7_1:1370:             if cached_value and method in ["GET", "HEAD"] and self.cache and 'range' not in headers:
httplib20_7_1:1430:                 cc = _parse_cache_control(headers)
httplib20_7_1:252:     retval = {}
httplib20_7_1:253:     if headers.has_key('cache-control'):
httplib20_7_1:258:     return retval
httplib20_7_1:1431:                 if cc.has_key('only-if-cached'):
httplib20_7_1:1436:                     (response, content) = self._request(conn, authority, uri, request_uri, method, body, headers, redirections, cachekey)
httplib20_7_1:1183:         auths = [(auth.depth(request_uri), auth) for auth in self.authorizations if auth.inscope(host, request_uri)]
httplib20_7_1:1184:         auth = auths and sorted(auths)[0][1] or None
httplib20_7_1:1185:         if auth:
httplib20_7_1:1188:         (response, content) = self._conn_request(conn, request_uri, method, body, headers)
httplib20_7_1:1120:         for i in range(2):
httplib20_7_1:1121:             try:
httplib20_7_1:1122:                 if conn.sock is None:
httplib20_7_1:1124:                 conn.request(method, request_uri, body, headers)
httplib:909:         try:
httplib:910:             self._send_request(method, url, body, headers)
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:921:         skips = {}
httplib:922:         if 'host' in header_names:
httplib:924:         if 'accept-encoding' in header_names:
httplib:925:             skips['skip_accept_encoding'] = 1
httplib:927:         self.putrequest(method, url, **skips)
httplib:789:         if self.__response and self.__response.isclosed():
httplib:509:         return self.fp is None
httplib:790:             self.__response = None
httplib:811:         if self.__state == _CS_IDLE:
httplib:812:             self.__state = _CS_REQ_STARTED
httplib:817:         self._method = method
httplib:818:         if not url:
httplib:820:         str = '%s %s %s' % (method, url, self._http_vsn_str)
httplib:822:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:824:         if self._http_vsn == 11:
httplib:827:             if not skip_host:
httplib:842:                 netloc = ''
httplib:843:                 if url.startswith('http'):
httplib:846:                 if netloc:
httplib:853:                     try:
httplib:854:                         host_enc = self.host.encode("ascii")
httplib:857:                     if self.port == self.default_port:
httplib:858:                         self.putheader('Host', host_enc)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:870:             if not skip_accept_encoding:
httplib:883:             pass
httplib:929:         if body and ('content-length' not in header_names):
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:947:         self.endheaders()
httplib:899:         if self.__state == _CS_REQ_STARTED:
httplib:900:             self.__state = _CS_REQ_SENT
httplib:904:         self._send_output()
httplib:773:         self._buffer.extend(("", ""))
httplib:774:         msg = "\r\n".join(self._buffer)
httplib:775:         del self._buffer[:]
httplib:776:         self.send(msg)
httplib:733:         if self.sock is None:
httplib:744:         if self.debuglevel > 0:
httplib:746:         try:
httplib:747:             blocksize=8192
httplib:748:             if hasattr(str,'read') and not isinstance(str, array):
httplib:755:                 self.sock.sendall(str)
eventlet.green.ssl:123:         if self._sslobj:
eventlet.green.ssl:124:             if flags != 0:
eventlet.green.ssl:128:             amount = len(data)
eventlet.green.ssl:129:             count = 0
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:131:                 v = self.send(data[count:])
eventlet.green.ssl:105:         if self._sslobj:
eventlet.green.ssl:106:             return self._call_trampolining(
eventlet.green.ssl:107:                 super(GreenSSLSocket, self).send, data, flags)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:167:         if self._sslobj:
ssl:168:             if flags != 0:
ssl:172:             while True:
ssl:173:                 try:
ssl:174:                     v = self._sslobj.write(data)
ssl:183:                     return v
eventlet.green.ssl:132:                 count += v
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:133:             return amount
httplib:949:         if body:
httplib20_7_1:1157:             try:
httplib20_7_1:1158:                 response = conn.getresponse()
httplib:956:         if self.__response and self.__response.isclosed():
httplib:975:         if self.__state != _CS_REQ_SENT or self.__response:
httplib:978:         if self.debuglevel > 0:
httplib:983:             response = self.response_class(self.sock, strict=self.strict,
httplib:984:                                            method=self._method)
httplib:330:         self.fp = sock.makefile('rb', 0)
ssl:335:         self._makefile_refs += 1
ssl:336:         return _fileobject(self, mode, bufsize)
socket:236:         self._sock = sock
socket:237:         self.mode = mode # Not actually used in this version
socket:238:         if bufsize < 0:
socket:240:         self.bufsize = bufsize
socket:241:         self.softspace = False
socket:245:         if bufsize == 0:
socket:246:             self._rbufsize = 1
socket:251:         self._wbufsize = bufsize
socket:256:         self._rbuf = StringIO()
socket:257:         self._wbuf = [] # A list of strings
socket:258:         self._wbuf_len = 0
socket:259:         self._close = close
httplib:331:         self.debuglevel = debuglevel
httplib:332:         self.strict = strict
httplib:333:         self._method = method
httplib:335:         self.msg = None
httplib:338:         self.version = _UNKNOWN # HTTP-Version
httplib:339:         self.status = _UNKNOWN  # Status-Code
httplib:340:         self.reason = _UNKNOWN  # Reason-Phrase
httplib:342:         self.chunked = _UNKNOWN         # is "chunked" being used?
httplib:343:         self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
httplib:344:         self.length = _UNKNOWN          # number of bytes left in response
httplib:345:         self.will_close = _UNKNOWN      # conn will close at end of response
httplib:986:         response.begin()
httplib:385:         if self.msg is not None:
httplib:390:         while True:
httplib:391:             version, status, reason = self._read_status()
httplib:349:         line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:399:                         break
socket:401:                 return "".join(buffers)
httplib:350:         if self.debuglevel > 0:
httplib:352:         if not line:
httplib:355:             raise BadStatusLine(line)
httplib:1199:         self.args = line,
httplib:1200:         self.line = line
httplib20_7_1:1159:             except (socket.error, httplib.HTTPException):
httplib20_7_1:1160:                 if i == 0:
httplib20_7_1:1161:                     conn.close()
httplib:723:         if self.sock:
httplib:724:             self.sock.close()   # close it manually... there may be other refs
ssl:283:         if self._makefile_refs < 1:
ssl:287:             self._makefile_refs -= 1
httplib:725:             self.sock = None
httplib:726:         if self.__response:
httplib:729:         self.__state = _CS_IDLE
httplib20_7_1:1162:                     conn.connect()
httplib20_7_1:874:         msg = "getaddrinfo returns an empty list"
httplib20_7_1:875:         for family, socktype, proto, canonname, sockaddr in socket.getaddrinfo(
httplib20_7_1:876:             self.host, self.port, 0, socket.SOCK_STREAM):
httplib20_7_1:877:             try:
httplib20_7_1:878:                 if self.proxy_info and self.proxy_info.isgood():
httplib20_7_1:882:                     sock = socket.socket(family, socktype, proto)
eventlet.greenio:115:         if isinstance(family_or_realsock, (int, long)):
eventlet.greenio:116:             fd = _original_socket(family_or_realsock, *args, **kwargs)
socket:181:         if _sock is None:
socket:182:             _sock = _realsocket(family, type, proto)
socket:183:         self._sock = _sock
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
eventlet.greenio:123:         try:
eventlet.greenio:124:             self._timeout = fd.gettimeout() or socket.getdefaulttimeout()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:128:         set_nonblocking(fd)
eventlet.greenio:76:     try:
eventlet.greenio:77:         setblocking = fd.setblocking
eventlet.greenio:100:         setblocking(0)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:129:         self.fd = fd
eventlet.greenio:132:         self.act_non_blocking = False
httplib20_7_1:883:                     sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
eventlet.greenio:145:         attr = getattr(self.fd, name)
eventlet.greenio:146:         setattr(self, name, attr)
eventlet.greenio:147:         return attr
socket:1: # Wrapper module for _socket, providing some additional facilities
httplib20_7_1:885:                 if has_timeout(self.timeout):
httplib20_7_1:97:     if hasattr(socket, '_GLOBAL_DEFAULT_TIMEOUT'):
httplib20_7_1:98:         return (timeout is not None and timeout is not socket._GLOBAL_DEFAULT_TIMEOUT)
httplib20_7_1:887:                 sock.connect((self.host, self.port))
eventlet.greenio:163:         if self.act_non_blocking:
eventlet.greenio:165:         fd = self.fd
eventlet.greenio:166:         if self.gettimeout() is None:
eventlet.greenio:317:         return self._timeout
eventlet.greenio:167:             while not socket_connect(fd, address):
eventlet.greenio:33:     err = descriptor.connect_ex(address)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:34:     if err in CONNECT_ERR:
eventlet.greenio:35:         return None
eventlet.greenio:168:                 trampoline(fd, write=True)
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:118:         elif write:
eventlet.hubs:119:             listener = hub.add(hub.WRITE, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:40:             mask |= WRITE_MASK | EXC_MASK
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
socket:275:         try:
socket:276:             self.close()
socket:266:         try:
socket:267:             if self._sock:
socket:268:                 self.flush()
socket:282:         if self._wbuf:
socket:270:             if self._close:
socket:272:             self._sock = None
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.timer:58:                 try:
eventlet.hubs.timer:59:                     del self.tpl
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:99:                     writers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.greenio:169:                 socket_checkerr(fd)
eventlet.greenio:41:     err = descriptor.getsockopt(socket.SOL_SOCKET, socket.SO_ERROR)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:42:     if err not in CONNECT_SUCCESS:
eventlet.greenio:167:             while not socket_connect(fd, address):
eventlet.greenio:33:     err = descriptor.connect_ex(address)
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.greenio:34:     if err in CONNECT_ERR:
eventlet.greenio:36:     if err not in CONNECT_SUCCESS:
eventlet.greenio:38:     return descriptor
httplib20_7_1:888:                 self.sock =_ssl_wrap_socket(
httplib20_7_1:889:                     sock, self.key_file, self.cert_file,
httplib20_7_1:890:                     self.disable_ssl_certificate_validation, self.ca_certs)
httplib20_7_1:68:         if disable_validation:
httplib20_7_1:69:             cert_reqs = ssl.CERT_NONE
httplib20_7_1:75:         return ssl.wrap_socket(sock, keyfile=key_file, certfile=cert_file,
httplib20_7_1:76:                                cert_reqs=cert_reqs, ca_certs=ca_certs)
eventlet.green.ssl:285:     return GreenSSLSocket(sock, *a, **kw)
eventlet.green.ssl:41:         if not isinstance(sock, GreenSocket):
eventlet.green.ssl:44:         self.act_non_blocking = sock.act_non_blocking
eventlet.green.ssl:45:         self._timeout = sock.gettimeout()
eventlet.greenio:317:         return self._timeout
eventlet.green.ssl:46:         super(GreenSSLSocket, self).__init__(sock.fd, *args, **kw)
ssl:92:         socket.__init__(self, _sock=sock._sock)
socket:181:         if _sock is None:
socket:183:         self._sock = _sock
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
socket:185:             setattr(self, method, getattr(_sock, method))
socket:184:         for method in _delegate_methods:
ssl:94:         self.send = lambda data, flags=0: SSLSocket.send(self, data, flags)
ssl:95:         self.sendto = lambda data, addr, flags=0: SSLSocket.sendto(self, data, addr, flags)
ssl:96:         self.recv = lambda buflen=1024, flags=0: SSLSocket.recv(self, buflen, flags)
ssl:97:         self.recvfrom = lambda addr, buflen=1024, flags=0: SSLSocket.recvfrom(self, addr, buflen, flags)
ssl:98:         self.recv_into = lambda buffer, nbytes=None, flags=0: SSLSocket.recv_into(self, buffer, nbytes, flags)
ssl:99:         self.recvfrom_into = lambda buffer, nbytes=None, flags=0: SSLSocket.recvfrom_into(self, buffer, nbytes, flags)
ssl:101:         if certfile and not keyfile:
ssl:104:         try:
ssl:105:             socket.getpeername(self)
socket:1: # Wrapper module for _socket, providing some additional facilities
ssl:111:             self._sslobj = _ssl.sslwrap(self._sock, server_side,
ssl:112:                                         keyfile, certfile,
ssl:113:                                         cert_reqs, ssl_version, ca_certs)
ssl:114:             if do_handshake_on_connect:
ssl:115:                 timeout = self.gettimeout()
eventlet.green.ssl:61:         return self._timeout
ssl:116:                 try:
ssl:117:                     self.settimeout(None)
eventlet.green.ssl:58:         self._timeout = timeout
ssl:118:                     self.do_handshake()
eventlet.green.ssl:192:         return self._call_trampolining(
eventlet.green.ssl:193:             super(GreenSSLSocket, self).do_handshake)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:293:         self._sslobj.do_handshake()
ssl:120:                     self.settimeout(timeout)
eventlet.green.ssl:58:         self._timeout = timeout
ssl:121:         self.keyfile = keyfile
ssl:122:         self.certfile = certfile
ssl:123:         self.cert_reqs = cert_reqs
ssl:124:         self.ssl_version = ssl_version
ssl:125:         self.ca_certs = ca_certs
ssl:126:         self.do_handshake_on_connect = do_handshake_on_connect
ssl:127:         self.suppress_ragged_eofs = suppress_ragged_eofs
ssl:128:         self._makefile_refs = 0
eventlet.green.ssl:51:         try:
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
eventlet.green.ssl:53:                 delattr(self, fn)
eventlet.green.ssl:52:             for fn in orig_socket._delegate_methods:
httplib20_7_1:891:                 if self.debuglevel > 0:
httplib20_7_1:893:                 if not self.disable_ssl_certificate_validation:
httplib20_7_1:923:             break
httplib20_7_1:924:         if not self.sock:
httplib20_7_1:1163:                     continue
httplib20_7_1:1120:         for i in range(2):
httplib20_7_1:1121:             try:
httplib20_7_1:1122:                 if conn.sock is None:
httplib20_7_1:1124:                 conn.request(method, request_uri, body, headers)
httplib:909:         try:
httplib:910:             self._send_request(method, url, body, headers)
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:920:         header_names = dict.fromkeys([k.lower() for k in headers])
httplib:921:         skips = {}
httplib:922:         if 'host' in header_names:
httplib:924:         if 'accept-encoding' in header_names:
httplib:925:             skips['skip_accept_encoding'] = 1
httplib:927:         self.putrequest(method, url, **skips)
httplib:789:         if self.__response and self.__response.isclosed():
httplib:811:         if self.__state == _CS_IDLE:
httplib:812:             self.__state = _CS_REQ_STARTED
httplib:817:         self._method = method
httplib:818:         if not url:
httplib:820:         str = '%s %s %s' % (method, url, self._http_vsn_str)
httplib:822:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:824:         if self._http_vsn == 11:
httplib:827:             if not skip_host:
httplib:842:                 netloc = ''
httplib:843:                 if url.startswith('http'):
httplib:846:                 if netloc:
httplib:853:                     try:
httplib:854:                         host_enc = self.host.encode("ascii")
httplib:857:                     if self.port == self.default_port:
httplib:858:                         self.putheader('Host', host_enc)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:870:             if not skip_accept_encoding:
httplib:883:             pass
httplib:929:         if body and ('content-length' not in header_names):
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:946:             self.putheader(hdr, value)
httplib:890:         if self.__state != _CS_REQ_STARTED:
httplib:893:         str = '%s: %s' % (header, value)
httplib:894:         self._output(str)
httplib:766:         self._buffer.append(s)
httplib:945:         for hdr, value in headers.iteritems():
httplib:947:         self.endheaders()
httplib:899:         if self.__state == _CS_REQ_STARTED:
httplib:900:             self.__state = _CS_REQ_SENT
httplib:904:         self._send_output()
httplib:773:         self._buffer.extend(("", ""))
httplib:774:         msg = "\r\n".join(self._buffer)
httplib:775:         del self._buffer[:]
httplib:776:         self.send(msg)
httplib:733:         if self.sock is None:
httplib:744:         if self.debuglevel > 0:
httplib:746:         try:
httplib:747:             blocksize=8192
httplib:748:             if hasattr(str,'read') and not isinstance(str, array):
httplib:755:                 self.sock.sendall(str)
eventlet.green.ssl:123:         if self._sslobj:
eventlet.green.ssl:124:             if flags != 0:
eventlet.green.ssl:128:             amount = len(data)
eventlet.green.ssl:129:             count = 0
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:131:                 v = self.send(data[count:])
eventlet.green.ssl:105:         if self._sslobj:
eventlet.green.ssl:106:             return self._call_trampolining(
eventlet.green.ssl:107:                 super(GreenSSLSocket, self).send, data, flags)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:167:         if self._sslobj:
ssl:168:             if flags != 0:
ssl:172:             while True:
ssl:173:                 try:
ssl:174:                     v = self._sslobj.write(data)
ssl:183:                     return v
eventlet.green.ssl:132:                 count += v
eventlet.green.ssl:130:             while (count < amount):
eventlet.green.ssl:133:             return amount
httplib:949:         if body:
httplib20_7_1:1157:             try:
httplib20_7_1:1158:                 response = conn.getresponse()
httplib:956:         if self.__response and self.__response.isclosed():
httplib:975:         if self.__state != _CS_REQ_SENT or self.__response:
httplib:978:         if self.debuglevel > 0:
httplib:983:             response = self.response_class(self.sock, strict=self.strict,
httplib:984:                                            method=self._method)
httplib:330:         self.fp = sock.makefile('rb', 0)
ssl:335:         self._makefile_refs += 1
ssl:336:         return _fileobject(self, mode, bufsize)
socket:236:         self._sock = sock
socket:237:         self.mode = mode # Not actually used in this version
socket:238:         if bufsize < 0:
socket:240:         self.bufsize = bufsize
socket:241:         self.softspace = False
socket:245:         if bufsize == 0:
socket:246:             self._rbufsize = 1
socket:251:         self._wbufsize = bufsize
socket:256:         self._rbuf = StringIO()
socket:257:         self._wbuf = [] # A list of strings
socket:258:         self._wbuf_len = 0
socket:259:         self._close = close
httplib:331:         self.debuglevel = debuglevel
httplib:332:         self.strict = strict
httplib:333:         self._method = method
httplib:335:         self.msg = None
httplib:338:         self.version = _UNKNOWN # HTTP-Version
httplib:339:         self.status = _UNKNOWN  # Status-Code
httplib:340:         self.reason = _UNKNOWN  # Reason-Phrase
httplib:342:         self.chunked = _UNKNOWN         # is "chunked" being used?
httplib:343:         self.chunk_left = _UNKNOWN      # bytes left to read in current chunk
httplib:344:         self.length = _UNKNOWN          # number of bytes left in response
httplib:345:         self.will_close = _UNKNOWN      # conn will close at end of response
httplib:986:         response.begin()
httplib:385:         if self.msg is not None:
httplib:390:         while True:
httplib:391:             version, status, reason = self._read_status()
httplib:349:         line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
ssl:137:         except SSLError, x:
ssl:138:             if x.args[0] == SSL_ERROR_EOF and self.suppress_ragged_eofs:
ssl:141:                 raise
eventlet.green.ssl:78:                 except SSLError, exc:
eventlet.green.ssl:79:                     if get_errno(exc) == SSL_ERROR_WANT_READ:
eventlet.support:12:     try:
eventlet.support:13:         if exc.errno is not None: return exc.errno
eventlet.green.ssl:80:                         trampoline(self,
eventlet.green.ssl:81:                                    read=True,
eventlet.green.ssl:82:                                    timeout=self.gettimeout(),
eventlet.green.ssl:61:         return self._timeout
eventlet.green.ssl:83:                                    timeout_exc=timeout_exc('timed out'))
eventlet.hubs:104:     t = None
eventlet.hubs:105:     hub = get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs:106:     current = greenlet.getcurrent()
eventlet.hubs:107:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.hubs:108:     assert not (read and write), 'not allowed to trampoline for reading and writing'
eventlet.hubs:109:     try:
eventlet.hubs:110:         fileno = fd.fileno()
socket:1: # Wrapper module for _socket, providing some additional facilities
eventlet.hubs:113:     if timeout is not None:
eventlet.hubs:115:     try:
eventlet.hubs:116:         if read:
eventlet.hubs:117:             listener = hub.add(hub.READ, fileno, current.switch)
eventlet.hubs.epolls:44:         oldlisteners = bool(self.listeners[READ].get(fileno) or
eventlet.hubs.epolls:45:                             self.listeners[WRITE].get(fileno))
eventlet.hubs.epolls:46:         listener = BaseHub.add(self, evtype, fileno, cb)
eventlet.hubs.hub:115:         listener = self.lclass(evtype, fileno, cb)
eventlet.hubs.hub:34:         assert (evtype is READ or evtype is WRITE)
eventlet.hubs.hub:35:         self.evtype = evtype
eventlet.hubs.hub:36:         self.fileno = fileno
eventlet.hubs.hub:37:         self.cb = cb
eventlet.hubs.hub:116:         bucket = self.listeners[evtype]
eventlet.hubs.hub:117:         if fileno in bucket:
eventlet.hubs.hub:130:             bucket[fileno] = listener
eventlet.hubs.hub:131:         return listener
eventlet.hubs.epolls:47:         try:
eventlet.hubs.epolls:48:             if not oldlisteners:
eventlet.hubs.epolls:50:                 self.register(fileno, new=True)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:38:             mask |= READ_MASK | EXC_MASK
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:43:                 if new:
eventlet.hubs.poll:44:                     self.poll.register(fileno, mask)
eventlet.hubs.epolls:56:         return listener
eventlet.hubs:120:         try:
eventlet.hubs:121:             return hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:95:             try:
eventlet.hubs.poll:96:                 if event & READ_MASK:
eventlet.hubs.poll:97:                     readers.get(fileno, noop).cb(fileno)
eventlet.hubs:123:             hub.remove(listener)
eventlet.hubs.poll:32:         super(Hub, self).remove(listener)
eventlet.hubs.hub:134:         fileno = listener.fileno
eventlet.hubs.hub:135:         evtype = listener.evtype
eventlet.hubs.hub:136:         self.listeners[evtype].pop(fileno, None)
eventlet.hubs.hub:138:         if fileno in self.secondaries[evtype]:
eventlet.hubs.poll:33:         self.register(listener.fileno)
eventlet.hubs.poll:36:         mask = 0
eventlet.hubs.poll:37:         if self.listeners[READ].get(fileno):
eventlet.hubs.poll:39:         if self.listeners[WRITE].get(fileno):
eventlet.hubs.poll:41:         try:
eventlet.hubs.poll:42:             if mask:
eventlet.hubs.poll:51:                 try:
eventlet.hubs.poll:52:                     self.poll.unregister(fileno)
eventlet.hubs:125:         if t is not None:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:350:         if self.debuglevel > 0:
httplib:352:         if not line:
httplib:356:         try:
httplib:357:             [version, status, reason] = line.split(None, 2)
httplib:366:         if not version.startswith('HTTP/'):
httplib:376:         try:
httplib:377:             status = int(status)
httplib:378:             if status < 100 or status > 999:
httplib:382:         return version, status, reason
httplib:392:             if status != CONTINUE:
httplib:393:                 break
httplib:402:         self.status = status
httplib:403:         self.reason = reason.strip()
httplib:404:         if version == 'HTTP/1.0':
httplib:406:         elif version.startswith('HTTP/1.'):
httplib:407:             self.version = 11   # use HTTP/1.1 code for HTTP/1.x where x>=1
httplib:413:         if self.version == 9:
httplib:420:         self.msg = HTTPMessage(self.fp, 0)
mimetools:25:         rfc822.Message.__init__(self, fp, seekable)
rfc822:90:         if seekable == 1:
rfc822:97:         self.fp = fp
rfc822:98:         self.seekable = seekable
rfc822:99:         self.startofheaders = None
rfc822:100:         self.startofbody = None
rfc822:102:         if self.seekable:
rfc822:108:         self.readheaders()
httplib:258:         self.dict = {}
httplib:259:         self.unixfrom = ''
httplib:260:         self.headers = hlist = []
httplib:261:         self.status = ''
httplib:262:         headerseen = ""
httplib:263:         firstline = 1
httplib:264:         startofline = unread = tell = None
httplib:265:         if hasattr(self.fp, 'unread'):
httplib:267:         elif self.seekable:
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:298:             headerseen = self.isheader(line)
rfc822:204:         i = line.find(':')
rfc822:205:         if i > 0:
rfc822:206:             return line[:i].lower()
httplib:299:             if headerseen:
httplib:301:                 hlist.append(line)
httplib:302:                 self.addheader(headerseen, line[len(headerseen)+1:].strip())
httplib:218:         prev = self.dict.get(key)
httplib:219:         if prev is None:
httplib:220:             self.dict[key] = value
httplib:303:                 continue
httplib:269:         while True:
httplib:270:             if tell:
httplib:276:             line = self.fp.readline()
socket:376:         buf = self._rbuf
socket:377:         buf.seek(0, 2)  # seek end
socket:378:         if buf.tell() > 0:
socket:387:         if size < 0:
socket:389:             if self._rbufsize <= 1:
socket:391:                 buf.seek(0)
socket:392:                 buffers = [buf.read()]
socket:393:                 self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:394:                 data = None
socket:395:                 recv = self._sock.recv
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:397:                     data = recv(1)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:398:                     if not data:
socket:400:                     buffers.append(data)
socket:396:                 while data != "\n":
socket:401:                 return "".join(buffers)
httplib:277:             if not line:
httplib:281:             if firstline and line.startswith('From '):
httplib:284:             firstline = 0
httplib:285:             if headerseen and line[0] in ' \t':
httplib:292:             elif self.iscomment(line):
rfc822:226:         return False
httplib:295:             elif self.islast(line):
rfc822:217:         return line in _blanklines
httplib:297:                 break
rfc822:110:         if self.seekable:
mimetools:27:                 self.getheader('content-transfer-encoding')
rfc822:292:         return self.dict.get(name.lower(), default)
mimetools:29:                 self.getheader('content-type')
rfc822:292:         return self.dict.get(name.lower(), default)
mimetools:30:         self.parsetype()
mimetools:34:         str = self.typeheader
mimetools:35:         if str is None:
mimetools:37:         if ';' in str:
mimetools:42:             self.plisttext = ''
mimetools:43:         fields = str.split('/')
mimetools:44:         for i in range(len(fields)):
mimetools:45:             fields[i] = fields[i].strip().lower()
mimetools:44:         for i in range(len(fields)):
mimetools:45:             fields[i] = fields[i].strip().lower()
mimetools:44:         for i in range(len(fields)):
mimetools:46:         self.type = '/'.join(fields)
mimetools:47:         self.maintype = fields[0]
mimetools:48:         self.subtype = '/'.join(fields[1:])
mimetools:31:         self.parseplist()
mimetools:51:         str = self.plisttext
mimetools:52:         self.plist = []
mimetools:53:         while str[:1] == ';':
httplib:421:         if self.debuglevel > 0:
httplib:426:         self.msg.fp = None
httplib:429:         tr_enc = self.msg.getheader('transfer-encoding')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:430:         if tr_enc and tr_enc.lower() == "chunked":
httplib:434:             self.chunked = 0
httplib:437:         self.will_close = self._check_close()
httplib:468:         conn = self.msg.getheader('connection')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:469:         if self.version == 11:
httplib:472:             conn = self.msg.getheader('connection')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:473:             if conn and "close" in conn.lower():
httplib:475:             return False
httplib:441:         length = self.msg.getheader('content-length')
rfc822:292:         return self.dict.get(name.lower(), default)
httplib:442:         if length and not self.chunked:
httplib:443:             try:
httplib:444:                 self.length = int(length)
httplib:448:                 if self.length < 0:  # ignore nonsensical negative lengths
httplib:454:         if (status == NO_CONTENT or status == NOT_MODIFIED or
httplib:455:             100 <= status < 200 or      # 1xx codes
httplib:456:             self._method == 'HEAD'):
httplib:462:         if not self.will_close and \
httplib:463:            not self.chunked and \
httplib:464:            self.length is None:
httplib:987:         assert response.will_close != _UNKNOWN
httplib:988:         self.__state = _CS_IDLE
httplib:990:         if response.will_close:
httplib:995:             self.__response = response
httplib:997:         return response
httplib20_7_1:1167:                 content = ""
httplib20_7_1:1168:                 if method == "HEAD":
httplib20_7_1:1171:                     content = response.read()
httplib:514:         if self.fp is None:
httplib:517:         if self.chunked:
httplib:520:         if amt is None:
httplib:522:             if self.length is None:
httplib:525:                 s = self._safe_read(self.length)
httplib:613:         s = []
httplib:614:         while amt > 0:
httplib:615:             chunk = self.fp.read(min(amt, MAXAMOUNT))
socket:319:         rbufsize = max(self._rbufsize, self.default_bufsize)
socket:323:         buf = self._rbuf
socket:324:         buf.seek(0, 2)  # seek end
socket:325:         if size < 0:
socket:336:             buf_len = buf.tell()
socket:337:             if buf_len >= size:
socket:345:             self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
socket:346:             while True:
socket:347:                 left = size - buf_len
socket:353:                 data = self._sock.recv(left)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:354:                 if not data:
socket:356:                 n = len(data)
socket:357:                 if n == size and not buf_len:
socket:364:                 if n == left:
socket:368:                 assert n <= left, "recv(%d) returned %d bytes" % (left, n)
socket:369:                 buf.write(data)
socket:370:                 buf_len += n
socket:371:                 del data  # explicit free
socket:346:             while True:
socket:347:                 left = size - buf_len
socket:353:                 data = self._sock.recv(left)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:354:                 if not data:
socket:356:                 n = len(data)
socket:357:                 if n == size and not buf_len:
socket:364:                 if n == left:
socket:368:                 assert n <= left, "recv(%d) returned %d bytes" % (left, n)
socket:369:                 buf.write(data)
socket:370:                 buf_len += n
socket:371:                 del data  # explicit free
socket:346:             while True:
socket:347:                 left = size - buf_len
socket:353:                 data = self._sock.recv(left)
eventlet.green.ssl:150:         if self._sslobj:
eventlet.green.ssl:151:             if flags != 0:
eventlet.green.ssl:155:             read = self.read(buflen)
eventlet.green.ssl:101:         return self._call_trampolining(
eventlet.green.ssl:102:             super(GreenSSLSocket, self).read, len)
eventlet.green.ssl:72:         if self.act_non_blocking:
eventlet.green.ssl:75:             while True:
eventlet.green.ssl:76:                 try:
eventlet.green.ssl:77:                     return func(*a, **kw)
ssl:135:         try:
ssl:136:             return self._sslobj.read(len)
eventlet.green.ssl:156:             return read
socket:354:                 if not data:
socket:356:                 n = len(data)
socket:357:                 if n == size and not buf_len:
socket:364:                 if n == left:
socket:365:                     buf.write(data)
socket:366:                     del data  # explicit free
socket:367:                     break
socket:373:             return buf.getvalue()
httplib:616:             if not chunk:
httplib:618:             s.append(chunk)
httplib:619:             amt -= len(chunk)
httplib:614:         while amt > 0:
httplib:620:         return ''.join(s)
httplib:526:                 self.length = 0
httplib:527:             self.close()        # we read everything
httplib:498:         if self.fp:
httplib:499:             self.fp.close()
socket:266:         try:
socket:267:             if self._sock:
socket:268:                 self.flush()
socket:282:         if self._wbuf:
socket:270:             if self._close:
socket:272:             self._sock = None
httplib:500:             self.fp = None
socket:275:         try:
socket:276:             self.close()
socket:266:         try:
socket:267:             if self._sock:
socket:270:             if self._close:
socket:272:             self._sock = None
httplib:528:             return s
httplib20_7_1:1172:                 response = Response(response)
httplib20_7_1:1488:         if isinstance(info, httplib.HTTPResponse):
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib:629:         if self.msg is None:
httplib:631:         return self.msg.items()
rfc822:459:         return self.dict.items()
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1490:                 self[key.lower()] = value
httplib20_7_1:1489:             for key, value in info.getheaders():
httplib20_7_1:1491:             self.status = info.status
httplib20_7_1:1492:             self['status'] = str(self.status)
httplib20_7_1:1493:             self.reason = info.reason
httplib20_7_1:1494:             self.version = info.version
httplib20_7_1:1173:                 if method != "HEAD":
httplib20_7_1:1174:                     content = _decompressContent(response, content)
httplib20_7_1:379:     content = new_content
httplib20_7_1:380:     try:
httplib20_7_1:381:         encoding = response.get('content-encoding', None)
httplib20_7_1:382:         if encoding in ['gzip', 'deflate']:
httplib20_7_1:383:             if encoding == 'gzip':
httplib20_7_1:384:                 content = gzip.GzipFile(fileobj=StringIO.StringIO(new_content)).read()
StringIO:56:         if not isinstance(buf, basestring):
StringIO:58:         self.buf = buf
StringIO:59:         self.len = len(buf)
StringIO:60:         self.buflist = []
StringIO:61:         self.pos = 0
StringIO:62:         self.closed = False
StringIO:63:         self.softspace = 0
gzip:76:         if mode and 'b' not in mode:
gzip:78:         if fileobj is None:
gzip:80:         if filename is None:
gzip:81:             if hasattr(fileobj, 'name'): filename = fileobj.name
gzip:82:             else: filename = ''
gzip:83:         if mode is None:
gzip:84:             if hasattr(fileobj, 'mode'): mode = fileobj.mode
gzip:85:             else: mode = 'rb'
gzip:87:         if mode[0:1] == 'r':
gzip:88:             self.mode = READ
gzip:90:             self._new_member = True
gzip:91:             self.extrabuf = ""
gzip:92:             self.extrasize = 0
gzip:93:             self.name = filename
gzip:95:             self.min_readsize = 100
gzip:108:         self.fileobj = fileobj
gzip:109:         self.offset = 0
gzip:111:         if self.mode == WRITE:
gzip:201:         if self.mode != READ:
gzip:205:         if self.extrasize <= 0 and self.fileobj is None:
gzip:208:         readsize = 1024
gzip:209:         if size < 0:        # get the whole thing
gzip:210:             try:
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:247:             pos = self.fileobj.tell()   # Save current position
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:248:             self.fileobj.seek(0, 2)     # Seek to end of file
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:111:             pos += self.len
StringIO:112:         self.pos = max(0, pos)
gzip:249:             if pos == self.fileobj.tell():
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:252:                 self.fileobj.seek( pos ) # Return to original position
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:112:         self.pos = max(0, pos)
gzip:254:             self._init_read()
gzip:150:         self.crc = zlib.crc32("") & 0xffffffffL
gzip:151:         self.size = 0
gzip:255:             self._read_gzip_header()
gzip:154:         magic = self.fileobj.read(2)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:155:         if magic != '\037\213':
gzip:157:         method = ord( self.fileobj.read(1) )
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:158:         if method != 8:
gzip:160:         flag = ord( self.fileobj.read(1) )
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:164:         self.fileobj.read(6)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:166:         if flag & FEXTRA:
gzip:171:         if flag & FNAME:
gzip:177:         if flag & FCOMMENT:
gzip:183:         if flag & FHCRC:
gzip:256:             self.decompress = zlib.decompressobj(-zlib.MAX_WBITS)
gzip:257:             self._new_member = False
gzip:260:         buf = self.fileobj.read(size)
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:265:         if buf == "":
gzip:271:         uncompress = self.decompress.decompress(buf)
gzip:272:         self._add_read_data( uncompress )
gzip:288:         self.crc = zlib.crc32(data, self.crc) & 0xffffffffL
gzip:289:         self.extrabuf = self.extrabuf + data
gzip:290:         self.extrasize = self.extrasize + len(data)
gzip:291:         self.size = self.size + len(data)
gzip:274:         if self.decompress.unused_data != "":
gzip:280:             self.fileobj.seek( -len(self.decompress.unused_data)+8, 1)
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:109:             pos += self.pos
StringIO:112:         self.pos = max(0, pos)
gzip:284:             self._read_eof()
gzip:299:         self.fileobj.seek(-8, 1)
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:109:             pos += self.pos
StringIO:112:         self.pos = max(0, pos)
gzip:300:         crc32 = read32(self.fileobj)
gzip:24:     return struct.unpack("<I", input.read(4))[0]
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:301:         isize = read32(self.fileobj)  # may exceed 2GB
gzip:24:     return struct.unpack("<I", input.read(4))[0]
StringIO:127:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:128:         if self.buflist:
StringIO:131:         if n < 0:
StringIO:134:             newpos = min(self.pos+n, self.len)
StringIO:135:         r = self.buf[self.pos:newpos]
StringIO:136:         self.pos = newpos
StringIO:137:         return r
gzip:302:         if crc32 != self.crc:
gzip:305:         elif isize != (self.size & 0xffffffffL):
gzip:285:             self._new_member = True
gzip:213:                     readsize = min(self.max_read_chunk, readsize * 2)
gzip:211:                 while True:
gzip:212:                     self._read(readsize)
gzip:238:         if self.fileobj is None:
gzip:241:         if self._new_member:
gzip:247:             pos = self.fileobj.tell()   # Save current position
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:248:             self.fileobj.seek(0, 2)     # Seek to end of file
StringIO:104:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:105:         if self.buflist:
StringIO:108:         if mode == 1:
StringIO:110:         elif mode == 2:
StringIO:111:             pos += self.len
StringIO:112:         self.pos = max(0, pos)
gzip:249:             if pos == self.fileobj.tell():
StringIO:116:         _complain_ifclosed(self.closed)
StringIO:39:     if closed:
StringIO:117:         return self.pos
gzip:250:                 raise EOFError, "Reached EOF"
gzip:214:             except EOFError:
gzip:215:                 size = self.extrasize
gzip:225:         chunk = self.extrabuf[:size]
gzip:226:         self.extrabuf = self.extrabuf[size:]
gzip:227:         self.extrasize = self.extrasize - size
gzip:229:         self.offset += size
gzip:230:         return chunk
gzip:324:         try:
gzip:325:             if (self.myfileobj is None and
gzip:326:                 self.fileobj is None):
gzip:330:         self.close()
gzip:309:         if self.fileobj is None:
gzip:311:         if self.mode == WRITE:
gzip:317:         elif self.mode == READ:
gzip:318:             self.fileobj = None
gzip:319:         if self.myfileobj:
httplib20_7_1:385:             if encoding == 'deflate':
httplib20_7_1:387:             response['content-length'] = str(len(content))
httplib20_7_1:389:             response['-content-encoding'] = response['content-encoding']
httplib20_7_1:390:             del response['content-encoding']
httplib20_7_1:394:     return content
httplib20_7_1:1175:             break
httplib20_7_1:1176:         return (response, content)
httplib20_7_1:1190:         if auth:
httplib20_7_1:1196:         if response.status == 401:
httplib20_7_1:1205:         if (self.follow_all_redirects or (method in ["GET", "HEAD"]) or response.status == 303):
httplib20_7_1:1206:             if self.follow_redirects and response.status in [300, 301, 302, 303, 307]:
httplib20_7_1:1240:             elif response.status in [200, 203] and method in ["GET", "HEAD"]:
httplib20_7_1:1242:                 if not response.has_key('content-location'):
httplib20_7_1:1243:                     response['content-location'] = absolute_uri
httplib20_7_1:1244:                 _updateCache(headers, response, content, self.cache, cachekey)
httplib20_7_1:397:     if cachekey:
httplib20_7_1:1246:         return (response, content)
httplib20_7_1:1464:         return (response, content)
contextlib:21:         if type is None:
contextlib:22:             try:
contextlib:23:                 self.gen.next()
eventlet.pools:19:     ...
eventlet.pools:129:         if self.current_size > self.max_size:
eventlet.pools:133:         if self.waiting():
eventlet.pools:161:         return max(0, self.channel.getting() - self.channel.putting())
eventlet.queue:202:         return len(self.getters)
eventlet.queue:197:         return len(self.putters)
eventlet.pools:136:             if self.order_as_stack:
eventlet.pools:139:                 self.free_items.append(item)
contextlib:24:             except StopIteration:
contextlib:25:                 return
work:62:         return content
pool:435:         try:
pool:436:             self.selectsharesResponse( value, server)
pool:195:         server = self.servers[server_name]
pool:196:         if server['role'] not in self.api_pull:
pool:199:         if server['api_method'] == 'json':
pool:200:             info = json.loads(response)
json:304:     if (cls is None and encoding is None and object_hook is None and
json:305:             parse_int is None and parse_float is None and
json:306:             parse_constant is None and not kw):
json:307:         return _default_decoder.decode(s)
json.decoder:319:         obj, end = self.raw_decode(s, idx=_w(s, 0).end())
json.decoder:334:         kw.setdefault('context', self)
json.decoder:335:         try:
json.decoder:336:             obj, end = self._scanner.iterscan(s, **kw).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:163:     pairs = {}
json.decoder:164:     s = match.string
json.decoder:165:     end = _w(s, match.end()).end()
json.decoder:166:     nextchar = s[end:end + 1]
json.decoder:168:     if nextchar == '}':
json.decoder:170:     if nextchar != '"':
json.decoder:172:     end += 1
json.decoder:173:     encoding = getattr(context, 'encoding', None)
json.decoder:174:     strict = getattr(context, 'strict', True)
json.decoder:175:     iterscan = JSONScanner.iterscan
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:61:     match = JSONNumber.regex.match(match.string, *match.span())
json.decoder:62:     integer, frac, exp = match.groups()
json.decoder:63:     if frac or exp:
json.decoder:67:         fn = getattr(context, 'parse_int', None) or int
json.decoder:68:         res = fn(integer)
json.decoder:69:     return res, None
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:61:     match = JSONNumber.regex.match(match.string, *match.span())
json.decoder:62:     integer, frac, exp = match.groups()
json.decoder:63:     if frac or exp:
json.decoder:67:         fn = getattr(context, 'parse_int', None) or int
json.decoder:68:         res = fn(integer)
json.decoder:69:     return res, None
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:191:             break
json.decoder:199:     object_hook = getattr(context, 'object_hook', None)
json.decoder:200:     if object_hook is not None:
json.decoder:202:     return pairs, end
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:339:         return obj, end
json.decoder:320:         end = _w(s, end).end()
json.decoder:321:         if end != len(s):
json.decoder:323:         return obj
pool:201:             for value in server['api_key'].split(','):
pool:202:                 info = info[value]
pool:201:             for value in server['api_key'].split(','):
pool:203:             if 'api_strip' in server:
pool:207:             round_shares = int(info)
pool:208:             if round_shares == None:
pool:211:             ghash = self.get_ghash(server, response, True)
pool:333:         if is_json == True:
pool:334:             info = json.loads(response)
json:304:     if (cls is None and encoding is None and object_hook is None and
json:305:             parse_int is None and parse_float is None and
json:306:             parse_constant is None and not kw):
json:307:         return _default_decoder.decode(s)
json.decoder:319:         obj, end = self.raw_decode(s, idx=_w(s, 0).end())
json.decoder:334:         kw.setdefault('context', self)
json.decoder:335:         try:
json.decoder:336:             obj, end = self._scanner.iterscan(s, **kw).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:163:     pairs = {}
json.decoder:164:     s = match.string
json.decoder:165:     end = _w(s, match.end()).end()
json.decoder:166:     nextchar = s[end:end + 1]
json.decoder:168:     if nextchar == '}':
json.decoder:170:     if nextchar != '"':
json.decoder:172:     end += 1
json.decoder:173:     encoding = getattr(context, 'encoding', None)
json.decoder:174:     strict = getattr(context, 'strict', True)
json.decoder:175:     iterscan = JSONScanner.iterscan
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:61:     match = JSONNumber.regex.match(match.string, *match.span())
json.decoder:62:     integer, frac, exp = match.groups()
json.decoder:63:     if frac or exp:
json.decoder:67:         fn = getattr(context, 'parse_int', None) or int
json.decoder:68:         res = fn(integer)
json.decoder:69:     return res, None
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:61:     match = JSONNumber.regex.match(match.string, *match.span())
json.decoder:62:     integer, frac, exp = match.groups()
json.decoder:63:     if frac or exp:
json.decoder:67:         fn = getattr(context, 'parse_int', None) or int
json.decoder:68:         res = fn(integer)
json.decoder:69:     return res, None
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:191:             break
json.decoder:199:     object_hook = getattr(context, 'object_hook', None)
json.decoder:200:     if object_hook is not None:
json.decoder:202:     return pairs, end
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:339:         return obj, end
json.decoder:320:         end = _w(s, end).end()
json.decoder:321:         if end != len(s):
json.decoder:323:         return obj
pool:335:             if 'api_key_ghashrate' in server:
pool:339:             if 'api_key_mhashrate' in server:
pool:340:                 for value in server['api_key_mhashrate'].split(','):
pool:341:                     info = info[value]
pool:340:                 for value in server['api_key_mhashrate'].split(','):
pool:342:                 return float(info) / 1000.0
pool:212:             if ghash > 0:
pool:213:                 server['ghash'] = ghash
pool:214:             if 'api_key_duration' in server:
pool:215:                 dur = json.loads(response)
json:304:     if (cls is None and encoding is None and object_hook is None and
json:305:             parse_int is None and parse_float is None and
json:306:             parse_constant is None and not kw):
json:307:         return _default_decoder.decode(s)
json.decoder:319:         obj, end = self.raw_decode(s, idx=_w(s, 0).end())
json.decoder:334:         kw.setdefault('context', self)
json.decoder:335:         try:
json.decoder:336:             obj, end = self._scanner.iterscan(s, **kw).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:163:     pairs = {}
json.decoder:164:     s = match.string
json.decoder:165:     end = _w(s, match.end()).end()
json.decoder:166:     nextchar = s[end:end + 1]
json.decoder:168:     if nextchar == '}':
json.decoder:170:     if nextchar != '"':
json.decoder:172:     end += 1
json.decoder:173:     encoding = getattr(context, 'encoding', None)
json.decoder:174:     strict = getattr(context, 'strict', True)
json.decoder:175:     iterscan = JSONScanner.iterscan
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:153:     encoding = getattr(context, 'encoding', None)
json.decoder:154:     strict = getattr(context, 'strict', True)
json.decoder:155:     return scanstring(match.string, match.end(), encoding, strict)
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:61:     match = JSONNumber.regex.match(match.string, *match.span())
json.decoder:62:     integer, frac, exp = match.groups()
json.decoder:63:     if frac or exp:
json.decoder:67:         fn = getattr(context, 'parse_int', None) or int
json.decoder:68:         res = fn(integer)
json.decoder:69:     return res, None
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:192:         if nextchar != ',':
json.decoder:194:         end = _w(s, end).end()
json.decoder:195:         nextchar = s[end:end + 1]
json.decoder:196:         end += 1
json.decoder:197:         if nextchar != '"':
json.decoder:176:     while True:
json.decoder:177:         key, end = scanstring(s, end, encoding, strict)
json.decoder:178:         end = _w(s, end).end()
json.decoder:179:         if s[end:end + 1] != ':':
json.decoder:181:         end = _w(s, end + 1).end()
json.decoder:182:         try:
json.decoder:183:             value, end = iterscan(s, idx=end, context=context).next()
json.scanner:42:         match = self.scanner.scanner(string, idx).match
json.scanner:43:         actions = self.actions
json.scanner:44:         lastend = idx
json.scanner:45:         end = len(string)
json.scanner:46:         while True:
json.scanner:47:             m = match()
json.scanner:48:             if m is None:
json.scanner:50:             matchbegin, matchend = m.span()
json.scanner:51:             if lastend == matchend:
json.scanner:53:             action = actions[m.lastindex]
json.scanner:54:             if action is not None:
json.scanner:55:                 rval, next_pos = action(m, context)
json.decoder:61:     match = JSONNumber.regex.match(match.string, *match.span())
json.decoder:62:     integer, frac, exp = match.groups()
json.decoder:63:     if frac or exp:
json.decoder:67:         fn = getattr(context, 'parse_int', None) or int
json.decoder:68:         res = fn(integer)
json.decoder:69:     return res, None
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:60:                 yield rval, matchend
json.decoder:186:         pairs[key] = value
json.decoder:187:         end = _w(s, end).end()
json.decoder:188:         nextchar = s[end:end + 1]
json.decoder:189:         end += 1
json.decoder:190:         if nextchar == '}':
json.decoder:191:             break
json.decoder:199:     object_hook = getattr(context, 'object_hook', None)
json.decoder:200:     if object_hook is not None:
json.decoder:202:     return pairs, end
json.scanner:56:                 if next_pos is not None and next_pos != matchend:
json.scanner:58:                     matchend = next_pos
json.scanner:59:                     match = self.scanner.scanner(string, matchend).match
json.scanner:60:                 yield rval, matchend
json.decoder:339:         return obj, end
json.decoder:320:         end = _w(s, end).end()
json.decoder:321:         if end != len(s):
json.decoder:323:         return obj
pool:216:                 for value in server['api_key_duration'].split(','):
pool:217:                     dur = dur[value]
pool:216:                 for value in server['api_key_duration'].split(','):
pool:218:                 duration = self.get_duration(server, str(dur))
pool:368:         duration = -1 # I think this is not needed anymore? Could somebody double check?
pool:369:         if 'api_key_duration_day_hour_min' in server:
pool:393:         elif 'api_key_duration_hour_min' in server:
pool:410:         elif 'api_key_duration_min' in server:
pool:420:         elif 'api_key_duration_sec' in server:
pool:421:             output = re.search(server['api_key_duration_sec'], response)
re:142:     return _compile(pattern, flags).search(string)
re:231:     cachekey = (type(key[0]),) + key
re:232:     p = _cache.get(cachekey)
re:233:     if p is not None:
re:234:         return p
pool:422:             try:
pool:423:                 duration = int(output.group(1).replace(' ', ''))
pool:427:         return duration
pool:219:                 if duration > 0:
pool:220:                     server['duration'] = duration
pool:222:             self.UpdateShares(server_name,round_shares)
pool:133:         with self.lock:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:68:             self._waiters.add(greenthread.getcurrent())
eventlet.semaphore:69:             try:
eventlet.semaphore:70:                 while self.counter <= 0:
eventlet.semaphore:71:                     hubs.get_hub().switch()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.poll:98:                 if event & WRITE_MASK:
eventlet.hubs.poll:100:                 if event & select.POLLNVAL:
eventlet.hubs.poll:103:                 if event & EXC_MASK:
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.hubs.timer:67:         if not self.called:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:74:         self.counter -= 1
eventlet.semaphore:75:         return True
threading:124:         if rc:
threading:125:             self.__owner = me
threading:126:             self.__count = 1
threading:128:                 self._note("%s.acquire(%s): initial success", self, blocking)
threading:65:             if self.__verbose:
threading:132:         return rc
threading:150:         self.release()
threading:137:         if self.__owner != _get_ident():
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:139:         self.__count = count = self.__count - 1
threading:140:         if not count:
threading:141:             self.__owner = None
threading:142:             self.__block.release()
eventlet.semaphore:87:         self.counter += 1
eventlet.semaphore:88:         if self._waiters:
eventlet.semaphore:90:         return True
threading:144:                 self._note("%s.release(): final release", self)
threading:65:             if self.__verbose:
eventlet.greenthread:25:     hub = hubs.get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.greenthread:26:     current = getcurrent()
eventlet.greenthread:27:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.greenthread:28:     timer = hub.schedule_call_global(seconds, current.switch)
eventlet.hubs.hub:313:         t = timer.Timer(seconds, cb, *args, **kw)
eventlet.hubs.timer:19:         self.seconds = seconds
eventlet.hubs.timer:20:         self.tpl = cb, args, kw
eventlet.hubs.timer:21:         self.called = False
eventlet.hubs.timer:22:         if _g_debug:
eventlet.hubs.hub:314:         self.add_timer(t)
eventlet.hubs.hub:269:         scheduled_time = self.clock() + timer.seconds
eventlet.hubs.hub:270:         self.next_timers.append((scheduled_time, timer))
eventlet.hubs.hub:271:         return scheduled_time
eventlet.hubs.hub:315:         return t
eventlet.greenthread:29:     try:
eventlet.greenthread:30:         hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.timer:58:                 try:
eventlet.hubs.timer:59:                     del self.tpl
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:286:             if item[1].called:
eventlet.hubs.hub:289:                 heappush(t, item)
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.hubs.timer:67:         if not self.called:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:74:         self.counter -= 1
eventlet.semaphore:75:         return True
threading:124:         if rc:
threading:125:             self.__owner = me
threading:126:             self.__count = 1
threading:128:                 self._note("%s.acquire(%s): initial success", self, blocking)
threading:65:             if self.__verbose:
threading:132:         return rc
threading:150:         self.release()
threading:137:         if self.__owner != _get_ident():
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:139:         self.__count = count = self.__count - 1
threading:140:         if not count:
threading:141:             self.__owner = None
threading:142:             self.__block.release()
eventlet.semaphore:87:         self.counter += 1
eventlet.semaphore:88:         if self._waiters:
eventlet.semaphore:90:         return True
threading:144:                 self._note("%s.release(): final release", self)
threading:65:             if self.__verbose:
eventlet.greenthread:25:     hub = hubs.get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.greenthread:26:     current = getcurrent()
eventlet.greenthread:27:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.greenthread:28:     timer = hub.schedule_call_global(seconds, current.switch)
eventlet.hubs.hub:313:         t = timer.Timer(seconds, cb, *args, **kw)
eventlet.hubs.timer:19:         self.seconds = seconds
eventlet.hubs.timer:20:         self.tpl = cb, args, kw
eventlet.hubs.timer:21:         self.called = False
eventlet.hubs.timer:22:         if _g_debug:
eventlet.hubs.hub:314:         self.add_timer(t)
eventlet.hubs.hub:269:         scheduled_time = self.clock() + timer.seconds
eventlet.hubs.hub:270:         self.next_timers.append((scheduled_time, timer))
eventlet.hubs.hub:271:         return scheduled_time
eventlet.hubs.hub:315:         return t
eventlet.greenthread:29:     try:
eventlet.greenthread:30:         hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.timer:58:                 try:
eventlet.hubs.timer:59:                     del self.tpl
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:286:             if item[1].called:
eventlet.hubs.hub:289:                 heappush(t, item)
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.greenthread:32:         timer.cancel()
eventlet.hubs.timer:67:         if not self.called:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:74:         self.counter -= 1
eventlet.semaphore:75:         return True
threading:124:         if rc:
threading:125:             self.__owner = me
threading:126:             self.__count = 1
threading:128:                 self._note("%s.acquire(%s): initial success", self, blocking)
threading:65:             if self.__verbose:
threading:132:         return rc
threading:150:         self.release()
threading:137:         if self.__owner != _get_ident():
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:139:         self.__count = count = self.__count - 1
threading:140:         if not count:
threading:141:             self.__owner = None
threading:142:             self.__block.release()
eventlet.semaphore:87:         self.counter += 1
eventlet.semaphore:88:         if self._waiters:
eventlet.semaphore:90:         return True
threading:144:                 self._note("%s.release(): final release", self)
threading:65:             if self.__verbose:
eventlet.greenthread:25:     hub = hubs.get_hub()
eventlet.hubs:77:     try:
eventlet.hubs:78:         hub = _threadlocal.hub
eventlet.hubs:85:     return hub
eventlet.greenthread:26:     current = getcurrent()
eventlet.greenthread:27:     assert hub.greenlet is not current, 'do not call blocking functions from the mainloop'
eventlet.greenthread:28:     timer = hub.schedule_call_global(seconds, current.switch)
eventlet.hubs.hub:313:         t = timer.Timer(seconds, cb, *args, **kw)
eventlet.hubs.timer:19:         self.seconds = seconds
eventlet.hubs.timer:20:         self.tpl = cb, args, kw
eventlet.hubs.timer:21:         self.called = False
eventlet.hubs.timer:22:         if _g_debug:
eventlet.hubs.hub:314:         self.add_timer(t)
eventlet.hubs.hub:269:         scheduled_time = self.clock() + timer.seconds
eventlet.hubs.hub:270:         self.next_timers.append((scheduled_time, timer))
eventlet.hubs.hub:271:         return scheduled_time
eventlet.hubs.hub:315:         return t
eventlet.greenthread:29:     try:
eventlet.greenthread:30:         hub.switch()
eventlet.hubs.hub:161:         cur = greenlet.getcurrent()
eventlet.hubs.hub:162:         assert cur is not self.greenlet, 'Cannot switch to MAINLOOP from MAINLOOP'
eventlet.hubs.hub:163:         switch_out = getattr(cur, 'switch_out', None)
eventlet.hubs.hub:164:         if switch_out is not None:
eventlet.hubs.hub:169:         if self.greenlet.dead:
eventlet.hubs.hub:171:         try:
eventlet.hubs.hub:172:             if self.greenlet.parent is not cur:
eventlet.hubs.hub:173:                 cur.parent = self.greenlet
eventlet.hubs.hub:176:         clear_sys_exc_info()
eventlet.hubs.hub:177:         return self.greenlet.switch()
eventlet.hubs.timer:58:                 try:
eventlet.hubs.timer:59:                     del self.tpl
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:286:             if item[1].called:
eventlet.hubs.hub:289:                 heappush(t, item)
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:328:                 break
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:196:         t = self.timers
eventlet.hubs.hub:197:         if not t:
eventlet.hubs.hub:199:         return t[0][0]
eventlet.hubs.poll:76:         readers = self.listeners[READ]
eventlet.hubs.poll:77:         writers = self.listeners[WRITE]
eventlet.hubs.poll:79:         if not readers and not writers:
eventlet.hubs.poll:83:         try:
eventlet.hubs.poll:84:             presult = self.do_poll(seconds)
eventlet.hubs.epolls:59:         return self.poll.poll(seconds)
eventlet.hubs.poll:89:         SYSTEM_EXCEPTIONS = self.SYSTEM_EXCEPTIONS
eventlet.hubs.poll:91:         if self.debug_blocking:
eventlet.hubs.poll:92:             self.block_detect_pre()
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.poll:94:         for fileno, event in presult:
eventlet.hubs.poll:112:         if self.debug_blocking:
eventlet.hubs.poll:113:             self.block_detect_post()
eventlet.hubs.hub:100:         if (hasattr(self, "_old_signal_handler") and
eventlet.hubs.hub:101:             self._old_signal_handler):
eventlet.hubs.hub:103:         signal.alarm(0)
eventlet.hubs.hub:283:         heappush = heapq.heappush
eventlet.hubs.hub:284:         t = self.timers
eventlet.hubs.hub:285:         for item in self.next_timers:
eventlet.hubs.hub:290:         del self.next_timers[:]
eventlet.hubs.hub:93:         tmp = signal.signal(signal.SIGALRM, alarm_handler)
eventlet.hubs.hub:94:         if tmp != alarm_handler:
eventlet.hubs.hub:97:         arm_alarm(self.debug_blocking_resolution)
eventlet.hubs.hub:11:         signal.setitimer(signal.ITIMER_REAL, seconds)
eventlet.hubs.hub:318:         t = self.timers
eventlet.hubs.hub:319:         heappop = heapq.heappop
eventlet.hubs.hub:321:         while t:
eventlet.hubs.hub:322:             next = t[0]
eventlet.hubs.hub:324:             exp = next[0]
eventlet.hubs.hub:325:             timer = next[1]
eventlet.hubs.hub:327:             if when < exp:
eventlet.hubs.hub:330:             heappop(t)
eventlet.hubs.hub:332:             try:
eventlet.hubs.hub:333:                 if timer.called:
eventlet.hubs.hub:336:                     timer()
eventlet.hubs.timer:52:         if not self.called:
eventlet.hubs.timer:53:             self.called = True
eventlet.hubs.timer:54:             cb, args, kw = self.tpl
eventlet.hubs.timer:55:             try:
eventlet.hubs.timer:56:                 cb(*args, **kw)
eventlet.greenthread:32:         timer.cancel()
eventlet.hubs.timer:67:         if not self.called:
threading:117:         me = _get_ident()
eventlet.green.thread:18:     if gr is None:
eventlet.green.thread:19:         return id(greenlet.getcurrent())
threading:118:         if self.__owner == me:
threading:123:         rc = self.__block.acquire(blocking)
eventlet.semaphore:65:         if not blocking and self.locked():
eventlet.semaphore:67:         if self.counter <= 0:
eventlet.semaphore:74:         self.counter -= 1
eventlet.semaphore:75:         return True
threading:124:         if rc:
threading:125:             self.__owner = me
threading:126:             self.__count = 1
threading:128:                 self._note("%s.acquire(%s): initial success", self, blocking)
threading:65:             if self.__verbose:
threading:132:         return rc
__main__:71:         if kwargs and kwargs.get('cat'):
__main__:73:         elif self.get_options() == None:
__main__:68:         return self.options
optparse:848:         if isinstance(other, Values):
optparse:850:         elif isinstance(other, types.DictType):
optparse:853:             return -1
__main__:76:         elif self.get_options().debug == True:
__main__:68:         return self.options
__main__:77:             print time.strftime("[%H:%M:%S] ") +str(msg)
[18:09:19] writing to database
__main__:78:             if str(msg).find("writing to database") > -1:
__main__:79:                 self.dbwrite += 1
__main__:82:             if self.dbwrite > 1:
__main__:83:                 print "2 DBWRITE CALLS FOUND IN A ROW " + str(self.dbwrite)
2 DBWRITE CALLS FOUND IN A ROW 3